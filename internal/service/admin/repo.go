package admin

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/lib/pq"
	adminpb "github.com/nmxmxh/master-ovasabi/api/protos/admin/v1"
	commonpb "github.com/nmxmxh/master-ovasabi/api/protos/common/v1"
	repo "github.com/nmxmxh/master-ovasabi/internal/repository"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/types/known/timestamppb"
)

var (
	ErrUserNotFound = errors.New("admin user not found")
	ErrRoleNotFound = errors.New("admin role not found")
)

type Repository struct {
	db         *sql.DB
	masterRepo repo.MasterRepository
}

func NewRepository(db *sql.DB, masterRepo repo.MasterRepository) *Repository {
	return &Repository{db: db, masterRepo: masterRepo}
}

// User management.
func (r *Repository) CreateUser(ctx context.Context, user *adminpb.User) (*adminpb.User, error) {
	metadataJSON, err := marshalMetadata(user.Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal user metadata: %w", err)
	}
	row := r.db.QueryRowContext(ctx, `
		INSERT INTO service_admin_user (id, master_id, master_uuid, email, name, roles, is_active, created_at, updated_at, user_id, metadata) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW(), $8, $9)
		RETURNING id, master_id, master_uuid, email, name, roles, is_active, created_at, updated_at, user_id, metadata
	`, user.Id, user.MasterId, user.MasterUuid, user.Email, user.Name, pq.Array(user.Roles), user.IsActive, user.UserId, metadataJSON)
	createdUser, _, err := scanUser(row, false)
	if err != nil {
		return nil, err
	}

	// Ensure master_id and master_uuid are set on the returned user object
	// This is crucial if the master_id/master_uuid are generated by the DB or masterRepo.
	// For admin users, it's common for them to be linked to existing user master entities.
	// If admin users are *new* master entities, this logic needs to be in a transaction
	// and use masterRepo.Create.
	// Assuming admin users are linked to existing master entities or their master_id/uuid are provided.
	// If `user.MasterId` and `user.MasterUuid` are expected to be generated here,
	// then this `CreateUser` method should also use `r.masterRepo.Create` within a transaction.
	// For now, I'll assume they are pre-populated or handled externally.
	// If not, this needs further refactoring.

	return createdUser, nil
}

func (r *Repository) UpdateUser(ctx context.Context, user *adminpb.User) (*adminpb.User, error) {
	metadataJSON, err := marshalMetadata(user.Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal user metadata for update: %w", err)
	}
	row := r.db.QueryRowContext(ctx, `
		UPDATE service_admin_user SET email=$1, name=$2, roles=$3, is_active=$4, metadata=$5, updated_at=now() WHERE id=$6
		RETURNING id, master_id, master_uuid, email, name, roles, is_active, created_at, updated_at, user_id, metadata
	`, user.Email, user.Name, pq.Array(user.Roles), user.IsActive, metadataJSON, user.Id)
	updatedUser, _, err := scanUser(row, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrUserNotFound
		}
		return nil, err
	}
	return updatedUser, nil
}

func (r *Repository) DeleteUser(ctx context.Context, userID string) error {
	_, err := r.db.ExecContext(ctx, `DELETE FROM service_admin_user WHERE id=$1`, userID)
	return err
}

func (r *Repository) ListUsers(ctx context.Context, page, pageSize int) ([]*adminpb.User, int, error) {
	offset := (page - 1) * pageSize
	rows, err := r.db.QueryContext(ctx, `
		SELECT id, master_id, master_uuid, email, name, roles, is_active, created_at, updated_at, user_id, metadata, count(*) OVER() AS total_count
		FROM service_admin_user ORDER BY email LIMIT $1 OFFSET $2
	`, pageSize, offset)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()
	var users []*adminpb.User
	var total int
	for rows.Next() {
		user, currentTotal, err := scanUser(rows, true)
		if err != nil {
			return nil, 0, err
		}
		users = append(users, user)
		total = currentTotal
	}
	if err := rows.Err(); err != nil {
		return nil, 0, err
	}
	return users, total, nil
}

func (r *Repository) GetUser(ctx context.Context, id string) (*adminpb.User, error) {
	row := r.db.QueryRowContext(ctx, `
		SELECT id, master_id, master_uuid, email, name, roles, is_active, created_at, updated_at, user_id, metadata
		FROM service_admin_user WHERE id = $1
	`, id)
	user, _, err := scanUser(row, false)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrUserNotFound
		}
		return nil, err
	}
	return user, nil
}

// Role management.
func (r *Repository) CreateRole(ctx context.Context, role *adminpb.Role) (*adminpb.Role, error) {
	// Create a master entity record for the role to ensure it's a first-class citizen.
	// This operation is now atomic within a transaction.
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction for role creation: %w", err)
	}
	defer func() {
		if r := recover(); r != nil {
			_ = tx.Rollback()
			panic(r) // Re-throw panic
		}
	}()

	// 1. Use masterRepo to create the master entity record
	// adminpb.Role has MasterUuid field.
	role.MasterId, role.MasterUuid, err = r.masterRepo.Create(ctx, tx, repo.EntityTypeRole, role.Name)
	if err != nil {
		return nil, fmt.Errorf("failed to create master entity for role %s: %w", role.Name, err)
	}

	metadataJSON, err := marshalMetadata(role.Metadata)
	if err != nil {
		_ = tx.Rollback()
		return nil, fmt.Errorf("failed to marshal role metadata: %w", err)
	}
	row := tx.QueryRowContext(ctx, `
		INSERT INTO service_admin_role (id, master_id, master_uuid, name, permissions, metadata, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, now(), now())
		RETURNING id, master_id, master_uuid, name, permissions, metadata
	`, role.Id, role.MasterId, role.MasterUuid, role.Name, pq.Array(role.Permissions), metadataJSON)

	var createdRole adminpb.Role
	var masterID int64    // Temporary for scanning
	var masterUUID string // Temporary for scanning
	var permissions []string
	var returnedMetadataJSON sql.NullString
	if err := row.Scan(&createdRole.Id, &masterID, &masterUUID, &createdRole.Name, pq.Array(&permissions), &returnedMetadataJSON); err != nil {
		return nil, err
	}

	createdRole.MasterId = masterID
	createdRole.MasterUuid = masterUUID
	createdRole.Permissions = permissions
	if err := unmarshalMetadata([]byte(returnedMetadataJSON.String), &createdRole.Metadata); err != nil {
		return nil, fmt.Errorf("failed to unmarshal created role metadata: %w", err)
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction for role creation: %w", err)
	}

	return &createdRole, nil
}

func (r *Repository) UpdateRole(ctx context.Context, role *adminpb.Role) (*adminpb.Role, error) {
	metadataJSON, err := marshalMetadata(role.Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal role metadata for update: %w", err)
	}
	row := r.db.QueryRowContext(ctx, `
		UPDATE service_admin_role SET name=$1, permissions=$2, metadata=$3, updated_at=now() WHERE id=$4
		RETURNING id, master_id, name, permissions, metadata
	`, role.Name, pq.Array(role.Permissions), metadataJSON, role.Id)

	var updatedRole adminpb.Role
	var masterID int64    // Temporary for scanning
	var masterUUID string // Temporary for scanning
	var permissions []string
	var returnedMetadataJSON sql.NullString
	if err := row.Scan(&updatedRole.Id, &masterID, &masterUUID, &updatedRole.Name, pq.Array(&permissions), &returnedMetadataJSON); err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrRoleNotFound
		}
		return nil, err
	}

	updatedRole.MasterId = masterID
	updatedRole.MasterUuid = masterUUID
	updatedRole.Permissions = permissions
	if err := unmarshalMetadata([]byte(returnedMetadataJSON.String), &updatedRole.Metadata); err != nil {
		return nil, fmt.Errorf("failed to unmarshal updated role metadata: %w", err)
	}

	return &updatedRole, nil
}

func (r *Repository) DeleteRole(ctx context.Context, roleID string) error {
	_, err := r.db.ExecContext(ctx, `DELETE FROM service_admin_role WHERE id=$1`, roleID)
	return err
}

func (r *Repository) ListRoles(ctx context.Context, page, pageSize int) ([]*adminpb.Role, int, error) {
	offset := (page - 1) * pageSize
	rows, err := r.db.QueryContext(ctx, `
		SELECT id, master_id, name, permissions, metadata, count(*) OVER() AS total_count
		FROM service_admin_role ORDER BY name LIMIT $1 OFFSET $2
	`, pageSize, offset)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()
	var roles []*adminpb.Role
	var total int
	for rows.Next() {
		var role adminpb.Role
		var masterID int64
		var masterUUID string
		var permissions []string
		var metadataJSON sql.NullString
		if err := rows.Scan(&role.Id, &masterID, &masterUUID, &role.Name, pq.Array(&permissions), &metadataJSON, &total); err != nil {
			return nil, 0, err
		}
		role.MasterId = masterID
		role.MasterUuid = masterUUID
		role.Permissions = permissions
		if err := unmarshalMetadata([]byte(metadataJSON.String), &role.Metadata); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal role metadata in list: %w", err)
		}
		roles = append(roles, &role)
	}
	if err := rows.Err(); err != nil {
		return nil, 0, err
	}
	return roles, total, nil
}

// Role assignment.
func (r *Repository) AssignRole(ctx context.Context, userID, roleID string) error {
	_, err := r.db.ExecContext(ctx, `
		INSERT INTO service_admin_user_role (user_id, role_id) VALUES ($1, $2) ON CONFLICT DO NOTHING
	`, userID, roleID)
	return err
}

func (r *Repository) RevokeRole(ctx context.Context, userID, roleID string) error {
	_, err := r.db.ExecContext(ctx, `DELETE FROM service_admin_user_role WHERE user_id=$1 AND role_id=$2`, userID, roleID)
	return err
}

// Settings management.
func (r *Repository) GetSettings(ctx context.Context) (*adminpb.Settings, error) {
	row := r.db.QueryRowContext(ctx, `SELECT values, metadata FROM service_admin_settings ORDER BY updated_at DESC LIMIT 1`)
	var valuesJSON []byte
	var metaJSON sql.NullString
	settings := &adminpb.Settings{}
	err := row.Scan(&valuesJSON, &metaJSON)
	if err != nil {
		if err == sql.ErrNoRows {
			return &adminpb.Settings{}, nil // Return empty settings if none found
		}
		return nil, err
	}
	if len(valuesJSON) > 0 {
		// settings.Values is a map[string]string, so we use the standard json package.
		if err := json.Unmarshal(valuesJSON, &settings.Values); err != nil {
			return nil, err
		}
	}
	if err := unmarshalMetadata([]byte(metaJSON.String), &settings.Metadata); err != nil {
		return nil, fmt.Errorf("failed to unmarshal settings metadata: %w", err)
	}
	return settings, nil
}

func (r *Repository) UpdateSettings(ctx context.Context, s *adminpb.Settings) (*adminpb.Settings, error) {
	valuesJSON, err := json.Marshal(s.Values) // Values is map[string]string
	if err != nil {
		return nil, err
	}
	metaJSON, err := marshalMetadata(s.Metadata)
	if err != nil {
		return nil, err
	}
	_, err = r.db.ExecContext(ctx, `INSERT INTO service_admin_settings (values, metadata, updated_at) VALUES ($1, $2, now())`, valuesJSON, metaJSON)
	if err != nil {
		return nil, err
	}
	return r.GetSettings(ctx)
}

// Audit log management.
func (r *Repository) GetAuditLogs(ctx context.Context, page, pageSize int, userID, action string) ([]*adminpb.AuditLog, int, error) {
	query := "SELECT id, master_id, user_id, action, resource, details, timestamp, metadata FROM service_admin_audit_log WHERE 1=1"
	args := []interface{}{}
	argCount := 1
	if userID != "" {
		query += fmt.Sprintf(" AND user_id = $%d", argCount)
		args = append(args, userID)
		argCount++
	}
	if action != "" {
		query += fmt.Sprintf(" AND action = $%d", argCount)
		args = append(args, action)
		argCount++
	}
	query += fmt.Sprintf(" ORDER BY timestamp DESC LIMIT $%d OFFSET $%d", argCount, argCount+1)
	args = append(args, pageSize, (page-1)*pageSize)

	rows, err := r.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()
	var logs []*adminpb.AuditLog
	for rows.Next() {
		var l adminpb.AuditLog
		var metaJSON sql.NullString
		if err := rows.Scan(&l.Id, &l.MasterId, &l.UserId, &l.Action, &l.Resource, &l.Details, &l.Timestamp, &metaJSON); err != nil {
			return nil, 0, err
		}
		if err := unmarshalMetadata([]byte(metaJSON.String), &l.Metadata); err != nil {
			return nil, 0, fmt.Errorf("failed to unmarshal audit log metadata: %w", err)
		}
		logs = append(logs, &l)
	}
	if err := rows.Err(); err != nil {
		return nil, 0, err
	}

	// Count total using a separate query for accurate pagination.
	var total int
	countQuery := "SELECT count(*) FROM service_admin_audit_log WHERE 1=1"
	countArgs := []interface{}{}
	argCount = 1
	if userID != "" {
		countQuery += fmt.Sprintf(" AND user_id = $%d", argCount)
		countArgs = append(countArgs, userID)
		argCount++
	}
	if action != "" {
		countQuery += fmt.Sprintf(" AND action = $%d", argCount)
		countArgs = append(countArgs, action)
	}
	if err := r.db.QueryRowContext(ctx, countQuery, countArgs...).Scan(&total); err != nil {
		return nil, 0, fmt.Errorf("failed to count audit logs: %w", err)
	}

	return logs, total, nil
}

// marshalMetadata marshals a protobuf metadata message into a JSON byte slice.
// Returns nil if the metadata is nil.
func marshalMetadata(meta *commonpb.Metadata) ([]byte, error) {
	if meta == nil {
		return nil, nil
	}
	return protojson.Marshal(meta)
}

// unmarshalMetadata unmarshals a JSON byte slice into a protobuf metadata message.
// It initializes the metadata message if it's nil.
func unmarshalMetadata(data []byte, meta **commonpb.Metadata) error {
	if len(data) == 0 {
		*meta = nil
		return nil
	}
	if *meta == nil {
		*meta = &commonpb.Metadata{}
	}
	return protojson.Unmarshal(data, *meta)
}

// rowScanner is an interface that can scan a row from a database query.
// It is satisfied by both *sql.Row and *sql.Rows.
type rowScanner interface {
	Scan(dest ...interface{}) error
}

// scanUser scans a single adminpb.User from a rowScanner.
// If includeTotal is true, it also scans the total count (used for pagination queries).
func scanUser(scanner rowScanner, includeTotal bool) (*adminpb.User, int, error) {
	var user adminpb.User
	var roles []string                                        // Temporary for pq.Array
	var createdAtProto, updatedAtProto *timestamppb.Timestamp // For direct scanning
	var metadataJSON sql.NullString
	var total int

	dest := []interface{}{
		&user.Id, &user.MasterId, &user.MasterUuid, &user.Email, &user.Name,
		pq.Array(&roles), &user.IsActive, &createdAtProto, &updatedAtProto, &user.UserId, &metadataJSON,
	}

	if includeTotal {
		dest = append(dest, &total)
	}

	if err := scanner.Scan(dest...); err != nil {
		return nil, 0, err
	}
	user.Roles = roles
	user.CreatedAt = createdAtProto
	user.UpdatedAt = updatedAtProto
	if err := unmarshalMetadata([]byte(metadataJSON.String), &user.Metadata); err != nil {
		return nil, 0, fmt.Errorf("failed to unmarshal user metadata: %w", err)
	}
	return &user, total, nil
}
