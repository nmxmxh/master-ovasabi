// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: analytics/v1/analytics.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Metadata } from "../../common/v1/metadata";
import { Struct } from "../../google/protobuf/struct";

export const protobufPackage = "analytics.v1";

export interface Event {
  id: string;
  /** Internal integer ID for analytics/unified queries */
  masterId: string;
  /** Global UUID for external APIs and global uniqueness */
  masterUuid: string;
  userId: string;
  eventType: string;
  entityId: string;
  entityType: string;
  properties: { [key: string]: string };
  timestamp: string;
  /** Robust, extensible metadata */
  metadata?:
    | Metadata
    | undefined;
  /** campaign/tenant context */
  campaignId: string;
}

export interface Event_PropertiesEntry {
  key: string;
  value: string;
}

export interface TrackEventRequest {
  event?: Event | undefined;
}

export interface TrackEventResponse {
  success: boolean;
}

export interface BatchTrackEventsRequest {
  events: Event[];
}

export interface BatchTrackEventsResponse {
  successCount: number;
  failureCount: number;
}

export interface GetUserEventsRequest {
  userId: string;
  page: number;
  pageSize: number;
  /** campaign/tenant context */
  campaignId: string;
}

export interface GetUserEventsResponse {
  events: Event[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface GetProductEventsRequest {
  productId: string;
  page: number;
  pageSize: number;
  /** campaign/tenant context */
  campaignId: string;
}

export interface GetProductEventsResponse {
  events: Event[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface GetReportRequest {
  reportId: string;
  parameters: { [key: string]: string };
}

export interface GetReportRequest_ParametersEntry {
  key: string;
  value: string;
}

export interface GetReportResponse {
  report?: Report | undefined;
}

export interface ListReportsRequest {
  page: number;
  pageSize: number;
}

export interface ListReportsResponse {
  reports: Report[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface Report {
  id: string;
  name: string;
  description: string;
  parameters: { [key: string]: string };
  data: Uint8Array;
  createdAt: string;
}

export interface Report_ParametersEntry {
  key: string;
  value: string;
}

export interface CaptureEventRequest {
  eventType: string;
  userId: string;
  userEmail: string;
  properties?: { [key: string]: any } | undefined;
  groups?: { [key: string]: any } | undefined;
  context?: { [key: string]: any } | undefined;
  gdprObscure: boolean;
  /** campaign/tenant context */
  campaignId: string;
}

export interface CaptureEventResponse {
  eventId: string;
}

export interface AnalyticsEvent {
  eventId: string;
  timestamp: string;
  /** Robust, extensible metadata */
  metadata?:
    | Metadata
    | undefined;
  /** campaign/tenant context */
  campaignId: string;
}

/** Add pagination in future */
export interface ListEventsRequest {
}

export interface ListEventsResponse {
  events: AnalyticsEvent[];
}

export interface EnrichEventMetadataRequest {
  eventId: string;
  newFields?:
    | { [key: string]: any }
    | undefined;
  /** campaign/tenant context */
  campaignId: string;
}

export interface EnrichEventMetadataResponse {
  success: boolean;
}

function createBaseEvent(): Event {
  return {
    id: "",
    masterId: "0",
    masterUuid: "",
    userId: "",
    eventType: "",
    entityId: "",
    entityType: "",
    properties: {},
    timestamp: "0",
    metadata: undefined,
    campaignId: "0",
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.masterId !== "0") {
      writer.uint32(16).int64(message.masterId);
    }
    if (message.masterUuid !== "") {
      writer.uint32(82).string(message.masterUuid);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.eventType !== "") {
      writer.uint32(34).string(message.eventType);
    }
    if (message.entityId !== "") {
      writer.uint32(42).string(message.entityId);
    }
    if (message.entityType !== "") {
      writer.uint32(50).string(message.entityType);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      Event_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.timestamp !== "0") {
      writer.uint32(64).int64(message.timestamp);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(74).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(88).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.masterId = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = Event_PropertiesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.properties[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      masterId: isSet(object.masterId) ? globalThis.String(object.masterId) : "0",
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.masterId !== "0") {
      obj.masterId = message.masterId;
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = v;
        });
      }
    }
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.id = object.id ?? "";
    message.masterId = object.masterId ?? "0";
    message.masterUuid = object.masterUuid ?? "";
    message.userId = object.userId ?? "";
    message.eventType = object.eventType ?? "";
    message.entityId = object.entityId ?? "";
    message.entityType = object.entityType ?? "";
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.timestamp = object.timestamp ?? "0";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseEvent_PropertiesEntry(): Event_PropertiesEntry {
  return { key: "", value: "" };
}

export const Event_PropertiesEntry: MessageFns<Event_PropertiesEntry> = {
  encode(message: Event_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Event_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event_PropertiesEntry>, I>>(base?: I): Event_PropertiesEntry {
    return Event_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event_PropertiesEntry>, I>>(object: I): Event_PropertiesEntry {
    const message = createBaseEvent_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTrackEventRequest(): TrackEventRequest {
  return { event: undefined };
}

export const TrackEventRequest: MessageFns<TrackEventRequest> = {
  encode(message: TrackEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackEventRequest {
    return { event: isSet(object.event) ? Event.fromJSON(object.event) : undefined };
  },

  toJSON(message: TrackEventRequest): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackEventRequest>, I>>(base?: I): TrackEventRequest {
    return TrackEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackEventRequest>, I>>(object: I): TrackEventRequest {
    const message = createBaseTrackEventRequest();
    message.event = (object.event !== undefined && object.event !== null) ? Event.fromPartial(object.event) : undefined;
    return message;
  },
};

function createBaseTrackEventResponse(): TrackEventResponse {
  return { success: false };
}

export const TrackEventResponse: MessageFns<TrackEventResponse> = {
  encode(message: TrackEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackEventResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: TrackEventResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TrackEventResponse>, I>>(base?: I): TrackEventResponse {
    return TrackEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TrackEventResponse>, I>>(object: I): TrackEventResponse {
    const message = createBaseTrackEventResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseBatchTrackEventsRequest(): BatchTrackEventsRequest {
  return { events: [] };
}

export const BatchTrackEventsRequest: MessageFns<BatchTrackEventsRequest> = {
  encode(message: BatchTrackEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTrackEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTrackEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTrackEventsRequest {
    return { events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [] };
  },

  toJSON(message: BatchTrackEventsRequest): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchTrackEventsRequest>, I>>(base?: I): BatchTrackEventsRequest {
    return BatchTrackEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchTrackEventsRequest>, I>>(object: I): BatchTrackEventsRequest {
    const message = createBaseBatchTrackEventsRequest();
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchTrackEventsResponse(): BatchTrackEventsResponse {
  return { successCount: 0, failureCount: 0 };
}

export const BatchTrackEventsResponse: MessageFns<BatchTrackEventsResponse> = {
  encode(message: BatchTrackEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.successCount !== 0) {
      writer.uint32(8).int32(message.successCount);
    }
    if (message.failureCount !== 0) {
      writer.uint32(16).int32(message.failureCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTrackEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTrackEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.failureCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTrackEventsResponse {
    return {
      successCount: isSet(object.successCount) ? globalThis.Number(object.successCount) : 0,
      failureCount: isSet(object.failureCount) ? globalThis.Number(object.failureCount) : 0,
    };
  },

  toJSON(message: BatchTrackEventsResponse): unknown {
    const obj: any = {};
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failureCount !== 0) {
      obj.failureCount = Math.round(message.failureCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BatchTrackEventsResponse>, I>>(base?: I): BatchTrackEventsResponse {
    return BatchTrackEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BatchTrackEventsResponse>, I>>(object: I): BatchTrackEventsResponse {
    const message = createBaseBatchTrackEventsResponse();
    message.successCount = object.successCount ?? 0;
    message.failureCount = object.failureCount ?? 0;
    return message;
  },
};

function createBaseGetUserEventsRequest(): GetUserEventsRequest {
  return { userId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const GetUserEventsRequest: MessageFns<GetUserEventsRequest> = {
  encode(message: GetUserEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserEventsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetUserEventsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserEventsRequest>, I>>(base?: I): GetUserEventsRequest {
    return GetUserEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserEventsRequest>, I>>(object: I): GetUserEventsRequest {
    const message = createBaseGetUserEventsRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetUserEventsResponse(): GetUserEventsResponse {
  return { events: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const GetUserEventsResponse: MessageFns<GetUserEventsResponse> = {
  encode(message: GetUserEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: GetUserEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserEventsResponse>, I>>(base?: I): GetUserEventsResponse {
    return GetUserEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserEventsResponse>, I>>(object: I): GetUserEventsResponse {
    const message = createBaseGetUserEventsResponse();
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseGetProductEventsRequest(): GetProductEventsRequest {
  return { productId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const GetProductEventsRequest: MessageFns<GetProductEventsRequest> = {
  encode(message: GetProductEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductEventsRequest {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetProductEventsRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductEventsRequest>, I>>(base?: I): GetProductEventsRequest {
    return GetProductEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductEventsRequest>, I>>(object: I): GetProductEventsRequest {
    const message = createBaseGetProductEventsRequest();
    message.productId = object.productId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetProductEventsResponse(): GetProductEventsResponse {
  return { events: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const GetProductEventsResponse: MessageFns<GetProductEventsResponse> = {
  encode(message: GetProductEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: GetProductEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductEventsResponse>, I>>(base?: I): GetProductEventsResponse {
    return GetProductEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductEventsResponse>, I>>(object: I): GetProductEventsResponse {
    const message = createBaseGetProductEventsResponse();
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseGetReportRequest(): GetReportRequest {
  return { reportId: "", parameters: {} };
}

export const GetReportRequest: MessageFns<GetReportRequest> = {
  encode(message: GetReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reportId !== "") {
      writer.uint32(10).string(message.reportId);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      GetReportRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reportId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GetReportRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.parameters[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReportRequest {
    return {
      reportId: isSet(object.reportId) ? globalThis.String(object.reportId) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetReportRequest): unknown {
    const obj: any = {};
    if (message.reportId !== "") {
      obj.reportId = message.reportId;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetReportRequest>, I>>(base?: I): GetReportRequest {
    return GetReportRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetReportRequest>, I>>(object: I): GetReportRequest {
    const message = createBaseGetReportRequest();
    message.reportId = object.reportId ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetReportRequest_ParametersEntry(): GetReportRequest_ParametersEntry {
  return { key: "", value: "" };
}

export const GetReportRequest_ParametersEntry: MessageFns<GetReportRequest_ParametersEntry> = {
  encode(message: GetReportRequest_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReportRequest_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReportRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReportRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetReportRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetReportRequest_ParametersEntry>, I>>(
    base?: I,
  ): GetReportRequest_ParametersEntry {
    return GetReportRequest_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetReportRequest_ParametersEntry>, I>>(
    object: I,
  ): GetReportRequest_ParametersEntry {
    const message = createBaseGetReportRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetReportResponse(): GetReportResponse {
  return { report: undefined };
}

export const GetReportResponse: MessageFns<GetReportResponse> = {
  encode(message: GetReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReportResponse {
    return { report: isSet(object.report) ? Report.fromJSON(object.report) : undefined };
  },

  toJSON(message: GetReportResponse): unknown {
    const obj: any = {};
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetReportResponse>, I>>(base?: I): GetReportResponse {
    return GetReportResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetReportResponse>, I>>(object: I): GetReportResponse {
    const message = createBaseGetReportResponse();
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    return message;
  },
};

function createBaseListReportsRequest(): ListReportsRequest {
  return { page: 0, pageSize: 0 };
}

export const ListReportsRequest: MessageFns<ListReportsRequest> = {
  encode(message: ListReportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListReportsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListReportsRequest>, I>>(base?: I): ListReportsRequest {
    return ListReportsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListReportsRequest>, I>>(object: I): ListReportsRequest {
    const message = createBaseListReportsRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListReportsResponse(): ListReportsResponse {
  return { reports: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListReportsResponse: MessageFns<ListReportsResponse> = {
  encode(message: ListReportsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reports) {
      Report.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reports.push(Report.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportsResponse {
    return {
      reports: globalThis.Array.isArray(object?.reports) ? object.reports.map((e: any) => Report.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListReportsResponse): unknown {
    const obj: any = {};
    if (message.reports?.length) {
      obj.reports = message.reports.map((e) => Report.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListReportsResponse>, I>>(base?: I): ListReportsResponse {
    return ListReportsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListReportsResponse>, I>>(object: I): ListReportsResponse {
    const message = createBaseListReportsResponse();
    message.reports = object.reports?.map((e) => Report.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseReport(): Report {
  return { id: "", name: "", description: "", parameters: {}, data: new Uint8Array(0), createdAt: "0" };
}

export const Report: MessageFns<Report> = {
  encode(message: Report, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      Report_ParametersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.data.length !== 0) {
      writer.uint32(42).bytes(message.data);
    }
    if (message.createdAt !== "0") {
      writer.uint32(48).int64(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Report {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Report_ParametersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.parameters[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.createdAt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Report {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "0",
    };
  },

  toJSON(message: Report): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.createdAt !== "0") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Report>, I>>(base?: I): Report {
    return Report.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Report>, I>>(object: I): Report {
    const message = createBaseReport();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.data = object.data ?? new Uint8Array(0);
    message.createdAt = object.createdAt ?? "0";
    return message;
  },
};

function createBaseReport_ParametersEntry(): Report_ParametersEntry {
  return { key: "", value: "" };
}

export const Report_ParametersEntry: MessageFns<Report_ParametersEntry> = {
  encode(message: Report_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Report_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReport_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Report_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Report_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Report_ParametersEntry>, I>>(base?: I): Report_ParametersEntry {
    return Report_ParametersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Report_ParametersEntry>, I>>(object: I): Report_ParametersEntry {
    const message = createBaseReport_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCaptureEventRequest(): CaptureEventRequest {
  return {
    eventType: "",
    userId: "",
    userEmail: "",
    properties: undefined,
    groups: undefined,
    context: undefined,
    gdprObscure: false,
    campaignId: "0",
  };
}

export const CaptureEventRequest: MessageFns<CaptureEventRequest> = {
  encode(message: CaptureEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== "") {
      writer.uint32(10).string(message.eventType);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.userEmail !== "") {
      writer.uint32(26).string(message.userEmail);
    }
    if (message.properties !== undefined) {
      Struct.encode(Struct.wrap(message.properties), writer.uint32(34).fork()).join();
    }
    if (message.groups !== undefined) {
      Struct.encode(Struct.wrap(message.groups), writer.uint32(42).fork()).join();
    }
    if (message.context !== undefined) {
      Struct.encode(Struct.wrap(message.context), writer.uint32(50).fork()).join();
    }
    if (message.gdprObscure !== false) {
      writer.uint32(56).bool(message.gdprObscure);
    }
    if (message.campaignId !== "0") {
      writer.uint32(64).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaptureEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userEmail = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.properties = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.groups = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.context = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.gdprObscure = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureEventRequest {
    return {
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userEmail: isSet(object.userEmail) ? globalThis.String(object.userEmail) : "",
      properties: isObject(object.properties) ? object.properties : undefined,
      groups: isObject(object.groups) ? object.groups : undefined,
      context: isObject(object.context) ? object.context : undefined,
      gdprObscure: isSet(object.gdprObscure) ? globalThis.Boolean(object.gdprObscure) : false,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: CaptureEventRequest): unknown {
    const obj: any = {};
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userEmail !== "") {
      obj.userEmail = message.userEmail;
    }
    if (message.properties !== undefined) {
      obj.properties = message.properties;
    }
    if (message.groups !== undefined) {
      obj.groups = message.groups;
    }
    if (message.context !== undefined) {
      obj.context = message.context;
    }
    if (message.gdprObscure !== false) {
      obj.gdprObscure = message.gdprObscure;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaptureEventRequest>, I>>(base?: I): CaptureEventRequest {
    return CaptureEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaptureEventRequest>, I>>(object: I): CaptureEventRequest {
    const message = createBaseCaptureEventRequest();
    message.eventType = object.eventType ?? "";
    message.userId = object.userId ?? "";
    message.userEmail = object.userEmail ?? "";
    message.properties = object.properties ?? undefined;
    message.groups = object.groups ?? undefined;
    message.context = object.context ?? undefined;
    message.gdprObscure = object.gdprObscure ?? false;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCaptureEventResponse(): CaptureEventResponse {
  return { eventId: "" };
}

export const CaptureEventResponse: MessageFns<CaptureEventResponse> = {
  encode(message: CaptureEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaptureEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureEventResponse {
    return { eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "" };
  },

  toJSON(message: CaptureEventResponse): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaptureEventResponse>, I>>(base?: I): CaptureEventResponse {
    return CaptureEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaptureEventResponse>, I>>(object: I): CaptureEventResponse {
    const message = createBaseCaptureEventResponse();
    message.eventId = object.eventId ?? "";
    return message;
  },
};

function createBaseAnalyticsEvent(): AnalyticsEvent {
  return { eventId: "", timestamp: "0", metadata: undefined, campaignId: "0" };
}

export const AnalyticsEvent: MessageFns<AnalyticsEvent> = {
  encode(message: AnalyticsEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(74).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(80).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyticsEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyticsEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyticsEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: AnalyticsEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalyticsEvent>, I>>(base?: I): AnalyticsEvent {
    return AnalyticsEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalyticsEvent>, I>>(object: I): AnalyticsEvent {
    const message = createBaseAnalyticsEvent();
    message.eventId = object.eventId ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListEventsRequest(): ListEventsRequest {
  return {};
}

export const ListEventsRequest: MessageFns<ListEventsRequest> = {
  encode(_: ListEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListEventsRequest {
    return {};
  },

  toJSON(_: ListEventsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListEventsRequest>, I>>(base?: I): ListEventsRequest {
    return ListEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListEventsRequest>, I>>(_: I): ListEventsRequest {
    const message = createBaseListEventsRequest();
    return message;
  },
};

function createBaseListEventsResponse(): ListEventsResponse {
  return { events: [] };
}

export const ListEventsResponse: MessageFns<ListEventsResponse> = {
  encode(message: ListEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      AnalyticsEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(AnalyticsEvent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => AnalyticsEvent.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => AnalyticsEvent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListEventsResponse>, I>>(base?: I): ListEventsResponse {
    return ListEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListEventsResponse>, I>>(object: I): ListEventsResponse {
    const message = createBaseListEventsResponse();
    message.events = object.events?.map((e) => AnalyticsEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEnrichEventMetadataRequest(): EnrichEventMetadataRequest {
  return { eventId: "", newFields: undefined, campaignId: "0" };
}

export const EnrichEventMetadataRequest: MessageFns<EnrichEventMetadataRequest> = {
  encode(message: EnrichEventMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.newFields !== undefined) {
      Struct.encode(Struct.wrap(message.newFields), writer.uint32(18).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(24).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnrichEventMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnrichEventMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newFields = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnrichEventMetadataRequest {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      newFields: isObject(object.newFields) ? object.newFields : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: EnrichEventMetadataRequest): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.newFields !== undefined) {
      obj.newFields = message.newFields;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnrichEventMetadataRequest>, I>>(base?: I): EnrichEventMetadataRequest {
    return EnrichEventMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnrichEventMetadataRequest>, I>>(object: I): EnrichEventMetadataRequest {
    const message = createBaseEnrichEventMetadataRequest();
    message.eventId = object.eventId ?? "";
    message.newFields = object.newFields ?? undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseEnrichEventMetadataResponse(): EnrichEventMetadataResponse {
  return { success: false };
}

export const EnrichEventMetadataResponse: MessageFns<EnrichEventMetadataResponse> = {
  encode(message: EnrichEventMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnrichEventMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnrichEventMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnrichEventMetadataResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: EnrichEventMetadataResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnrichEventMetadataResponse>, I>>(base?: I): EnrichEventMetadataResponse {
    return EnrichEventMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnrichEventMetadataResponse>, I>>(object: I): EnrichEventMetadataResponse {
    const message = createBaseEnrichEventMetadataResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export interface AnalyticsService {
  TrackEvent(request: TrackEventRequest): Promise<TrackEventResponse>;
  BatchTrackEvents(request: BatchTrackEventsRequest): Promise<BatchTrackEventsResponse>;
  GetUserEvents(request: GetUserEventsRequest): Promise<GetUserEventsResponse>;
  GetProductEvents(request: GetProductEventsRequest): Promise<GetProductEventsResponse>;
  GetReport(request: GetReportRequest): Promise<GetReportResponse>;
  ListReports(request: ListReportsRequest): Promise<ListReportsResponse>;
  CaptureEvent(request: CaptureEventRequest): Promise<CaptureEventResponse>;
  ListEvents(request: ListEventsRequest): Promise<ListEventsResponse>;
  EnrichEventMetadata(request: EnrichEventMetadataRequest): Promise<EnrichEventMetadataResponse>;
}

export const AnalyticsServiceServiceName = "analytics.v1.AnalyticsService";
export class AnalyticsServiceClientImpl implements AnalyticsService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AnalyticsServiceServiceName;
    this.rpc = rpc;
    this.TrackEvent = this.TrackEvent.bind(this);
    this.BatchTrackEvents = this.BatchTrackEvents.bind(this);
    this.GetUserEvents = this.GetUserEvents.bind(this);
    this.GetProductEvents = this.GetProductEvents.bind(this);
    this.GetReport = this.GetReport.bind(this);
    this.ListReports = this.ListReports.bind(this);
    this.CaptureEvent = this.CaptureEvent.bind(this);
    this.ListEvents = this.ListEvents.bind(this);
    this.EnrichEventMetadata = this.EnrichEventMetadata.bind(this);
  }
  TrackEvent(request: TrackEventRequest): Promise<TrackEventResponse> {
    const data = TrackEventRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TrackEvent", data);
    return promise.then((data) => TrackEventResponse.decode(new BinaryReader(data)));
  }

  BatchTrackEvents(request: BatchTrackEventsRequest): Promise<BatchTrackEventsResponse> {
    const data = BatchTrackEventsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BatchTrackEvents", data);
    return promise.then((data) => BatchTrackEventsResponse.decode(new BinaryReader(data)));
  }

  GetUserEvents(request: GetUserEventsRequest): Promise<GetUserEventsResponse> {
    const data = GetUserEventsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserEvents", data);
    return promise.then((data) => GetUserEventsResponse.decode(new BinaryReader(data)));
  }

  GetProductEvents(request: GetProductEventsRequest): Promise<GetProductEventsResponse> {
    const data = GetProductEventsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProductEvents", data);
    return promise.then((data) => GetProductEventsResponse.decode(new BinaryReader(data)));
  }

  GetReport(request: GetReportRequest): Promise<GetReportResponse> {
    const data = GetReportRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetReport", data);
    return promise.then((data) => GetReportResponse.decode(new BinaryReader(data)));
  }

  ListReports(request: ListReportsRequest): Promise<ListReportsResponse> {
    const data = ListReportsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListReports", data);
    return promise.then((data) => ListReportsResponse.decode(new BinaryReader(data)));
  }

  CaptureEvent(request: CaptureEventRequest): Promise<CaptureEventResponse> {
    const data = CaptureEventRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CaptureEvent", data);
    return promise.then((data) => CaptureEventResponse.decode(new BinaryReader(data)));
  }

  ListEvents(request: ListEventsRequest): Promise<ListEventsResponse> {
    const data = ListEventsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListEvents", data);
    return promise.then((data) => ListEventsResponse.decode(new BinaryReader(data)));
  }

  EnrichEventMetadata(request: EnrichEventMetadataRequest): Promise<EnrichEventMetadataResponse> {
    const data = EnrichEventMetadataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EnrichEventMetadata", data);
    return promise.then((data) => EnrichEventMetadataResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
