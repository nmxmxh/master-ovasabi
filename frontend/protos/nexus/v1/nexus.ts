// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: nexus/v1/nexus.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Metadata } from "../../common/v1/metadata";
import { IntegrationPattern } from "../../common/v1/patterns";
import { Payload } from "../../common/v1/payload";
import { Struct } from "../../google/protobuf/struct";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "nexus.v1";

/**
 * NexusService proto
 * See docs/services/nexus.md for full documentation and research inspirations.
 */

export interface RegisterPatternRequest {
  patternId: string;
  patternType: string;
  version: string;
  origin: string;
  definition?: IntegrationPattern | undefined;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface RegisterPatternResponse {
  success: boolean;
  error: string;
  metadata?: Metadata | undefined;
}

export interface ListPatternsRequest {
  patternType: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface ListPatternsResponse {
  patterns: Pattern[];
  metadata?: Metadata | undefined;
}

export interface Pattern {
  patternId: string;
  patternType: string;
  version: string;
  origin: string;
  definition?: IntegrationPattern | undefined;
  usageCount: string;
  lastUsed?: Date | undefined;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface OrchestrateRequest {
  patternId: string;
  input?: { [key: string]: any } | undefined;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface OrchestrateResponse {
  orchestrationId: string;
  output?: { [key: string]: any } | undefined;
  metadata?: Metadata | undefined;
}

export interface TracePatternRequest {
  orchestrationId: string;
  metadata?: Metadata | undefined;
}

export interface TracePatternResponse {
  traceId: string;
  steps: TraceStep[];
  metadata?: Metadata | undefined;
}

export interface TraceStep {
  service: string;
  action: string;
  timestamp?: Date | undefined;
  details?: { [key: string]: any } | undefined;
}

export interface MinePatternsRequest {
  source: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface MinePatternsResponse {
  patterns: Pattern[];
  metadata?: Metadata | undefined;
}

export interface FeedbackRequest {
  patternId: string;
  score: number;
  comments: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface FeedbackResponse {
  success: boolean;
  error: string;
  metadata?: Metadata | undefined;
}

export interface HandleOpsRequest {
  op: string;
  params: { [key: string]: string };
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface HandleOpsRequest_ParamsEntry {
  key: string;
  value: string;
}

export interface HandleOpsResponse {
  success: boolean;
  message: string;
  data?: { [key: string]: any } | undefined;
  metadata?: Metadata | undefined;
}

export interface EventRequest {
  eventId: string;
  eventType: string;
  entityId: string;
  metadata?: Metadata | undefined;
  campaignId: string;
  payload?: Payload | undefined;
}

export interface EventResponse {
  success: boolean;
  eventId: string;
  eventType: string;
  message: string;
  metadata?: Metadata | undefined;
  payload?: Payload | undefined;
}

export interface SubscribeRequest {
  eventTypes: string[];
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface Nexus {
  /** ... existing fields ... */
  campaignId: string;
}

function createBaseRegisterPatternRequest(): RegisterPatternRequest {
  return {
    patternId: "",
    patternType: "",
    version: "",
    origin: "",
    definition: undefined,
    metadata: undefined,
    campaignId: "0",
  };
}

export const RegisterPatternRequest: MessageFns<RegisterPatternRequest> = {
  encode(message: RegisterPatternRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.patternId !== "") {
      writer.uint32(10).string(message.patternId);
    }
    if (message.patternType !== "") {
      writer.uint32(18).string(message.patternType);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.origin !== "") {
      writer.uint32(34).string(message.origin);
    }
    if (message.definition !== undefined) {
      IntegrationPattern.encode(message.definition, writer.uint32(42).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(56).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterPatternRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterPatternRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patternId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.patternType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.origin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.definition = IntegrationPattern.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterPatternRequest {
    return {
      patternId: isSet(object.patternId) ? globalThis.String(object.patternId) : "",
      patternType: isSet(object.patternType) ? globalThis.String(object.patternType) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
      definition: isSet(object.definition) ? IntegrationPattern.fromJSON(object.definition) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: RegisterPatternRequest): unknown {
    const obj: any = {};
    if (message.patternId !== "") {
      obj.patternId = message.patternId;
    }
    if (message.patternType !== "") {
      obj.patternType = message.patternType;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.origin !== "") {
      obj.origin = message.origin;
    }
    if (message.definition !== undefined) {
      obj.definition = IntegrationPattern.toJSON(message.definition);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterPatternRequest>, I>>(base?: I): RegisterPatternRequest {
    return RegisterPatternRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterPatternRequest>, I>>(object: I): RegisterPatternRequest {
    const message = createBaseRegisterPatternRequest();
    message.patternId = object.patternId ?? "";
    message.patternType = object.patternType ?? "";
    message.version = object.version ?? "";
    message.origin = object.origin ?? "";
    message.definition = (object.definition !== undefined && object.definition !== null)
      ? IntegrationPattern.fromPartial(object.definition)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseRegisterPatternResponse(): RegisterPatternResponse {
  return { success: false, error: "", metadata: undefined };
}

export const RegisterPatternResponse: MessageFns<RegisterPatternResponse> = {
  encode(message: RegisterPatternResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterPatternResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterPatternResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterPatternResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: RegisterPatternResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterPatternResponse>, I>>(base?: I): RegisterPatternResponse {
    return RegisterPatternResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterPatternResponse>, I>>(object: I): RegisterPatternResponse {
    const message = createBaseRegisterPatternResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListPatternsRequest(): ListPatternsRequest {
  return { patternType: "", metadata: undefined, campaignId: "0" };
}

export const ListPatternsRequest: MessageFns<ListPatternsRequest> = {
  encode(message: ListPatternsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.patternType !== "") {
      writer.uint32(10).string(message.patternType);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(24).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPatternsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPatternsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patternType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPatternsRequest {
    return {
      patternType: isSet(object.patternType) ? globalThis.String(object.patternType) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListPatternsRequest): unknown {
    const obj: any = {};
    if (message.patternType !== "") {
      obj.patternType = message.patternType;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPatternsRequest>, I>>(base?: I): ListPatternsRequest {
    return ListPatternsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPatternsRequest>, I>>(object: I): ListPatternsRequest {
    const message = createBaseListPatternsRequest();
    message.patternType = object.patternType ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListPatternsResponse(): ListPatternsResponse {
  return { patterns: [], metadata: undefined };
}

export const ListPatternsResponse: MessageFns<ListPatternsResponse> = {
  encode(message: ListPatternsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.patterns) {
      Pattern.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPatternsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPatternsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patterns.push(Pattern.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPatternsResponse {
    return {
      patterns: globalThis.Array.isArray(object?.patterns) ? object.patterns.map((e: any) => Pattern.fromJSON(e)) : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListPatternsResponse): unknown {
    const obj: any = {};
    if (message.patterns?.length) {
      obj.patterns = message.patterns.map((e) => Pattern.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPatternsResponse>, I>>(base?: I): ListPatternsResponse {
    return ListPatternsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPatternsResponse>, I>>(object: I): ListPatternsResponse {
    const message = createBaseListPatternsResponse();
    message.patterns = object.patterns?.map((e) => Pattern.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBasePattern(): Pattern {
  return {
    patternId: "",
    patternType: "",
    version: "",
    origin: "",
    definition: undefined,
    usageCount: "0",
    lastUsed: undefined,
    metadata: undefined,
    campaignId: "0",
  };
}

export const Pattern: MessageFns<Pattern> = {
  encode(message: Pattern, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.patternId !== "") {
      writer.uint32(10).string(message.patternId);
    }
    if (message.patternType !== "") {
      writer.uint32(18).string(message.patternType);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.origin !== "") {
      writer.uint32(34).string(message.origin);
    }
    if (message.definition !== undefined) {
      IntegrationPattern.encode(message.definition, writer.uint32(42).fork()).join();
    }
    if (message.usageCount !== "0") {
      writer.uint32(48).int64(message.usageCount);
    }
    if (message.lastUsed !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUsed), writer.uint32(58).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(72).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pattern {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePattern();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patternId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.patternType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.origin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.definition = IntegrationPattern.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.usageCount = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lastUsed = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pattern {
    return {
      patternId: isSet(object.patternId) ? globalThis.String(object.patternId) : "",
      patternType: isSet(object.patternType) ? globalThis.String(object.patternType) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
      definition: isSet(object.definition) ? IntegrationPattern.fromJSON(object.definition) : undefined,
      usageCount: isSet(object.usageCount) ? globalThis.String(object.usageCount) : "0",
      lastUsed: isSet(object.lastUsed) ? fromJsonTimestamp(object.lastUsed) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Pattern): unknown {
    const obj: any = {};
    if (message.patternId !== "") {
      obj.patternId = message.patternId;
    }
    if (message.patternType !== "") {
      obj.patternType = message.patternType;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.origin !== "") {
      obj.origin = message.origin;
    }
    if (message.definition !== undefined) {
      obj.definition = IntegrationPattern.toJSON(message.definition);
    }
    if (message.usageCount !== "0") {
      obj.usageCount = message.usageCount;
    }
    if (message.lastUsed !== undefined) {
      obj.lastUsed = message.lastUsed.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pattern>, I>>(base?: I): Pattern {
    return Pattern.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pattern>, I>>(object: I): Pattern {
    const message = createBasePattern();
    message.patternId = object.patternId ?? "";
    message.patternType = object.patternType ?? "";
    message.version = object.version ?? "";
    message.origin = object.origin ?? "";
    message.definition = (object.definition !== undefined && object.definition !== null)
      ? IntegrationPattern.fromPartial(object.definition)
      : undefined;
    message.usageCount = object.usageCount ?? "0";
    message.lastUsed = object.lastUsed ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseOrchestrateRequest(): OrchestrateRequest {
  return { patternId: "", input: undefined, metadata: undefined, campaignId: "0" };
}

export const OrchestrateRequest: MessageFns<OrchestrateRequest> = {
  encode(message: OrchestrateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.patternId !== "") {
      writer.uint32(10).string(message.patternId);
    }
    if (message.input !== undefined) {
      Struct.encode(Struct.wrap(message.input), writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patternId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrchestrateRequest {
    return {
      patternId: isSet(object.patternId) ? globalThis.String(object.patternId) : "",
      input: isObject(object.input) ? object.input : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: OrchestrateRequest): unknown {
    const obj: any = {};
    if (message.patternId !== "") {
      obj.patternId = message.patternId;
    }
    if (message.input !== undefined) {
      obj.input = message.input;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrchestrateRequest>, I>>(base?: I): OrchestrateRequest {
    return OrchestrateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrchestrateRequest>, I>>(object: I): OrchestrateRequest {
    const message = createBaseOrchestrateRequest();
    message.patternId = object.patternId ?? "";
    message.input = object.input ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseOrchestrateResponse(): OrchestrateResponse {
  return { orchestrationId: "", output: undefined, metadata: undefined };
}

export const OrchestrateResponse: MessageFns<OrchestrateResponse> = {
  encode(message: OrchestrateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orchestrationId !== "") {
      writer.uint32(10).string(message.orchestrationId);
    }
    if (message.output !== undefined) {
      Struct.encode(Struct.wrap(message.output), writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orchestrationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.output = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrchestrateResponse {
    return {
      orchestrationId: isSet(object.orchestrationId) ? globalThis.String(object.orchestrationId) : "",
      output: isObject(object.output) ? object.output : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: OrchestrateResponse): unknown {
    const obj: any = {};
    if (message.orchestrationId !== "") {
      obj.orchestrationId = message.orchestrationId;
    }
    if (message.output !== undefined) {
      obj.output = message.output;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrchestrateResponse>, I>>(base?: I): OrchestrateResponse {
    return OrchestrateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrchestrateResponse>, I>>(object: I): OrchestrateResponse {
    const message = createBaseOrchestrateResponse();
    message.orchestrationId = object.orchestrationId ?? "";
    message.output = object.output ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseTracePatternRequest(): TracePatternRequest {
  return { orchestrationId: "", metadata: undefined };
}

export const TracePatternRequest: MessageFns<TracePatternRequest> = {
  encode(message: TracePatternRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orchestrationId !== "") {
      writer.uint32(10).string(message.orchestrationId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TracePatternRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTracePatternRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orchestrationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TracePatternRequest {
    return {
      orchestrationId: isSet(object.orchestrationId) ? globalThis.String(object.orchestrationId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: TracePatternRequest): unknown {
    const obj: any = {};
    if (message.orchestrationId !== "") {
      obj.orchestrationId = message.orchestrationId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TracePatternRequest>, I>>(base?: I): TracePatternRequest {
    return TracePatternRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TracePatternRequest>, I>>(object: I): TracePatternRequest {
    const message = createBaseTracePatternRequest();
    message.orchestrationId = object.orchestrationId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseTracePatternResponse(): TracePatternResponse {
  return { traceId: "", steps: [], metadata: undefined };
}

export const TracePatternResponse: MessageFns<TracePatternResponse> = {
  encode(message: TracePatternResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.traceId !== "") {
      writer.uint32(10).string(message.traceId);
    }
    for (const v of message.steps) {
      TraceStep.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TracePatternResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTracePatternResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.traceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.steps.push(TraceStep.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TracePatternResponse {
    return {
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => TraceStep.fromJSON(e)) : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: TracePatternResponse): unknown {
    const obj: any = {};
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => TraceStep.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TracePatternResponse>, I>>(base?: I): TracePatternResponse {
    return TracePatternResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TracePatternResponse>, I>>(object: I): TracePatternResponse {
    const message = createBaseTracePatternResponse();
    message.traceId = object.traceId ?? "";
    message.steps = object.steps?.map((e) => TraceStep.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseTraceStep(): TraceStep {
  return { service: "", action: "", timestamp: undefined, details: undefined };
}

export const TraceStep: MessageFns<TraceStep> = {
  encode(message: TraceStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    if (message.details !== undefined) {
      Struct.encode(Struct.wrap(message.details), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraceStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraceStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.details = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraceStep {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      details: isObject(object.details) ? object.details : undefined,
    };
  },

  toJSON(message: TraceStep): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraceStep>, I>>(base?: I): TraceStep {
    return TraceStep.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraceStep>, I>>(object: I): TraceStep {
    const message = createBaseTraceStep();
    message.service = object.service ?? "";
    message.action = object.action ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.details = object.details ?? undefined;
    return message;
  },
};

function createBaseMinePatternsRequest(): MinePatternsRequest {
  return { source: "", metadata: undefined, campaignId: "0" };
}

export const MinePatternsRequest: MessageFns<MinePatternsRequest> = {
  encode(message: MinePatternsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(24).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MinePatternsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinePatternsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinePatternsRequest {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: MinePatternsRequest): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MinePatternsRequest>, I>>(base?: I): MinePatternsRequest {
    return MinePatternsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MinePatternsRequest>, I>>(object: I): MinePatternsRequest {
    const message = createBaseMinePatternsRequest();
    message.source = object.source ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseMinePatternsResponse(): MinePatternsResponse {
  return { patterns: [], metadata: undefined };
}

export const MinePatternsResponse: MessageFns<MinePatternsResponse> = {
  encode(message: MinePatternsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.patterns) {
      Pattern.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MinePatternsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinePatternsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patterns.push(Pattern.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinePatternsResponse {
    return {
      patterns: globalThis.Array.isArray(object?.patterns) ? object.patterns.map((e: any) => Pattern.fromJSON(e)) : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: MinePatternsResponse): unknown {
    const obj: any = {};
    if (message.patterns?.length) {
      obj.patterns = message.patterns.map((e) => Pattern.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MinePatternsResponse>, I>>(base?: I): MinePatternsResponse {
    return MinePatternsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MinePatternsResponse>, I>>(object: I): MinePatternsResponse {
    const message = createBaseMinePatternsResponse();
    message.patterns = object.patterns?.map((e) => Pattern.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseFeedbackRequest(): FeedbackRequest {
  return { patternId: "", score: 0, comments: "", metadata: undefined, campaignId: "0" };
}

export const FeedbackRequest: MessageFns<FeedbackRequest> = {
  encode(message: FeedbackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.patternId !== "") {
      writer.uint32(10).string(message.patternId);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    if (message.comments !== "") {
      writer.uint32(26).string(message.comments);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeedbackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeedbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.patternId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comments = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeedbackRequest {
    return {
      patternId: isSet(object.patternId) ? globalThis.String(object.patternId) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      comments: isSet(object.comments) ? globalThis.String(object.comments) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: FeedbackRequest): unknown {
    const obj: any = {};
    if (message.patternId !== "") {
      obj.patternId = message.patternId;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.comments !== "") {
      obj.comments = message.comments;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeedbackRequest>, I>>(base?: I): FeedbackRequest {
    return FeedbackRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeedbackRequest>, I>>(object: I): FeedbackRequest {
    const message = createBaseFeedbackRequest();
    message.patternId = object.patternId ?? "";
    message.score = object.score ?? 0;
    message.comments = object.comments ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseFeedbackResponse(): FeedbackResponse {
  return { success: false, error: "", metadata: undefined };
}

export const FeedbackResponse: MessageFns<FeedbackResponse> = {
  encode(message: FeedbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeedbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeedbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeedbackResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: FeedbackResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeedbackResponse>, I>>(base?: I): FeedbackResponse {
    return FeedbackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeedbackResponse>, I>>(object: I): FeedbackResponse {
    const message = createBaseFeedbackResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseHandleOpsRequest(): HandleOpsRequest {
  return { op: "", params: {}, metadata: undefined, campaignId: "0" };
}

export const HandleOpsRequest: MessageFns<HandleOpsRequest> = {
  encode(message: HandleOpsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== "") {
      writer.uint32(10).string(message.op);
    }
    Object.entries(message.params).forEach(([key, value]) => {
      HandleOpsRequest_ParamsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandleOpsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandleOpsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.op = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = HandleOpsRequest_ParamsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.params[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandleOpsRequest {
    return {
      op: isSet(object.op) ? globalThis.String(object.op) : "",
      params: isObject(object.params)
        ? Object.entries(object.params).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: HandleOpsRequest): unknown {
    const obj: any = {};
    if (message.op !== "") {
      obj.op = message.op;
    }
    if (message.params) {
      const entries = Object.entries(message.params);
      if (entries.length > 0) {
        obj.params = {};
        entries.forEach(([k, v]) => {
          obj.params[k] = v;
        });
      }
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandleOpsRequest>, I>>(base?: I): HandleOpsRequest {
    return HandleOpsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandleOpsRequest>, I>>(object: I): HandleOpsRequest {
    const message = createBaseHandleOpsRequest();
    message.op = object.op ?? "";
    message.params = Object.entries(object.params ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseHandleOpsRequest_ParamsEntry(): HandleOpsRequest_ParamsEntry {
  return { key: "", value: "" };
}

export const HandleOpsRequest_ParamsEntry: MessageFns<HandleOpsRequest_ParamsEntry> = {
  encode(message: HandleOpsRequest_ParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandleOpsRequest_ParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandleOpsRequest_ParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandleOpsRequest_ParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HandleOpsRequest_ParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandleOpsRequest_ParamsEntry>, I>>(base?: I): HandleOpsRequest_ParamsEntry {
    return HandleOpsRequest_ParamsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandleOpsRequest_ParamsEntry>, I>>(object: I): HandleOpsRequest_ParamsEntry {
    const message = createBaseHandleOpsRequest_ParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHandleOpsResponse(): HandleOpsResponse {
  return { success: false, message: "", data: undefined, metadata: undefined };
}

export const HandleOpsResponse: MessageFns<HandleOpsResponse> = {
  encode(message: HandleOpsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HandleOpsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHandleOpsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HandleOpsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isObject(object.data) ? object.data : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: HandleOpsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HandleOpsResponse>, I>>(base?: I): HandleOpsResponse {
    return HandleOpsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HandleOpsResponse>, I>>(object: I): HandleOpsResponse {
    const message = createBaseHandleOpsResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.data = object.data ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseEventRequest(): EventRequest {
  return { eventId: "", eventType: "", entityId: "", metadata: undefined, campaignId: "0", payload: undefined };
}

export const EventRequest: MessageFns<EventRequest> = {
  encode(message: EventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.entityId !== "") {
      writer.uint32(26).string(message.entityId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    if (message.payload !== undefined) {
      Payload.encode(message.payload, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.payload = Payload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventRequest {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
      payload: isSet(object.payload) ? Payload.fromJSON(object.payload) : undefined,
    };
  },

  toJSON(message: EventRequest): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    if (message.payload !== undefined) {
      obj.payload = Payload.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventRequest>, I>>(base?: I): EventRequest {
    return EventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventRequest>, I>>(object: I): EventRequest {
    const message = createBaseEventRequest();
    message.eventId = object.eventId ?? "";
    message.eventType = object.eventType ?? "";
    message.entityId = object.entityId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Payload.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseEventResponse(): EventResponse {
  return { success: false, eventId: "", eventType: "", message: "", metadata: undefined, payload: undefined };
}

export const EventResponse: MessageFns<EventResponse> = {
  encode(message: EventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.eventId !== "") {
      writer.uint32(18).string(message.eventId);
    }
    if (message.eventType !== "") {
      writer.uint32(26).string(message.eventType);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.payload !== undefined) {
      Payload.encode(message.payload, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.payload = Payload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      payload: isSet(object.payload) ? Payload.fromJSON(object.payload) : undefined,
    };
  },

  toJSON(message: EventResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.payload !== undefined) {
      obj.payload = Payload.toJSON(message.payload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventResponse>, I>>(base?: I): EventResponse {
    return EventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventResponse>, I>>(object: I): EventResponse {
    const message = createBaseEventResponse();
    message.success = object.success ?? false;
    message.eventId = object.eventId ?? "";
    message.eventType = object.eventType ?? "";
    message.message = object.message ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Payload.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseSubscribeRequest(): SubscribeRequest {
  return { eventTypes: [], metadata: undefined, campaignId: "0" };
}

export const SubscribeRequest: MessageFns<SubscribeRequest> = {
  encode(message: SubscribeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.eventTypes) {
      writer.uint32(10).string(v!);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(24).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventTypes.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequest {
    return {
      eventTypes: globalThis.Array.isArray(object?.eventTypes)
        ? object.eventTypes.map((e: any) => globalThis.String(e))
        : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: SubscribeRequest): unknown {
    const obj: any = {};
    if (message.eventTypes?.length) {
      obj.eventTypes = message.eventTypes;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeRequest>, I>>(base?: I): SubscribeRequest {
    return SubscribeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeRequest>, I>>(object: I): SubscribeRequest {
    const message = createBaseSubscribeRequest();
    message.eventTypes = object.eventTypes?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseNexus(): Nexus {
  return { campaignId: "0" };
}

export const Nexus: MessageFns<Nexus> = {
  encode(message: Nexus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.campaignId !== "0") {
      writer.uint32(80).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Nexus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNexus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Nexus {
    return { campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0" };
  },

  toJSON(message: Nexus): unknown {
    const obj: any = {};
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Nexus>, I>>(base?: I): Nexus {
    return Nexus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Nexus>, I>>(object: I): Nexus {
    const message = createBaseNexus();
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

/** NexusService: High-level composer, orchestrator, and pattern identifier */
export interface NexusService {
  RegisterPattern(request: RegisterPatternRequest): Promise<RegisterPatternResponse>;
  ListPatterns(request: ListPatternsRequest): Promise<ListPatternsResponse>;
  Orchestrate(request: OrchestrateRequest): Promise<OrchestrateResponse>;
  TracePattern(request: TracePatternRequest): Promise<TracePatternResponse>;
  MinePatterns(request: MinePatternsRequest): Promise<MinePatternsResponse>;
  Feedback(request: FeedbackRequest): Promise<FeedbackResponse>;
  HandleOps(request: HandleOpsRequest): Promise<HandleOpsResponse>;
  /** --- Event Bus Methods --- */
  EmitEvent(request: EventRequest): Promise<EventResponse>;
  SubscribeEvents(request: SubscribeRequest): Observable<EventResponse>;
}

export const NexusServiceServiceName = "nexus.v1.NexusService";
export class NexusServiceClientImpl implements NexusService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || NexusServiceServiceName;
    this.rpc = rpc;
    this.RegisterPattern = this.RegisterPattern.bind(this);
    this.ListPatterns = this.ListPatterns.bind(this);
    this.Orchestrate = this.Orchestrate.bind(this);
    this.TracePattern = this.TracePattern.bind(this);
    this.MinePatterns = this.MinePatterns.bind(this);
    this.Feedback = this.Feedback.bind(this);
    this.HandleOps = this.HandleOps.bind(this);
    this.EmitEvent = this.EmitEvent.bind(this);
    this.SubscribeEvents = this.SubscribeEvents.bind(this);
  }
  RegisterPattern(request: RegisterPatternRequest): Promise<RegisterPatternResponse> {
    const data = RegisterPatternRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterPattern", data);
    return promise.then((data) => RegisterPatternResponse.decode(new BinaryReader(data)));
  }

  ListPatterns(request: ListPatternsRequest): Promise<ListPatternsResponse> {
    const data = ListPatternsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListPatterns", data);
    return promise.then((data) => ListPatternsResponse.decode(new BinaryReader(data)));
  }

  Orchestrate(request: OrchestrateRequest): Promise<OrchestrateResponse> {
    const data = OrchestrateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Orchestrate", data);
    return promise.then((data) => OrchestrateResponse.decode(new BinaryReader(data)));
  }

  TracePattern(request: TracePatternRequest): Promise<TracePatternResponse> {
    const data = TracePatternRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TracePattern", data);
    return promise.then((data) => TracePatternResponse.decode(new BinaryReader(data)));
  }

  MinePatterns(request: MinePatternsRequest): Promise<MinePatternsResponse> {
    const data = MinePatternsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MinePatterns", data);
    return promise.then((data) => MinePatternsResponse.decode(new BinaryReader(data)));
  }

  Feedback(request: FeedbackRequest): Promise<FeedbackResponse> {
    const data = FeedbackRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Feedback", data);
    return promise.then((data) => FeedbackResponse.decode(new BinaryReader(data)));
  }

  HandleOps(request: HandleOpsRequest): Promise<HandleOpsResponse> {
    const data = HandleOpsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "HandleOps", data);
    return promise.then((data) => HandleOpsResponse.decode(new BinaryReader(data)));
  }

  EmitEvent(request: EventRequest): Promise<EventResponse> {
    const data = EventRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EmitEvent", data);
    return promise.then((data) => EventResponse.decode(new BinaryReader(data)));
  }

  SubscribeEvents(request: SubscribeRequest): Observable<EventResponse> {
    const data = SubscribeRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "SubscribeEvents", data);
    return result.pipe(map((data) => EventResponse.decode(new BinaryReader(data))));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
