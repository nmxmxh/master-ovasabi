// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: ai/v1/model.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Entity } from "../../common/v1/entity";
import { Metadata } from "../../common/v1/metadata";
import { ContentType, contentTypeFromJSON, contentTypeToJSON } from "../../crawler/v1/crawler";

export const protobufPackage = "ai.v1";

/** --- Core Data Models --- */
export interface ContentChunk {
  data: Uint8Array;
  sequence: number;
  isLast: boolean;
  tokenCount: number;
  /** SHA-256 */
  contentHash: string;
  /** Added for reference */
  sourceUri: string;
}

export interface Relation {
  /** "related", "child", "similar", etc. */
  type: string;
  /** URI reference to other entity */
  targetUri: string;
  /** Relationship confidence (0.0-1.0) */
  strength: number;
  /** Unix timestamp for GC */
  lastUpdated: string;
}

export interface SecurityAssessment {
  level: SecurityAssessment_ThreatLevel;
  indicators: string[];
  quarantinePath: string;
}

export enum SecurityAssessment_ThreatLevel {
  THREAT_LEVEL_UNKNOWN_UNSPECIFIED = 0,
  THREAT_LEVEL_CLEAN = 1,
  THREAT_LEVEL_SUSPECT = 2,
  THREAT_LEVEL_MALICIOUS = 3,
  UNRECOGNIZED = -1,
}

export function securityAssessment_ThreatLevelFromJSON(object: any): SecurityAssessment_ThreatLevel {
  switch (object) {
    case 0:
    case "THREAT_LEVEL_UNKNOWN_UNSPECIFIED":
      return SecurityAssessment_ThreatLevel.THREAT_LEVEL_UNKNOWN_UNSPECIFIED;
    case 1:
    case "THREAT_LEVEL_CLEAN":
      return SecurityAssessment_ThreatLevel.THREAT_LEVEL_CLEAN;
    case 2:
    case "THREAT_LEVEL_SUSPECT":
      return SecurityAssessment_ThreatLevel.THREAT_LEVEL_SUSPECT;
    case 3:
    case "THREAT_LEVEL_MALICIOUS":
      return SecurityAssessment_ThreatLevel.THREAT_LEVEL_MALICIOUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SecurityAssessment_ThreatLevel.UNRECOGNIZED;
  }
}

export function securityAssessment_ThreatLevelToJSON(object: SecurityAssessment_ThreatLevel): string {
  switch (object) {
    case SecurityAssessment_ThreatLevel.THREAT_LEVEL_UNKNOWN_UNSPECIFIED:
      return "THREAT_LEVEL_UNKNOWN_UNSPECIFIED";
    case SecurityAssessment_ThreatLevel.THREAT_LEVEL_CLEAN:
      return "THREAT_LEVEL_CLEAN";
    case SecurityAssessment_ThreatLevel.THREAT_LEVEL_SUSPECT:
      return "THREAT_LEVEL_SUSPECT";
    case SecurityAssessment_ThreatLevel.THREAT_LEVEL_MALICIOUS:
      return "THREAT_LEVEL_MALICIOUS";
    case SecurityAssessment_ThreatLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** --- AI Processing --- */
export interface EnrichmentRequest {
  taskUuid: string;
  contentType: ContentType;
  /** Enhanced metadata */
  metadata?: Metadata | undefined;
  rawData?: Uint8Array | undefined;
  chunk?: ContentChunk | undefined;
  security?: SecurityAssessment | undefined;
}

export interface TextEnrichment {
  summary: string;
  entities: Entity[];
  sentimentScore: number;
  keyPhrases: string[];
  topicDistribution: { [key: string]: number };
}

export interface TextEnrichment_TopicDistributionEntry {
  key: string;
  value: number;
}

export interface MediaEnrichment {
  caption: string;
  detectedObjects: Entity[];
  transcription: string;
  keywords: string[];
}

export interface EnrichmentResponse {
  taskUuid: string;
  text?: TextEnrichment | undefined;
  media?: MediaEnrichment | undefined;
  knowledgeGaps: string[];
  errorMessage: string;
  vector?:
    | EnrichmentResponse_Vector
    | undefined;
  /** Added knowledge graph relations */
  relations: Relation[];
}

export interface EnrichmentResponse_Vector {
  values: number[];
  model: string;
  dimensions: number;
}

/** --- Federated Learning with P2P --- */
export interface ModelUpdate {
  delta: Uint8Array;
  meta?: Metadata | undefined;
  baseVersion: string;
  signature: string;
  /** P2P identifier */
  peerId: string;
  /** Federation role */
  isAggregator: boolean;
}

export interface Model {
  weights: Uint8Array;
  meta?: Metadata | undefined;
  version: string;
  parentHash: string;
  integrityCheck: string;
}

/** --- Support Messages --- */
export interface ModelUpdateAck {
  accepted: boolean;
  message: string;
}

export interface ModelRequest {
  version: string;
  includeWeights: boolean;
}

/** Client feedback mechanism */
export interface ClientEvent {
  taskUuid: string;
  /** e.g., "feedback", "correction" */
  eventType: string;
  payload: { [key: string]: string };
  /** Reference URI */
  sourceUri: string;
}

export interface ClientEvent_PayloadEntry {
  key: string;
  value: string;
}

export interface ClientEventAck {
  processed: boolean;
}

function createBaseContentChunk(): ContentChunk {
  return { data: new Uint8Array(0), sequence: 0, isLast: false, tokenCount: 0, contentHash: "", sourceUri: "" };
}

export const ContentChunk: MessageFns<ContentChunk> = {
  encode(message: ContentChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.sequence !== 0) {
      writer.uint32(16).int32(message.sequence);
    }
    if (message.isLast !== false) {
      writer.uint32(24).bool(message.isLast);
    }
    if (message.tokenCount !== 0) {
      writer.uint32(32).int32(message.tokenCount);
    }
    if (message.contentHash !== "") {
      writer.uint32(42).string(message.contentHash);
    }
    if (message.sourceUri !== "") {
      writer.uint32(50).string(message.sourceUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sequence = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isLast = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tokenCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contentHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentChunk {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      isLast: isSet(object.isLast) ? globalThis.Boolean(object.isLast) : false,
      tokenCount: isSet(object.tokenCount) ? globalThis.Number(object.tokenCount) : 0,
      contentHash: isSet(object.contentHash) ? globalThis.String(object.contentHash) : "",
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
    };
  },

  toJSON(message: ContentChunk): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.isLast !== false) {
      obj.isLast = message.isLast;
    }
    if (message.tokenCount !== 0) {
      obj.tokenCount = Math.round(message.tokenCount);
    }
    if (message.contentHash !== "") {
      obj.contentHash = message.contentHash;
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentChunk>, I>>(base?: I): ContentChunk {
    return ContentChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentChunk>, I>>(object: I): ContentChunk {
    const message = createBaseContentChunk();
    message.data = object.data ?? new Uint8Array(0);
    message.sequence = object.sequence ?? 0;
    message.isLast = object.isLast ?? false;
    message.tokenCount = object.tokenCount ?? 0;
    message.contentHash = object.contentHash ?? "";
    message.sourceUri = object.sourceUri ?? "";
    return message;
  },
};

function createBaseRelation(): Relation {
  return { type: "", targetUri: "", strength: 0, lastUpdated: "0" };
}

export const Relation: MessageFns<Relation> = {
  encode(message: Relation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.targetUri !== "") {
      writer.uint32(18).string(message.targetUri);
    }
    if (message.strength !== 0) {
      writer.uint32(29).float(message.strength);
    }
    if (message.lastUpdated !== "0") {
      writer.uint32(32).int64(message.lastUpdated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Relation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetUri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.strength = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastUpdated = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Relation {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      targetUri: isSet(object.targetUri) ? globalThis.String(object.targetUri) : "",
      strength: isSet(object.strength) ? globalThis.Number(object.strength) : 0,
      lastUpdated: isSet(object.lastUpdated) ? globalThis.String(object.lastUpdated) : "0",
    };
  },

  toJSON(message: Relation): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.targetUri !== "") {
      obj.targetUri = message.targetUri;
    }
    if (message.strength !== 0) {
      obj.strength = message.strength;
    }
    if (message.lastUpdated !== "0") {
      obj.lastUpdated = message.lastUpdated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Relation>, I>>(base?: I): Relation {
    return Relation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Relation>, I>>(object: I): Relation {
    const message = createBaseRelation();
    message.type = object.type ?? "";
    message.targetUri = object.targetUri ?? "";
    message.strength = object.strength ?? 0;
    message.lastUpdated = object.lastUpdated ?? "0";
    return message;
  },
};

function createBaseSecurityAssessment(): SecurityAssessment {
  return { level: 0, indicators: [], quarantinePath: "" };
}

export const SecurityAssessment: MessageFns<SecurityAssessment> = {
  encode(message: SecurityAssessment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== 0) {
      writer.uint32(8).int32(message.level);
    }
    for (const v of message.indicators) {
      writer.uint32(18).string(v!);
    }
    if (message.quarantinePath !== "") {
      writer.uint32(26).string(message.quarantinePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityAssessment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityAssessment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.indicators.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quarantinePath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityAssessment {
    return {
      level: isSet(object.level) ? securityAssessment_ThreatLevelFromJSON(object.level) : 0,
      indicators: globalThis.Array.isArray(object?.indicators)
        ? object.indicators.map((e: any) => globalThis.String(e))
        : [],
      quarantinePath: isSet(object.quarantinePath) ? globalThis.String(object.quarantinePath) : "",
    };
  },

  toJSON(message: SecurityAssessment): unknown {
    const obj: any = {};
    if (message.level !== 0) {
      obj.level = securityAssessment_ThreatLevelToJSON(message.level);
    }
    if (message.indicators?.length) {
      obj.indicators = message.indicators;
    }
    if (message.quarantinePath !== "") {
      obj.quarantinePath = message.quarantinePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityAssessment>, I>>(base?: I): SecurityAssessment {
    return SecurityAssessment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityAssessment>, I>>(object: I): SecurityAssessment {
    const message = createBaseSecurityAssessment();
    message.level = object.level ?? 0;
    message.indicators = object.indicators?.map((e) => e) || [];
    message.quarantinePath = object.quarantinePath ?? "";
    return message;
  },
};

function createBaseEnrichmentRequest(): EnrichmentRequest {
  return {
    taskUuid: "",
    contentType: 0,
    metadata: undefined,
    rawData: undefined,
    chunk: undefined,
    security: undefined,
  };
}

export const EnrichmentRequest: MessageFns<EnrichmentRequest> = {
  encode(message: EnrichmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskUuid !== "") {
      writer.uint32(10).string(message.taskUuid);
    }
    if (message.contentType !== 0) {
      writer.uint32(16).int32(message.contentType);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.rawData !== undefined) {
      writer.uint32(34).bytes(message.rawData);
    }
    if (message.chunk !== undefined) {
      ContentChunk.encode(message.chunk, writer.uint32(42).fork()).join();
    }
    if (message.security !== undefined) {
      SecurityAssessment.encode(message.security, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnrichmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnrichmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.contentType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rawData = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.chunk = ContentChunk.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.security = SecurityAssessment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnrichmentRequest {
    return {
      taskUuid: isSet(object.taskUuid) ? globalThis.String(object.taskUuid) : "",
      contentType: isSet(object.contentType) ? contentTypeFromJSON(object.contentType) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      rawData: isSet(object.rawData) ? bytesFromBase64(object.rawData) : undefined,
      chunk: isSet(object.chunk) ? ContentChunk.fromJSON(object.chunk) : undefined,
      security: isSet(object.security) ? SecurityAssessment.fromJSON(object.security) : undefined,
    };
  },

  toJSON(message: EnrichmentRequest): unknown {
    const obj: any = {};
    if (message.taskUuid !== "") {
      obj.taskUuid = message.taskUuid;
    }
    if (message.contentType !== 0) {
      obj.contentType = contentTypeToJSON(message.contentType);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.rawData !== undefined) {
      obj.rawData = base64FromBytes(message.rawData);
    }
    if (message.chunk !== undefined) {
      obj.chunk = ContentChunk.toJSON(message.chunk);
    }
    if (message.security !== undefined) {
      obj.security = SecurityAssessment.toJSON(message.security);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnrichmentRequest>, I>>(base?: I): EnrichmentRequest {
    return EnrichmentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnrichmentRequest>, I>>(object: I): EnrichmentRequest {
    const message = createBaseEnrichmentRequest();
    message.taskUuid = object.taskUuid ?? "";
    message.contentType = object.contentType ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.rawData = object.rawData ?? undefined;
    message.chunk = (object.chunk !== undefined && object.chunk !== null)
      ? ContentChunk.fromPartial(object.chunk)
      : undefined;
    message.security = (object.security !== undefined && object.security !== null)
      ? SecurityAssessment.fromPartial(object.security)
      : undefined;
    return message;
  },
};

function createBaseTextEnrichment(): TextEnrichment {
  return { summary: "", entities: [], sentimentScore: 0, keyPhrases: [], topicDistribution: {} };
}

export const TextEnrichment: MessageFns<TextEnrichment> = {
  encode(message: TextEnrichment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summary !== "") {
      writer.uint32(10).string(message.summary);
    }
    for (const v of message.entities) {
      Entity.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.sentimentScore !== 0) {
      writer.uint32(29).float(message.sentimentScore);
    }
    for (const v of message.keyPhrases) {
      writer.uint32(34).string(v!);
    }
    Object.entries(message.topicDistribution).forEach(([key, value]) => {
      TextEnrichment_TopicDistributionEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextEnrichment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextEnrichment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entities.push(Entity.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.sentimentScore = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keyPhrases.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = TextEnrichment_TopicDistributionEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.topicDistribution[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextEnrichment {
    return {
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      entities: globalThis.Array.isArray(object?.entities) ? object.entities.map((e: any) => Entity.fromJSON(e)) : [],
      sentimentScore: isSet(object.sentimentScore) ? globalThis.Number(object.sentimentScore) : 0,
      keyPhrases: globalThis.Array.isArray(object?.keyPhrases)
        ? object.keyPhrases.map((e: any) => globalThis.String(e))
        : [],
      topicDistribution: isObject(object.topicDistribution)
        ? Object.entries(object.topicDistribution).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TextEnrichment): unknown {
    const obj: any = {};
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.entities?.length) {
      obj.entities = message.entities.map((e) => Entity.toJSON(e));
    }
    if (message.sentimentScore !== 0) {
      obj.sentimentScore = message.sentimentScore;
    }
    if (message.keyPhrases?.length) {
      obj.keyPhrases = message.keyPhrases;
    }
    if (message.topicDistribution) {
      const entries = Object.entries(message.topicDistribution);
      if (entries.length > 0) {
        obj.topicDistribution = {};
        entries.forEach(([k, v]) => {
          obj.topicDistribution[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextEnrichment>, I>>(base?: I): TextEnrichment {
    return TextEnrichment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextEnrichment>, I>>(object: I): TextEnrichment {
    const message = createBaseTextEnrichment();
    message.summary = object.summary ?? "";
    message.entities = object.entities?.map((e) => Entity.fromPartial(e)) || [];
    message.sentimentScore = object.sentimentScore ?? 0;
    message.keyPhrases = object.keyPhrases?.map((e) => e) || [];
    message.topicDistribution = Object.entries(object.topicDistribution ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTextEnrichment_TopicDistributionEntry(): TextEnrichment_TopicDistributionEntry {
  return { key: "", value: 0 };
}

export const TextEnrichment_TopicDistributionEntry: MessageFns<TextEnrichment_TopicDistributionEntry> = {
  encode(message: TextEnrichment_TopicDistributionEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextEnrichment_TopicDistributionEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextEnrichment_TopicDistributionEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextEnrichment_TopicDistributionEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: TextEnrichment_TopicDistributionEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextEnrichment_TopicDistributionEntry>, I>>(
    base?: I,
  ): TextEnrichment_TopicDistributionEntry {
    return TextEnrichment_TopicDistributionEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextEnrichment_TopicDistributionEntry>, I>>(
    object: I,
  ): TextEnrichment_TopicDistributionEntry {
    const message = createBaseTextEnrichment_TopicDistributionEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMediaEnrichment(): MediaEnrichment {
  return { caption: "", detectedObjects: [], transcription: "", keywords: [] };
}

export const MediaEnrichment: MessageFns<MediaEnrichment> = {
  encode(message: MediaEnrichment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caption !== "") {
      writer.uint32(10).string(message.caption);
    }
    for (const v of message.detectedObjects) {
      Entity.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.transcription !== "") {
      writer.uint32(26).string(message.transcription);
    }
    for (const v of message.keywords) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MediaEnrichment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMediaEnrichment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.caption = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.detectedObjects.push(Entity.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transcription = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keywords.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MediaEnrichment {
    return {
      caption: isSet(object.caption) ? globalThis.String(object.caption) : "",
      detectedObjects: globalThis.Array.isArray(object?.detectedObjects)
        ? object.detectedObjects.map((e: any) => Entity.fromJSON(e))
        : [],
      transcription: isSet(object.transcription) ? globalThis.String(object.transcription) : "",
      keywords: globalThis.Array.isArray(object?.keywords) ? object.keywords.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MediaEnrichment): unknown {
    const obj: any = {};
    if (message.caption !== "") {
      obj.caption = message.caption;
    }
    if (message.detectedObjects?.length) {
      obj.detectedObjects = message.detectedObjects.map((e) => Entity.toJSON(e));
    }
    if (message.transcription !== "") {
      obj.transcription = message.transcription;
    }
    if (message.keywords?.length) {
      obj.keywords = message.keywords;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MediaEnrichment>, I>>(base?: I): MediaEnrichment {
    return MediaEnrichment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MediaEnrichment>, I>>(object: I): MediaEnrichment {
    const message = createBaseMediaEnrichment();
    message.caption = object.caption ?? "";
    message.detectedObjects = object.detectedObjects?.map((e) => Entity.fromPartial(e)) || [];
    message.transcription = object.transcription ?? "";
    message.keywords = object.keywords?.map((e) => e) || [];
    return message;
  },
};

function createBaseEnrichmentResponse(): EnrichmentResponse {
  return {
    taskUuid: "",
    text: undefined,
    media: undefined,
    knowledgeGaps: [],
    errorMessage: "",
    vector: undefined,
    relations: [],
  };
}

export const EnrichmentResponse: MessageFns<EnrichmentResponse> = {
  encode(message: EnrichmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskUuid !== "") {
      writer.uint32(10).string(message.taskUuid);
    }
    if (message.text !== undefined) {
      TextEnrichment.encode(message.text, writer.uint32(18).fork()).join();
    }
    if (message.media !== undefined) {
      MediaEnrichment.encode(message.media, writer.uint32(26).fork()).join();
    }
    for (const v of message.knowledgeGaps) {
      writer.uint32(34).string(v!);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    if (message.vector !== undefined) {
      EnrichmentResponse_Vector.encode(message.vector, writer.uint32(50).fork()).join();
    }
    for (const v of message.relations) {
      Relation.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnrichmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnrichmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = TextEnrichment.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.media = MediaEnrichment.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.knowledgeGaps.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.vector = EnrichmentResponse_Vector.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.relations.push(Relation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnrichmentResponse {
    return {
      taskUuid: isSet(object.taskUuid) ? globalThis.String(object.taskUuid) : "",
      text: isSet(object.text) ? TextEnrichment.fromJSON(object.text) : undefined,
      media: isSet(object.media) ? MediaEnrichment.fromJSON(object.media) : undefined,
      knowledgeGaps: globalThis.Array.isArray(object?.knowledgeGaps)
        ? object.knowledgeGaps.map((e: any) => globalThis.String(e))
        : [],
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      vector: isSet(object.vector) ? EnrichmentResponse_Vector.fromJSON(object.vector) : undefined,
      relations: globalThis.Array.isArray(object?.relations)
        ? object.relations.map((e: any) => Relation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EnrichmentResponse): unknown {
    const obj: any = {};
    if (message.taskUuid !== "") {
      obj.taskUuid = message.taskUuid;
    }
    if (message.text !== undefined) {
      obj.text = TextEnrichment.toJSON(message.text);
    }
    if (message.media !== undefined) {
      obj.media = MediaEnrichment.toJSON(message.media);
    }
    if (message.knowledgeGaps?.length) {
      obj.knowledgeGaps = message.knowledgeGaps;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.vector !== undefined) {
      obj.vector = EnrichmentResponse_Vector.toJSON(message.vector);
    }
    if (message.relations?.length) {
      obj.relations = message.relations.map((e) => Relation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnrichmentResponse>, I>>(base?: I): EnrichmentResponse {
    return EnrichmentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnrichmentResponse>, I>>(object: I): EnrichmentResponse {
    const message = createBaseEnrichmentResponse();
    message.taskUuid = object.taskUuid ?? "";
    message.text = (object.text !== undefined && object.text !== null)
      ? TextEnrichment.fromPartial(object.text)
      : undefined;
    message.media = (object.media !== undefined && object.media !== null)
      ? MediaEnrichment.fromPartial(object.media)
      : undefined;
    message.knowledgeGaps = object.knowledgeGaps?.map((e) => e) || [];
    message.errorMessage = object.errorMessage ?? "";
    message.vector = (object.vector !== undefined && object.vector !== null)
      ? EnrichmentResponse_Vector.fromPartial(object.vector)
      : undefined;
    message.relations = object.relations?.map((e) => Relation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEnrichmentResponse_Vector(): EnrichmentResponse_Vector {
  return { values: [], model: "", dimensions: 0 };
}

export const EnrichmentResponse_Vector: MessageFns<EnrichmentResponse_Vector> = {
  encode(message: EnrichmentResponse_Vector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.float(v);
    }
    writer.join();
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    if (message.dimensions !== 0) {
      writer.uint32(24).int32(message.dimensions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnrichmentResponse_Vector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnrichmentResponse_Vector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.values.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.float());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dimensions = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnrichmentResponse_Vector {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      dimensions: isSet(object.dimensions) ? globalThis.Number(object.dimensions) : 0,
    };
  },

  toJSON(message: EnrichmentResponse_Vector): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.dimensions !== 0) {
      obj.dimensions = Math.round(message.dimensions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnrichmentResponse_Vector>, I>>(base?: I): EnrichmentResponse_Vector {
    return EnrichmentResponse_Vector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnrichmentResponse_Vector>, I>>(object: I): EnrichmentResponse_Vector {
    const message = createBaseEnrichmentResponse_Vector();
    message.values = object.values?.map((e) => e) || [];
    message.model = object.model ?? "";
    message.dimensions = object.dimensions ?? 0;
    return message;
  },
};

function createBaseModelUpdate(): ModelUpdate {
  return { delta: new Uint8Array(0), meta: undefined, baseVersion: "", signature: "", peerId: "", isAggregator: false };
}

export const ModelUpdate: MessageFns<ModelUpdate> = {
  encode(message: ModelUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delta.length !== 0) {
      writer.uint32(10).bytes(message.delta);
    }
    if (message.meta !== undefined) {
      Metadata.encode(message.meta, writer.uint32(18).fork()).join();
    }
    if (message.baseVersion !== "") {
      writer.uint32(26).string(message.baseVersion);
    }
    if (message.signature !== "") {
      writer.uint32(34).string(message.signature);
    }
    if (message.peerId !== "") {
      writer.uint32(42).string(message.peerId);
    }
    if (message.isAggregator !== false) {
      writer.uint32(48).bool(message.isAggregator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delta = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.peerId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isAggregator = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelUpdate {
    return {
      delta: isSet(object.delta) ? bytesFromBase64(object.delta) : new Uint8Array(0),
      meta: isSet(object.meta) ? Metadata.fromJSON(object.meta) : undefined,
      baseVersion: isSet(object.baseVersion) ? globalThis.String(object.baseVersion) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      peerId: isSet(object.peerId) ? globalThis.String(object.peerId) : "",
      isAggregator: isSet(object.isAggregator) ? globalThis.Boolean(object.isAggregator) : false,
    };
  },

  toJSON(message: ModelUpdate): unknown {
    const obj: any = {};
    if (message.delta.length !== 0) {
      obj.delta = base64FromBytes(message.delta);
    }
    if (message.meta !== undefined) {
      obj.meta = Metadata.toJSON(message.meta);
    }
    if (message.baseVersion !== "") {
      obj.baseVersion = message.baseVersion;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.peerId !== "") {
      obj.peerId = message.peerId;
    }
    if (message.isAggregator !== false) {
      obj.isAggregator = message.isAggregator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelUpdate>, I>>(base?: I): ModelUpdate {
    return ModelUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelUpdate>, I>>(object: I): ModelUpdate {
    const message = createBaseModelUpdate();
    message.delta = object.delta ?? new Uint8Array(0);
    message.meta = (object.meta !== undefined && object.meta !== null) ? Metadata.fromPartial(object.meta) : undefined;
    message.baseVersion = object.baseVersion ?? "";
    message.signature = object.signature ?? "";
    message.peerId = object.peerId ?? "";
    message.isAggregator = object.isAggregator ?? false;
    return message;
  },
};

function createBaseModel(): Model {
  return { weights: new Uint8Array(0), meta: undefined, version: "", parentHash: "", integrityCheck: "" };
}

export const Model: MessageFns<Model> = {
  encode(message: Model, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.weights.length !== 0) {
      writer.uint32(10).bytes(message.weights);
    }
    if (message.meta !== undefined) {
      Metadata.encode(message.meta, writer.uint32(18).fork()).join();
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.parentHash !== "") {
      writer.uint32(34).string(message.parentHash);
    }
    if (message.integrityCheck !== "") {
      writer.uint32(42).string(message.integrityCheck);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.weights = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.meta = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.integrityCheck = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model {
    return {
      weights: isSet(object.weights) ? bytesFromBase64(object.weights) : new Uint8Array(0),
      meta: isSet(object.meta) ? Metadata.fromJSON(object.meta) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      parentHash: isSet(object.parentHash) ? globalThis.String(object.parentHash) : "",
      integrityCheck: isSet(object.integrityCheck) ? globalThis.String(object.integrityCheck) : "",
    };
  },

  toJSON(message: Model): unknown {
    const obj: any = {};
    if (message.weights.length !== 0) {
      obj.weights = base64FromBytes(message.weights);
    }
    if (message.meta !== undefined) {
      obj.meta = Metadata.toJSON(message.meta);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.parentHash !== "") {
      obj.parentHash = message.parentHash;
    }
    if (message.integrityCheck !== "") {
      obj.integrityCheck = message.integrityCheck;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Model>, I>>(base?: I): Model {
    return Model.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Model>, I>>(object: I): Model {
    const message = createBaseModel();
    message.weights = object.weights ?? new Uint8Array(0);
    message.meta = (object.meta !== undefined && object.meta !== null) ? Metadata.fromPartial(object.meta) : undefined;
    message.version = object.version ?? "";
    message.parentHash = object.parentHash ?? "";
    message.integrityCheck = object.integrityCheck ?? "";
    return message;
  },
};

function createBaseModelUpdateAck(): ModelUpdateAck {
  return { accepted: false, message: "" };
}

export const ModelUpdateAck: MessageFns<ModelUpdateAck> = {
  encode(message: ModelUpdateAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accepted !== false) {
      writer.uint32(8).bool(message.accepted);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelUpdateAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelUpdateAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.accepted = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelUpdateAck {
    return {
      accepted: isSet(object.accepted) ? globalThis.Boolean(object.accepted) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ModelUpdateAck): unknown {
    const obj: any = {};
    if (message.accepted !== false) {
      obj.accepted = message.accepted;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelUpdateAck>, I>>(base?: I): ModelUpdateAck {
    return ModelUpdateAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelUpdateAck>, I>>(object: I): ModelUpdateAck {
    const message = createBaseModelUpdateAck();
    message.accepted = object.accepted ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseModelRequest(): ModelRequest {
  return { version: "", includeWeights: false };
}

export const ModelRequest: MessageFns<ModelRequest> = {
  encode(message: ModelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.includeWeights !== false) {
      writer.uint32(16).bool(message.includeWeights);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeWeights = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelRequest {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      includeWeights: isSet(object.includeWeights) ? globalThis.Boolean(object.includeWeights) : false,
    };
  },

  toJSON(message: ModelRequest): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.includeWeights !== false) {
      obj.includeWeights = message.includeWeights;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelRequest>, I>>(base?: I): ModelRequest {
    return ModelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelRequest>, I>>(object: I): ModelRequest {
    const message = createBaseModelRequest();
    message.version = object.version ?? "";
    message.includeWeights = object.includeWeights ?? false;
    return message;
  },
};

function createBaseClientEvent(): ClientEvent {
  return { taskUuid: "", eventType: "", payload: {}, sourceUri: "" };
}

export const ClientEvent: MessageFns<ClientEvent> = {
  encode(message: ClientEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskUuid !== "") {
      writer.uint32(10).string(message.taskUuid);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    Object.entries(message.payload).forEach(([key, value]) => {
      ClientEvent_PayloadEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.sourceUri !== "") {
      writer.uint32(34).string(message.sourceUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ClientEvent_PayloadEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.payload[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent {
    return {
      taskUuid: isSet(object.taskUuid) ? globalThis.String(object.taskUuid) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      payload: isObject(object.payload)
        ? Object.entries(object.payload).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
    };
  },

  toJSON(message: ClientEvent): unknown {
    const obj: any = {};
    if (message.taskUuid !== "") {
      obj.taskUuid = message.taskUuid;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.payload) {
      const entries = Object.entries(message.payload);
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent>, I>>(base?: I): ClientEvent {
    return ClientEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent>, I>>(object: I): ClientEvent {
    const message = createBaseClientEvent();
    message.taskUuid = object.taskUuid ?? "";
    message.eventType = object.eventType ?? "";
    message.payload = Object.entries(object.payload ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.sourceUri = object.sourceUri ?? "";
    return message;
  },
};

function createBaseClientEvent_PayloadEntry(): ClientEvent_PayloadEntry {
  return { key: "", value: "" };
}

export const ClientEvent_PayloadEntry: MessageFns<ClientEvent_PayloadEntry> = {
  encode(message: ClientEvent_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEvent_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEvent_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEvent_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ClientEvent_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEvent_PayloadEntry>, I>>(base?: I): ClientEvent_PayloadEntry {
    return ClientEvent_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEvent_PayloadEntry>, I>>(object: I): ClientEvent_PayloadEntry {
    const message = createBaseClientEvent_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseClientEventAck(): ClientEventAck {
  return { processed: false };
}

export const ClientEventAck: MessageFns<ClientEventAck> = {
  encode(message: ClientEventAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processed !== false) {
      writer.uint32(8).bool(message.processed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientEventAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientEventAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.processed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientEventAck {
    return { processed: isSet(object.processed) ? globalThis.Boolean(object.processed) : false };
  },

  toJSON(message: ClientEventAck): unknown {
    const obj: any = {};
    if (message.processed !== false) {
      obj.processed = message.processed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientEventAck>, I>>(base?: I): ClientEventAck {
    return ClientEventAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientEventAck>, I>>(object: I): ClientEventAck {
    const message = createBaseClientEventAck();
    message.processed = object.processed ?? false;
    return message;
  },
};

/** --- Service Definitions --- */
export interface AIService {
  ProcessContent(request: Observable<EnrichmentRequest>): Promise<EnrichmentResponse>;
  GenerateEmbeddings(request: EnrichmentRequest): Promise<EnrichmentResponse_Vector>;
  SubmitModelUpdate(request: ModelUpdate): Promise<ModelUpdateAck>;
  GetCurrentModel(request: ModelRequest): Promise<Model>;
  /** New client feedback endpoint */
  HandleClientEvent(request: ClientEvent): Promise<ClientEventAck>;
}

export const AIServiceServiceName = "ai.v1.AIService";
export class AIServiceClientImpl implements AIService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AIServiceServiceName;
    this.rpc = rpc;
    this.ProcessContent = this.ProcessContent.bind(this);
    this.GenerateEmbeddings = this.GenerateEmbeddings.bind(this);
    this.SubmitModelUpdate = this.SubmitModelUpdate.bind(this);
    this.GetCurrentModel = this.GetCurrentModel.bind(this);
    this.HandleClientEvent = this.HandleClientEvent.bind(this);
  }
  ProcessContent(request: Observable<EnrichmentRequest>): Promise<EnrichmentResponse> {
    const data = request.pipe(map((request) => EnrichmentRequest.encode(request).finish()));
    const promise = this.rpc.clientStreamingRequest(this.service, "ProcessContent", data);
    return promise.then((data) => EnrichmentResponse.decode(new BinaryReader(data)));
  }

  GenerateEmbeddings(request: EnrichmentRequest): Promise<EnrichmentResponse_Vector> {
    const data = EnrichmentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GenerateEmbeddings", data);
    return promise.then((data) => EnrichmentResponse_Vector.decode(new BinaryReader(data)));
  }

  SubmitModelUpdate(request: ModelUpdate): Promise<ModelUpdateAck> {
    const data = ModelUpdate.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitModelUpdate", data);
    return promise.then((data) => ModelUpdateAck.decode(new BinaryReader(data)));
  }

  GetCurrentModel(request: ModelRequest): Promise<Model> {
    const data = ModelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCurrentModel", data);
    return promise.then((data) => Model.decode(new BinaryReader(data)));
  }

  HandleClientEvent(request: ClientEvent): Promise<ClientEventAck> {
    const data = ClientEvent.encode(request).finish();
    const promise = this.rpc.request(this.service, "HandleClientEvent", data);
    return promise.then((data) => ClientEventAck.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
