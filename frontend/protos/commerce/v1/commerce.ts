// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: commerce/v1/commerce.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Metadata } from "../../common/v1/metadata";
import { Struct } from "../../google/protobuf/struct";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "commerce.v1";

export enum QuoteStatus {
  QUOTE_STATUS_UNSPECIFIED = 0,
  QUOTE_STATUS_PENDING = 1,
  QUOTE_STATUS_ACCEPTED = 2,
  QUOTE_STATUS_REJECTED = 3,
  QUOTE_STATUS_EXPIRED = 4,
  UNRECOGNIZED = -1,
}

export function quoteStatusFromJSON(object: any): QuoteStatus {
  switch (object) {
    case 0:
    case "QUOTE_STATUS_UNSPECIFIED":
      return QuoteStatus.QUOTE_STATUS_UNSPECIFIED;
    case 1:
    case "QUOTE_STATUS_PENDING":
      return QuoteStatus.QUOTE_STATUS_PENDING;
    case 2:
    case "QUOTE_STATUS_ACCEPTED":
      return QuoteStatus.QUOTE_STATUS_ACCEPTED;
    case 3:
    case "QUOTE_STATUS_REJECTED":
      return QuoteStatus.QUOTE_STATUS_REJECTED;
    case 4:
    case "QUOTE_STATUS_EXPIRED":
      return QuoteStatus.QUOTE_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QuoteStatus.UNRECOGNIZED;
  }
}

export function quoteStatusToJSON(object: QuoteStatus): string {
  switch (object) {
    case QuoteStatus.QUOTE_STATUS_UNSPECIFIED:
      return "QUOTE_STATUS_UNSPECIFIED";
    case QuoteStatus.QUOTE_STATUS_PENDING:
      return "QUOTE_STATUS_PENDING";
    case QuoteStatus.QUOTE_STATUS_ACCEPTED:
      return "QUOTE_STATUS_ACCEPTED";
    case QuoteStatus.QUOTE_STATUS_REJECTED:
      return "QUOTE_STATUS_REJECTED";
    case QuoteStatus.QUOTE_STATUS_EXPIRED:
      return "QUOTE_STATUS_EXPIRED";
    case QuoteStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OrderStatus {
  ORDER_STATUS_UNSPECIFIED = 0,
  ORDER_STATUS_PENDING = 1,
  ORDER_STATUS_PAID = 2,
  ORDER_STATUS_SHIPPED = 3,
  ORDER_STATUS_COMPLETED = 4,
  ORDER_STATUS_CANCELLED = 5,
  ORDER_STATUS_REFUNDED = 6,
  UNRECOGNIZED = -1,
}

export function orderStatusFromJSON(object: any): OrderStatus {
  switch (object) {
    case 0:
    case "ORDER_STATUS_UNSPECIFIED":
      return OrderStatus.ORDER_STATUS_UNSPECIFIED;
    case 1:
    case "ORDER_STATUS_PENDING":
      return OrderStatus.ORDER_STATUS_PENDING;
    case 2:
    case "ORDER_STATUS_PAID":
      return OrderStatus.ORDER_STATUS_PAID;
    case 3:
    case "ORDER_STATUS_SHIPPED":
      return OrderStatus.ORDER_STATUS_SHIPPED;
    case 4:
    case "ORDER_STATUS_COMPLETED":
      return OrderStatus.ORDER_STATUS_COMPLETED;
    case 5:
    case "ORDER_STATUS_CANCELLED":
      return OrderStatus.ORDER_STATUS_CANCELLED;
    case 6:
    case "ORDER_STATUS_REFUNDED":
      return OrderStatus.ORDER_STATUS_REFUNDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderStatus.UNRECOGNIZED;
  }
}

export function orderStatusToJSON(object: OrderStatus): string {
  switch (object) {
    case OrderStatus.ORDER_STATUS_UNSPECIFIED:
      return "ORDER_STATUS_UNSPECIFIED";
    case OrderStatus.ORDER_STATUS_PENDING:
      return "ORDER_STATUS_PENDING";
    case OrderStatus.ORDER_STATUS_PAID:
      return "ORDER_STATUS_PAID";
    case OrderStatus.ORDER_STATUS_SHIPPED:
      return "ORDER_STATUS_SHIPPED";
    case OrderStatus.ORDER_STATUS_COMPLETED:
      return "ORDER_STATUS_COMPLETED";
    case OrderStatus.ORDER_STATUS_CANCELLED:
      return "ORDER_STATUS_CANCELLED";
    case OrderStatus.ORDER_STATUS_REFUNDED:
      return "ORDER_STATUS_REFUNDED";
    case OrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PaymentStatus {
  PAYMENT_STATUS_UNSPECIFIED = 0,
  PAYMENT_STATUS_PENDING = 1,
  PAYMENT_STATUS_SUCCEEDED = 2,
  PAYMENT_STATUS_FAILED = 3,
  PAYMENT_STATUS_REFUNDED = 4,
  UNRECOGNIZED = -1,
}

export function paymentStatusFromJSON(object: any): PaymentStatus {
  switch (object) {
    case 0:
    case "PAYMENT_STATUS_UNSPECIFIED":
      return PaymentStatus.PAYMENT_STATUS_UNSPECIFIED;
    case 1:
    case "PAYMENT_STATUS_PENDING":
      return PaymentStatus.PAYMENT_STATUS_PENDING;
    case 2:
    case "PAYMENT_STATUS_SUCCEEDED":
      return PaymentStatus.PAYMENT_STATUS_SUCCEEDED;
    case 3:
    case "PAYMENT_STATUS_FAILED":
      return PaymentStatus.PAYMENT_STATUS_FAILED;
    case 4:
    case "PAYMENT_STATUS_REFUNDED":
      return PaymentStatus.PAYMENT_STATUS_REFUNDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentStatus.UNRECOGNIZED;
  }
}

export function paymentStatusToJSON(object: PaymentStatus): string {
  switch (object) {
    case PaymentStatus.PAYMENT_STATUS_UNSPECIFIED:
      return "PAYMENT_STATUS_UNSPECIFIED";
    case PaymentStatus.PAYMENT_STATUS_PENDING:
      return "PAYMENT_STATUS_PENDING";
    case PaymentStatus.PAYMENT_STATUS_SUCCEEDED:
      return "PAYMENT_STATUS_SUCCEEDED";
    case PaymentStatus.PAYMENT_STATUS_FAILED:
      return "PAYMENT_STATUS_FAILED";
    case PaymentStatus.PAYMENT_STATUS_REFUNDED:
      return "PAYMENT_STATUS_REFUNDED";
    case PaymentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionType {
  TRANSACTION_TYPE_UNSPECIFIED = 0,
  TRANSACTION_TYPE_CREDIT = 1,
  TRANSACTION_TYPE_DEBIT = 2,
  TRANSACTION_TYPE_REFUND = 3,
  UNRECOGNIZED = -1,
}

export function transactionTypeFromJSON(object: any): TransactionType {
  switch (object) {
    case 0:
    case "TRANSACTION_TYPE_UNSPECIFIED":
      return TransactionType.TRANSACTION_TYPE_UNSPECIFIED;
    case 1:
    case "TRANSACTION_TYPE_CREDIT":
      return TransactionType.TRANSACTION_TYPE_CREDIT;
    case 2:
    case "TRANSACTION_TYPE_DEBIT":
      return TransactionType.TRANSACTION_TYPE_DEBIT;
    case 3:
    case "TRANSACTION_TYPE_REFUND":
      return TransactionType.TRANSACTION_TYPE_REFUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionType.UNRECOGNIZED;
  }
}

export function transactionTypeToJSON(object: TransactionType): string {
  switch (object) {
    case TransactionType.TRANSACTION_TYPE_UNSPECIFIED:
      return "TRANSACTION_TYPE_UNSPECIFIED";
    case TransactionType.TRANSACTION_TYPE_CREDIT:
      return "TRANSACTION_TYPE_CREDIT";
    case TransactionType.TRANSACTION_TYPE_DEBIT:
      return "TRANSACTION_TYPE_DEBIT";
    case TransactionType.TRANSACTION_TYPE_REFUND:
      return "TRANSACTION_TYPE_REFUND";
    case TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TransactionStatus {
  TRANSACTION_STATUS_UNSPECIFIED = 0,
  TRANSACTION_STATUS_PENDING = 1,
  TRANSACTION_STATUS_COMPLETED = 2,
  TRANSACTION_STATUS_FAILED = 3,
  UNRECOGNIZED = -1,
}

export function transactionStatusFromJSON(object: any): TransactionStatus {
  switch (object) {
    case 0:
    case "TRANSACTION_STATUS_UNSPECIFIED":
      return TransactionStatus.TRANSACTION_STATUS_UNSPECIFIED;
    case 1:
    case "TRANSACTION_STATUS_PENDING":
      return TransactionStatus.TRANSACTION_STATUS_PENDING;
    case 2:
    case "TRANSACTION_STATUS_COMPLETED":
      return TransactionStatus.TRANSACTION_STATUS_COMPLETED;
    case 3:
    case "TRANSACTION_STATUS_FAILED":
      return TransactionStatus.TRANSACTION_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionStatus.UNRECOGNIZED;
  }
}

export function transactionStatusToJSON(object: TransactionStatus): string {
  switch (object) {
    case TransactionStatus.TRANSACTION_STATUS_UNSPECIFIED:
      return "TRANSACTION_STATUS_UNSPECIFIED";
    case TransactionStatus.TRANSACTION_STATUS_PENDING:
      return "TRANSACTION_STATUS_PENDING";
    case TransactionStatus.TRANSACTION_STATUS_COMPLETED:
      return "TRANSACTION_STATUS_COMPLETED";
    case TransactionStatus.TRANSACTION_STATUS_FAILED:
      return "TRANSACTION_STATUS_FAILED";
    case TransactionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum InvestmentOrderStatus {
  INVESTMENT_ORDER_STATUS_UNSPECIFIED = 0,
  INVESTMENT_ORDER_STATUS_PENDING = 1,
  INVESTMENT_ORDER_STATUS_FILLED = 2,
  INVESTMENT_ORDER_STATUS_CANCELLED = 3,
  INVESTMENT_ORDER_STATUS_FAILED = 4,
  UNRECOGNIZED = -1,
}

export function investmentOrderStatusFromJSON(object: any): InvestmentOrderStatus {
  switch (object) {
    case 0:
    case "INVESTMENT_ORDER_STATUS_UNSPECIFIED":
      return InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_UNSPECIFIED;
    case 1:
    case "INVESTMENT_ORDER_STATUS_PENDING":
      return InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_PENDING;
    case 2:
    case "INVESTMENT_ORDER_STATUS_FILLED":
      return InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_FILLED;
    case 3:
    case "INVESTMENT_ORDER_STATUS_CANCELLED":
      return InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_CANCELLED;
    case 4:
    case "INVESTMENT_ORDER_STATUS_FAILED":
      return InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InvestmentOrderStatus.UNRECOGNIZED;
  }
}

export function investmentOrderStatusToJSON(object: InvestmentOrderStatus): string {
  switch (object) {
    case InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_UNSPECIFIED:
      return "INVESTMENT_ORDER_STATUS_UNSPECIFIED";
    case InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_PENDING:
      return "INVESTMENT_ORDER_STATUS_PENDING";
    case InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_FILLED:
      return "INVESTMENT_ORDER_STATUS_FILLED";
    case InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_CANCELLED:
      return "INVESTMENT_ORDER_STATUS_CANCELLED";
    case InvestmentOrderStatus.INVESTMENT_ORDER_STATUS_FAILED:
      return "INVESTMENT_ORDER_STATUS_FAILED";
    case InvestmentOrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BankTransferStatus {
  BANK_TRANSFER_STATUS_UNSPECIFIED = 0,
  BANK_TRANSFER_STATUS_PENDING = 1,
  BANK_TRANSFER_STATUS_COMPLETED = 2,
  BANK_TRANSFER_STATUS_FAILED = 3,
  BANK_TRANSFER_STATUS_CANCELLED = 4,
  UNRECOGNIZED = -1,
}

export function bankTransferStatusFromJSON(object: any): BankTransferStatus {
  switch (object) {
    case 0:
    case "BANK_TRANSFER_STATUS_UNSPECIFIED":
      return BankTransferStatus.BANK_TRANSFER_STATUS_UNSPECIFIED;
    case 1:
    case "BANK_TRANSFER_STATUS_PENDING":
      return BankTransferStatus.BANK_TRANSFER_STATUS_PENDING;
    case 2:
    case "BANK_TRANSFER_STATUS_COMPLETED":
      return BankTransferStatus.BANK_TRANSFER_STATUS_COMPLETED;
    case 3:
    case "BANK_TRANSFER_STATUS_FAILED":
      return BankTransferStatus.BANK_TRANSFER_STATUS_FAILED;
    case 4:
    case "BANK_TRANSFER_STATUS_CANCELLED":
      return BankTransferStatus.BANK_TRANSFER_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BankTransferStatus.UNRECOGNIZED;
  }
}

export function bankTransferStatusToJSON(object: BankTransferStatus): string {
  switch (object) {
    case BankTransferStatus.BANK_TRANSFER_STATUS_UNSPECIFIED:
      return "BANK_TRANSFER_STATUS_UNSPECIFIED";
    case BankTransferStatus.BANK_TRANSFER_STATUS_PENDING:
      return "BANK_TRANSFER_STATUS_PENDING";
    case BankTransferStatus.BANK_TRANSFER_STATUS_COMPLETED:
      return "BANK_TRANSFER_STATUS_COMPLETED";
    case BankTransferStatus.BANK_TRANSFER_STATUS_FAILED:
      return "BANK_TRANSFER_STATUS_FAILED";
    case BankTransferStatus.BANK_TRANSFER_STATUS_CANCELLED:
      return "BANK_TRANSFER_STATUS_CANCELLED";
    case BankTransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ListingStatus {
  LISTING_STATUS_UNSPECIFIED = 0,
  LISTING_STATUS_ACTIVE = 1,
  LISTING_STATUS_SOLD = 2,
  LISTING_STATUS_CANCELLED = 3,
  UNRECOGNIZED = -1,
}

export function listingStatusFromJSON(object: any): ListingStatus {
  switch (object) {
    case 0:
    case "LISTING_STATUS_UNSPECIFIED":
      return ListingStatus.LISTING_STATUS_UNSPECIFIED;
    case 1:
    case "LISTING_STATUS_ACTIVE":
      return ListingStatus.LISTING_STATUS_ACTIVE;
    case 2:
    case "LISTING_STATUS_SOLD":
      return ListingStatus.LISTING_STATUS_SOLD;
    case 3:
    case "LISTING_STATUS_CANCELLED":
      return ListingStatus.LISTING_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListingStatus.UNRECOGNIZED;
  }
}

export function listingStatusToJSON(object: ListingStatus): string {
  switch (object) {
    case ListingStatus.LISTING_STATUS_UNSPECIFIED:
      return "LISTING_STATUS_UNSPECIFIED";
    case ListingStatus.LISTING_STATUS_ACTIVE:
      return "LISTING_STATUS_ACTIVE";
    case ListingStatus.LISTING_STATUS_SOLD:
      return "LISTING_STATUS_SOLD";
    case ListingStatus.LISTING_STATUS_CANCELLED:
      return "LISTING_STATUS_CANCELLED";
    case ListingStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MarketplaceOrderStatus {
  MARKETPLACE_ORDER_STATUS_UNSPECIFIED = 0,
  MARKETPLACE_ORDER_STATUS_PENDING = 1,
  MARKETPLACE_ORDER_STATUS_COMPLETED = 2,
  MARKETPLACE_ORDER_STATUS_CANCELLED = 3,
  UNRECOGNIZED = -1,
}

export function marketplaceOrderStatusFromJSON(object: any): MarketplaceOrderStatus {
  switch (object) {
    case 0:
    case "MARKETPLACE_ORDER_STATUS_UNSPECIFIED":
      return MarketplaceOrderStatus.MARKETPLACE_ORDER_STATUS_UNSPECIFIED;
    case 1:
    case "MARKETPLACE_ORDER_STATUS_PENDING":
      return MarketplaceOrderStatus.MARKETPLACE_ORDER_STATUS_PENDING;
    case 2:
    case "MARKETPLACE_ORDER_STATUS_COMPLETED":
      return MarketplaceOrderStatus.MARKETPLACE_ORDER_STATUS_COMPLETED;
    case 3:
    case "MARKETPLACE_ORDER_STATUS_CANCELLED":
      return MarketplaceOrderStatus.MARKETPLACE_ORDER_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MarketplaceOrderStatus.UNRECOGNIZED;
  }
}

export function marketplaceOrderStatusToJSON(object: MarketplaceOrderStatus): string {
  switch (object) {
    case MarketplaceOrderStatus.MARKETPLACE_ORDER_STATUS_UNSPECIFIED:
      return "MARKETPLACE_ORDER_STATUS_UNSPECIFIED";
    case MarketplaceOrderStatus.MARKETPLACE_ORDER_STATUS_PENDING:
      return "MARKETPLACE_ORDER_STATUS_PENDING";
    case MarketplaceOrderStatus.MARKETPLACE_ORDER_STATUS_COMPLETED:
      return "MARKETPLACE_ORDER_STATUS_COMPLETED";
    case MarketplaceOrderStatus.MARKETPLACE_ORDER_STATUS_CANCELLED:
      return "MARKETPLACE_ORDER_STATUS_CANCELLED";
    case MarketplaceOrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum OfferStatus {
  OFFER_STATUS_UNSPECIFIED = 0,
  OFFER_STATUS_PENDING = 1,
  OFFER_STATUS_ACCEPTED = 2,
  OFFER_STATUS_REJECTED = 3,
  OFFER_STATUS_CANCELLED = 4,
  UNRECOGNIZED = -1,
}

export function offerStatusFromJSON(object: any): OfferStatus {
  switch (object) {
    case 0:
    case "OFFER_STATUS_UNSPECIFIED":
      return OfferStatus.OFFER_STATUS_UNSPECIFIED;
    case 1:
    case "OFFER_STATUS_PENDING":
      return OfferStatus.OFFER_STATUS_PENDING;
    case 2:
    case "OFFER_STATUS_ACCEPTED":
      return OfferStatus.OFFER_STATUS_ACCEPTED;
    case 3:
    case "OFFER_STATUS_REJECTED":
      return OfferStatus.OFFER_STATUS_REJECTED;
    case 4:
    case "OFFER_STATUS_CANCELLED":
      return OfferStatus.OFFER_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OfferStatus.UNRECOGNIZED;
  }
}

export function offerStatusToJSON(object: OfferStatus): string {
  switch (object) {
    case OfferStatus.OFFER_STATUS_UNSPECIFIED:
      return "OFFER_STATUS_UNSPECIFIED";
    case OfferStatus.OFFER_STATUS_PENDING:
      return "OFFER_STATUS_PENDING";
    case OfferStatus.OFFER_STATUS_ACCEPTED:
      return "OFFER_STATUS_ACCEPTED";
    case OfferStatus.OFFER_STATUS_REJECTED:
      return "OFFER_STATUS_REJECTED";
    case OfferStatus.OFFER_STATUS_CANCELLED:
      return "OFFER_STATUS_CANCELLED";
    case OfferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExchangeOrderStatus {
  EXCHANGE_ORDER_STATUS_UNSPECIFIED = 0,
  EXCHANGE_ORDER_STATUS_PENDING = 1,
  EXCHANGE_ORDER_STATUS_FILLED = 2,
  EXCHANGE_ORDER_STATUS_CANCELLED = 3,
  EXCHANGE_ORDER_STATUS_FAILED = 4,
  UNRECOGNIZED = -1,
}

export function exchangeOrderStatusFromJSON(object: any): ExchangeOrderStatus {
  switch (object) {
    case 0:
    case "EXCHANGE_ORDER_STATUS_UNSPECIFIED":
      return ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_UNSPECIFIED;
    case 1:
    case "EXCHANGE_ORDER_STATUS_PENDING":
      return ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_PENDING;
    case 2:
    case "EXCHANGE_ORDER_STATUS_FILLED":
      return ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_FILLED;
    case 3:
    case "EXCHANGE_ORDER_STATUS_CANCELLED":
      return ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_CANCELLED;
    case 4:
    case "EXCHANGE_ORDER_STATUS_FAILED":
      return ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExchangeOrderStatus.UNRECOGNIZED;
  }
}

export function exchangeOrderStatusToJSON(object: ExchangeOrderStatus): string {
  switch (object) {
    case ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_UNSPECIFIED:
      return "EXCHANGE_ORDER_STATUS_UNSPECIFIED";
    case ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_PENDING:
      return "EXCHANGE_ORDER_STATUS_PENDING";
    case ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_FILLED:
      return "EXCHANGE_ORDER_STATUS_FILLED";
    case ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_CANCELLED:
      return "EXCHANGE_ORDER_STATUS_CANCELLED";
    case ExchangeOrderStatus.EXCHANGE_ORDER_STATUS_FAILED:
      return "EXCHANGE_ORDER_STATUS_FAILED";
    case ExchangeOrderStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** --- Quotes --- */
export interface CreateQuoteRequest {
  userId: string;
  productId: string;
  amount: number;
  currency: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface CreateQuoteResponse {
  quote?: Quote | undefined;
}

export interface GetQuoteRequest {
  quoteId: string;
  campaignId: string;
}

export interface GetQuoteResponse {
  quote?: Quote | undefined;
}

export interface ListQuotesRequest {
  userId: string;
  page: number;
  pageSize: number;
  campaignId: string;
}

export interface ListQuotesResponse {
  quotes: Quote[];
  total: number;
}

export interface Quote {
  quoteId: string;
  userId: string;
  productId: string;
  amount: number;
  currency: string;
  status: QuoteStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  campaignId: string;
}

/** --- Orders --- */
export interface CreateOrderRequest {
  userId: string;
  items: OrderItem[];
  currency: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface CreateOrderResponse {
  order?: Order | undefined;
}

export interface GetOrderRequest {
  orderId: string;
  campaignId: string;
}

export interface GetOrderResponse {
  order?: Order | undefined;
}

export interface ListOrdersRequest {
  userId: string;
  page: number;
  pageSize: number;
  campaignId: string;
}

export interface ListOrdersResponse {
  orders: Order[];
  total: number;
}

export interface UpdateOrderStatusRequest {
  orderId: string;
  status: OrderStatus;
  campaignId: string;
}

export interface UpdateOrderStatusResponse {
  order?: Order | undefined;
}

export interface Order {
  orderId: string;
  userId: string;
  items: OrderItem[];
  total: number;
  currency: string;
  status: OrderStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  campaignId: string;
}

export interface OrderItem {
  productId: string;
  quantity: number;
  price: number;
  metadata?: Metadata | undefined;
}

/** --- Payments --- */
export interface InitiatePaymentRequest {
  orderId: string;
  userId: string;
  amount: number;
  currency: string;
  method: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface InitiatePaymentResponse {
  payment?: Payment | undefined;
}

export interface ConfirmPaymentRequest {
  paymentId: string;
  userId: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface ConfirmPaymentResponse {
  payment?: Payment | undefined;
}

export interface RefundPaymentRequest {
  paymentId: string;
  userId: string;
  amount: number;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface RefundPaymentResponse {
  payment?: Payment | undefined;
}

export interface Payment {
  paymentId: string;
  orderId: string;
  userId: string;
  amount: number;
  currency: string;
  method: string;
  status: PaymentStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  campaignId: string;
}

/** --- Transactions --- */
export interface GetTransactionRequest {
  transactionId: string;
  campaignId: string;
}

export interface GetTransactionResponse {
  transaction?: Transaction | undefined;
}

export interface ListTransactionsRequest {
  userId: string;
  page: number;
  pageSize: number;
  campaignId: string;
}

export interface ListTransactionsResponse {
  transactions: Transaction[];
  total: number;
}

export interface Transaction {
  transactionId: string;
  paymentId: string;
  userId: string;
  type: TransactionType;
  amount: number;
  currency: string;
  status: TransactionStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  campaignId: string;
}

/** --- Balances --- */
export interface GetBalanceRequest {
  userId: string;
  currency: string;
  campaignId: string;
}

export interface GetBalanceResponse {
  balance?: Balance | undefined;
}

export interface ListBalancesRequest {
  userId: string;
  campaignId: string;
}

export interface ListBalancesResponse {
  balances: Balance[];
}

export interface Balance {
  userId: string;
  currency: string;
  amount: number;
  updatedAt?:
    | Date
    | undefined;
  /**
   * Robust, extensible metadata for balances
   * (see docs/amadeus/amadeus_context.md)
   */
  metadata?: Metadata | undefined;
  campaignId: string;
}

/** --- Events (Analytics/Audit) --- */
export interface ListEventsRequest {
  entityId: string;
  entityType: string;
  page: number;
  pageSize: number;
  campaignId: string;
}

export interface ListEventsResponse {
  events: CommerceEvent[];
  total: number;
}

export interface CommerceEvent {
  eventId: string;
  entityId: string;
  entityType: string;
  eventType: string;
  payload?: { [key: string]: any } | undefined;
  createdAt?:
    | Date
    | undefined;
  /**
   * Robust, extensible metadata for analytics/audit
   * (see docs/amadeus/amadeus_context.md)
   */
  metadata?: Metadata | undefined;
  campaignId: string;
}

/** --- Shared Primitives --- */
export interface Party {
  partyId: string;
  /** USER, BUSINESS, BANK, EXCHANGE, etc. */
  type: string;
  name: string;
  metadata?: Metadata | undefined;
}

export interface Account {
  accountId: string;
  partyId: string;
  /** BANK, INVESTMENT, WALLET, etc. */
  type: string;
  currency: string;
  balance: number;
  metadata?: Metadata | undefined;
}

/** --- Investment --- */
export interface InvestmentAccount {
  accountId: string;
  ownerId: string;
  /** BROKERAGE, RETIREMENT, etc. */
  type: string;
  currency: string;
  balance: number;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  campaignId: string;
}

export interface InvestmentOrder {
  orderId: string;
  accountId: string;
  assetId: string;
  quantity: number;
  price: number;
  /** MARKET, LIMIT, etc. */
  orderType: string;
  status: InvestmentOrderStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  campaignId: string;
}

export interface Asset {
  assetId: string;
  symbol: string;
  name: string;
  /** STOCK, BOND, FUND, CRYPTO, etc. */
  type: string;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
}

export interface Portfolio {
  portfolioId: string;
  accountId: string;
  positions: AssetPosition[];
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  campaignId: string;
}

export interface AssetPosition {
  assetId: string;
  quantity: number;
  averagePrice: number;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
}

/** --- Banking --- */
export interface BankAccount {
  accountId: string;
  userId: string;
  iban: string;
  bic: string;
  currency: string;
  balance: number;
  metadata?: Metadata | undefined;
}

export interface BankTransfer {
  transferId: string;
  fromAccountId: string;
  toAccountId: string;
  amount: number;
  currency: string;
  status: BankTransferStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
}

export interface BankStatement {
  accountId: string;
  transactions: Transaction[];
  metadata?: Metadata | undefined;
}

/** --- Marketplace --- */
export interface MarketplaceListing {
  listingId: string;
  sellerId: string;
  productId: string;
  price: number;
  currency: string;
  status: ListingStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
}

export interface MarketplaceOrder {
  orderId: string;
  listingId: string;
  buyerId: string;
  price: number;
  currency: string;
  status: MarketplaceOrderStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
}

export interface MarketplaceOffer {
  offerId: string;
  listingId: string;
  buyerId: string;
  offerPrice: number;
  currency: string;
  status: OfferStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
}

/** --- Exchange --- */
export interface ExchangeOrder {
  orderId: string;
  accountId: string;
  /** e.g., BTC/USD */
  pair: string;
  amount: number;
  price: number;
  /** MARKET, LIMIT */
  orderType: string;
  status: ExchangeOrderStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
}

export interface ExchangePair {
  pairId: string;
  baseAsset: string;
  quoteAsset: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface ExchangeRate {
  pairId: string;
  rate: number;
  timestamp?: Date | undefined;
  metadata?: Metadata | undefined;
  campaignId: string;
}

/** Investment */
export interface CreateInvestmentAccountRequest {
  ownerId: string;
  type: string;
  currency: string;
  balance: number;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface CreateInvestmentAccountResponse {
  account?: InvestmentAccount | undefined;
}

export interface GetInvestmentAccountRequest {
  accountId: string;
  campaignId: string;
}

export interface GetInvestmentAccountResponse {
  account?: InvestmentAccount | undefined;
}

export interface PlaceInvestmentOrderRequest {
  accountId: string;
  assetId: string;
  quantity: number;
  price: number;
  orderType: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface PlaceInvestmentOrderResponse {
  order?: InvestmentOrder | undefined;
}

export interface GetPortfolioRequest {
  portfolioId: string;
  campaignId: string;
}

export interface GetPortfolioResponse {
  portfolio?: Portfolio | undefined;
}

export interface ListPortfoliosRequest {
  accountId: string;
  campaignId: string;
}

export interface ListPortfoliosResponse {
  portfolios: Portfolio[];
}

export interface ListAssetsRequest {
  userId: string;
  page: number;
  pageSize: number;
  campaignId: string;
}

export interface ListAssetsResponse {
  assets: Asset[];
  total: number;
}

/** Banking */
export interface CreateBankAccountRequest {
  userId: string;
  iban: string;
  bic: string;
  currency: string;
  balance: number;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface CreateBankAccountResponse {
  account?: BankAccount | undefined;
}

export interface InitiateBankTransferRequest {
  fromAccountId: string;
  toAccountId: string;
  amount: number;
  currency: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface InitiateBankTransferResponse {
  transfer?: BankTransfer | undefined;
}

export interface GetBankStatementRequest {
  accountId: string;
  campaignId: string;
}

export interface GetBankStatementResponse {
  statement?: BankStatement | undefined;
}

/** Marketplace */
export interface CreateListingRequest {
  sellerId: string;
  productId: string;
  price: number;
  currency: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface CreateListingResponse {
  listing?: MarketplaceListing | undefined;
}

export interface PlaceMarketplaceOrderRequest {
  listingId: string;
  buyerId: string;
  price: number;
  currency: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface PlaceMarketplaceOrderResponse {
  order?: MarketplaceOrder | undefined;
}

export interface MakeOfferRequest {
  listingId: string;
  buyerId: string;
  offerPrice: number;
  currency: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface MakeOfferResponse {
  offer?: MarketplaceOffer | undefined;
}

export interface ListListingsRequest {
  userId: string;
  page: number;
  pageSize: number;
  campaignId: string;
}

export interface ListListingsResponse {
  listings: MarketplaceListing[];
  total: number;
}

/** Exchange */
export interface PlaceExchangeOrderRequest {
  accountId: string;
  pair: string;
  amount: number;
  price: number;
  orderType: string;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface PlaceExchangeOrderResponse {
  order?: ExchangeOrder | undefined;
}

export interface GetExchangeRateRequest {
  pairId: string;
  campaignId: string;
}

export interface GetExchangeRateResponse {
  rate?: ExchangeRate | undefined;
}

export interface ListExchangePairsRequest {
  userId: string;
  page: number;
  pageSize: number;
  campaignId: string;
}

export interface ListExchangePairsResponse {
  pairs: ExchangePair[];
  total: number;
}

export interface CreateExchangePairRequest {
  pairId: string;
  baseAsset: string;
  quoteAsset: string;
  metadata?: Metadata | undefined;
}

export interface CreateExchangePairResponse {
  pair?: ExchangePair | undefined;
}

export interface CreateExchangeRateRequest {
  pairId: string;
  rate: number;
  timestamp?: Date | undefined;
  metadata?: Metadata | undefined;
  campaignId: string;
}

export interface CreateExchangeRateResponse {
  rate?: ExchangeRate | undefined;
}

function createBaseCreateQuoteRequest(): CreateQuoteRequest {
  return { userId: "", productId: "", amount: 0, currency: "", metadata: undefined, campaignId: "0" };
}

export const CreateQuoteRequest: MessageFns<CreateQuoteRequest> = {
  encode(message: CreateQuoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.amount !== 0) {
      writer.uint32(25).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateQuoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateQuoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateQuoteRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: CreateQuoteRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateQuoteRequest>, I>>(base?: I): CreateQuoteRequest {
    return CreateQuoteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateQuoteRequest>, I>>(object: I): CreateQuoteRequest {
    const message = createBaseCreateQuoteRequest();
    message.userId = object.userId ?? "";
    message.productId = object.productId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCreateQuoteResponse(): CreateQuoteResponse {
  return { quote: undefined };
}

export const CreateQuoteResponse: MessageFns<CreateQuoteResponse> = {
  encode(message: CreateQuoteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quote !== undefined) {
      Quote.encode(message.quote, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateQuoteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateQuoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quote = Quote.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateQuoteResponse {
    return { quote: isSet(object.quote) ? Quote.fromJSON(object.quote) : undefined };
  },

  toJSON(message: CreateQuoteResponse): unknown {
    const obj: any = {};
    if (message.quote !== undefined) {
      obj.quote = Quote.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateQuoteResponse>, I>>(base?: I): CreateQuoteResponse {
    return CreateQuoteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateQuoteResponse>, I>>(object: I): CreateQuoteResponse {
    const message = createBaseCreateQuoteResponse();
    message.quote = (object.quote !== undefined && object.quote !== null) ? Quote.fromPartial(object.quote) : undefined;
    return message;
  },
};

function createBaseGetQuoteRequest(): GetQuoteRequest {
  return { quoteId: "", campaignId: "0" };
}

export const GetQuoteRequest: MessageFns<GetQuoteRequest> = {
  encode(message: GetQuoteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quoteId !== "") {
      writer.uint32(10).string(message.quoteId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuoteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuoteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quoteId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuoteRequest {
    return {
      quoteId: isSet(object.quoteId) ? globalThis.String(object.quoteId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetQuoteRequest): unknown {
    const obj: any = {};
    if (message.quoteId !== "") {
      obj.quoteId = message.quoteId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuoteRequest>, I>>(base?: I): GetQuoteRequest {
    return GetQuoteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuoteRequest>, I>>(object: I): GetQuoteRequest {
    const message = createBaseGetQuoteRequest();
    message.quoteId = object.quoteId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetQuoteResponse(): GetQuoteResponse {
  return { quote: undefined };
}

export const GetQuoteResponse: MessageFns<GetQuoteResponse> = {
  encode(message: GetQuoteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quote !== undefined) {
      Quote.encode(message.quote, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuoteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuoteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quote = Quote.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuoteResponse {
    return { quote: isSet(object.quote) ? Quote.fromJSON(object.quote) : undefined };
  },

  toJSON(message: GetQuoteResponse): unknown {
    const obj: any = {};
    if (message.quote !== undefined) {
      obj.quote = Quote.toJSON(message.quote);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuoteResponse>, I>>(base?: I): GetQuoteResponse {
    return GetQuoteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuoteResponse>, I>>(object: I): GetQuoteResponse {
    const message = createBaseGetQuoteResponse();
    message.quote = (object.quote !== undefined && object.quote !== null) ? Quote.fromPartial(object.quote) : undefined;
    return message;
  },
};

function createBaseListQuotesRequest(): ListQuotesRequest {
  return { userId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const ListQuotesRequest: MessageFns<ListQuotesRequest> = {
  encode(message: ListQuotesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQuotesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQuotesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQuotesRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListQuotesRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListQuotesRequest>, I>>(base?: I): ListQuotesRequest {
    return ListQuotesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListQuotesRequest>, I>>(object: I): ListQuotesRequest {
    const message = createBaseListQuotesRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListQuotesResponse(): ListQuotesResponse {
  return { quotes: [], total: 0 };
}

export const ListQuotesResponse: MessageFns<ListQuotesResponse> = {
  encode(message: ListQuotesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.quotes) {
      Quote.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQuotesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQuotesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quotes.push(Quote.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQuotesResponse {
    return {
      quotes: globalThis.Array.isArray(object?.quotes) ? object.quotes.map((e: any) => Quote.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListQuotesResponse): unknown {
    const obj: any = {};
    if (message.quotes?.length) {
      obj.quotes = message.quotes.map((e) => Quote.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListQuotesResponse>, I>>(base?: I): ListQuotesResponse {
    return ListQuotesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListQuotesResponse>, I>>(object: I): ListQuotesResponse {
    const message = createBaseListQuotesResponse();
    message.quotes = object.quotes?.map((e) => Quote.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseQuote(): Quote {
  return {
    quoteId: "",
    userId: "",
    productId: "",
    amount: 0,
    currency: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    campaignId: "0",
  };
}

export const Quote: MessageFns<Quote> = {
  encode(message: Quote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quoteId !== "") {
      writer.uint32(10).string(message.quoteId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.productId !== "") {
      writer.uint32(26).string(message.productId);
    }
    if (message.amount !== 0) {
      writer.uint32(33).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(74).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(80).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Quote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.quoteId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Quote {
    return {
      quoteId: isSet(object.quoteId) ? globalThis.String(object.quoteId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? quoteStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Quote): unknown {
    const obj: any = {};
    if (message.quoteId !== "") {
      obj.quoteId = message.quoteId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== 0) {
      obj.status = quoteStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Quote>, I>>(base?: I): Quote {
    return Quote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Quote>, I>>(object: I): Quote {
    const message = createBaseQuote();
    message.quoteId = object.quoteId ?? "";
    message.userId = object.userId ?? "";
    message.productId = object.productId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCreateOrderRequest(): CreateOrderRequest {
  return { userId: "", items: [], currency: "", metadata: undefined, campaignId: "0" };
}

export const CreateOrderRequest: MessageFns<CreateOrderRequest> = {
  encode(message: CreateOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.items) {
      OrderItem.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => OrderItem.fromJSON(e)) : [],
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: CreateOrderRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => OrderItem.toJSON(e));
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(base?: I): CreateOrderRequest {
    return CreateOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderRequest>, I>>(object: I): CreateOrderRequest {
    const message = createBaseCreateOrderRequest();
    message.userId = object.userId ?? "";
    message.items = object.items?.map((e) => OrderItem.fromPartial(e)) || [];
    message.currency = object.currency ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCreateOrderResponse(): CreateOrderResponse {
  return { order: undefined };
}

export const CreateOrderResponse: MessageFns<CreateOrderResponse> = {
  encode(message: CreateOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrderResponse {
    return { order: isSet(object.order) ? Order.fromJSON(object.order) : undefined };
  },

  toJSON(message: CreateOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(base?: I): CreateOrderResponse {
    return CreateOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateOrderResponse>, I>>(object: I): CreateOrderResponse {
    const message = createBaseCreateOrderResponse();
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    return message;
  },
};

function createBaseGetOrderRequest(): GetOrderRequest {
  return { orderId: "", campaignId: "0" };
}

export const GetOrderRequest: MessageFns<GetOrderRequest> = {
  encode(message: GetOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetOrderRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderRequest>, I>>(base?: I): GetOrderRequest {
    return GetOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderRequest>, I>>(object: I): GetOrderRequest {
    const message = createBaseGetOrderRequest();
    message.orderId = object.orderId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetOrderResponse(): GetOrderResponse {
  return { order: undefined };
}

export const GetOrderResponse: MessageFns<GetOrderResponse> = {
  encode(message: GetOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrderResponse {
    return { order: isSet(object.order) ? Order.fromJSON(object.order) : undefined };
  },

  toJSON(message: GetOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrderResponse>, I>>(base?: I): GetOrderResponse {
    return GetOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrderResponse>, I>>(object: I): GetOrderResponse {
    const message = createBaseGetOrderResponse();
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    return message;
  },
};

function createBaseListOrdersRequest(): ListOrdersRequest {
  return { userId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const ListOrdersRequest: MessageFns<ListOrdersRequest> = {
  encode(message: ListOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrdersRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListOrdersRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOrdersRequest>, I>>(base?: I): ListOrdersRequest {
    return ListOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOrdersRequest>, I>>(object: I): ListOrdersRequest {
    const message = createBaseListOrdersRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListOrdersResponse(): ListOrdersResponse {
  return { orders: [], total: 0 };
}

export const ListOrdersResponse: MessageFns<ListOrdersResponse> = {
  encode(message: ListOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      Order.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => Order.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => Order.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListOrdersResponse>, I>>(base?: I): ListOrdersResponse {
    return ListOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListOrdersResponse>, I>>(object: I): ListOrdersResponse {
    const message = createBaseListOrdersResponse();
    message.orders = object.orders?.map((e) => Order.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseUpdateOrderStatusRequest(): UpdateOrderStatusRequest {
  return { orderId: "", status: 0, campaignId: "0" };
}

export const UpdateOrderStatusRequest: MessageFns<UpdateOrderStatusRequest> = {
  encode(message: UpdateOrderStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.campaignId !== "0") {
      writer.uint32(24).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrderStatusRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: UpdateOrderStatusRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrderStatusRequest>, I>>(base?: I): UpdateOrderStatusRequest {
    return UpdateOrderStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOrderStatusRequest>, I>>(object: I): UpdateOrderStatusRequest {
    const message = createBaseUpdateOrderStatusRequest();
    message.orderId = object.orderId ?? "";
    message.status = object.status ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseUpdateOrderStatusResponse(): UpdateOrderStatusResponse {
  return { order: undefined };
}

export const UpdateOrderStatusResponse: MessageFns<UpdateOrderStatusResponse> = {
  encode(message: UpdateOrderStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrderStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrderStatusResponse {
    return { order: isSet(object.order) ? Order.fromJSON(object.order) : undefined };
  },

  toJSON(message: UpdateOrderStatusResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateOrderStatusResponse>, I>>(base?: I): UpdateOrderStatusResponse {
    return UpdateOrderStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateOrderStatusResponse>, I>>(object: I): UpdateOrderStatusResponse {
    const message = createBaseUpdateOrderStatusResponse();
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    return message;
  },
};

function createBaseOrder(): Order {
  return {
    orderId: "",
    userId: "",
    items: [],
    total: 0,
    currency: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    campaignId: "0",
  };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    for (const v of message.items) {
      OrderItem.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(33).double(message.total);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(74).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(80).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.total = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => OrderItem.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? orderStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => OrderItem.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = message.total;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== 0) {
      obj.status = orderStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Order>, I>>(base?: I): Order {
    return Order.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Order>, I>>(object: I): Order {
    const message = createBaseOrder();
    message.orderId = object.orderId ?? "";
    message.userId = object.userId ?? "";
    message.items = object.items?.map((e) => OrderItem.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseOrderItem(): OrderItem {
  return { productId: "", quantity: 0, price: 0, metadata: undefined };
}

export const OrderItem: MessageFns<OrderItem> = {
  encode(message: OrderItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(25).double(message.price);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderItem {
    return {
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: OrderItem): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderItem>, I>>(base?: I): OrderItem {
    return OrderItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderItem>, I>>(object: I): OrderItem {
    const message = createBaseOrderItem();
    message.productId = object.productId ?? "";
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseInitiatePaymentRequest(): InitiatePaymentRequest {
  return { orderId: "", userId: "", amount: 0, currency: "", method: "", metadata: undefined, campaignId: "0" };
}

export const InitiatePaymentRequest: MessageFns<InitiatePaymentRequest> = {
  encode(message: InitiatePaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.amount !== 0) {
      writer.uint32(25).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.method !== "") {
      writer.uint32(42).string(message.method);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(56).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiatePaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiatePaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiatePaymentRequest {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: InitiatePaymentRequest): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiatePaymentRequest>, I>>(base?: I): InitiatePaymentRequest {
    return InitiatePaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiatePaymentRequest>, I>>(object: I): InitiatePaymentRequest {
    const message = createBaseInitiatePaymentRequest();
    message.orderId = object.orderId ?? "";
    message.userId = object.userId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.method = object.method ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseInitiatePaymentResponse(): InitiatePaymentResponse {
  return { payment: undefined };
}

export const InitiatePaymentResponse: MessageFns<InitiatePaymentResponse> = {
  encode(message: InitiatePaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiatePaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiatePaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiatePaymentResponse {
    return { payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined };
  },

  toJSON(message: InitiatePaymentResponse): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiatePaymentResponse>, I>>(base?: I): InitiatePaymentResponse {
    return InitiatePaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiatePaymentResponse>, I>>(object: I): InitiatePaymentResponse {
    const message = createBaseInitiatePaymentResponse();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

function createBaseConfirmPaymentRequest(): ConfirmPaymentRequest {
  return { paymentId: "", userId: "", metadata: undefined, campaignId: "0" };
}

export const ConfirmPaymentRequest: MessageFns<ConfirmPaymentRequest> = {
  encode(message: ConfirmPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfirmPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmPaymentRequest {
    return {
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ConfirmPaymentRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmPaymentRequest>, I>>(base?: I): ConfirmPaymentRequest {
    return ConfirmPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmPaymentRequest>, I>>(object: I): ConfirmPaymentRequest {
    const message = createBaseConfirmPaymentRequest();
    message.paymentId = object.paymentId ?? "";
    message.userId = object.userId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseConfirmPaymentResponse(): ConfirmPaymentResponse {
  return { payment: undefined };
}

export const ConfirmPaymentResponse: MessageFns<ConfirmPaymentResponse> = {
  encode(message: ConfirmPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfirmPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfirmPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfirmPaymentResponse {
    return { payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined };
  },

  toJSON(message: ConfirmPaymentResponse): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfirmPaymentResponse>, I>>(base?: I): ConfirmPaymentResponse {
    return ConfirmPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfirmPaymentResponse>, I>>(object: I): ConfirmPaymentResponse {
    const message = createBaseConfirmPaymentResponse();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

function createBaseRefundPaymentRequest(): RefundPaymentRequest {
  return { paymentId: "", userId: "", amount: 0, metadata: undefined, campaignId: "0" };
}

export const RefundPaymentRequest: MessageFns<RefundPaymentRequest> = {
  encode(message: RefundPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.amount !== 0) {
      writer.uint32(25).double(message.amount);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundPaymentRequest {
    return {
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: RefundPaymentRequest): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundPaymentRequest>, I>>(base?: I): RefundPaymentRequest {
    return RefundPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundPaymentRequest>, I>>(object: I): RefundPaymentRequest {
    const message = createBaseRefundPaymentRequest();
    message.paymentId = object.paymentId ?? "";
    message.userId = object.userId ?? "";
    message.amount = object.amount ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseRefundPaymentResponse(): RefundPaymentResponse {
  return { payment: undefined };
}

export const RefundPaymentResponse: MessageFns<RefundPaymentResponse> = {
  encode(message: RefundPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundPaymentResponse {
    return { payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined };
  },

  toJSON(message: RefundPaymentResponse): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundPaymentResponse>, I>>(base?: I): RefundPaymentResponse {
    return RefundPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundPaymentResponse>, I>>(object: I): RefundPaymentResponse {
    const message = createBaseRefundPaymentResponse();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

function createBasePayment(): Payment {
  return {
    paymentId: "",
    orderId: "",
    userId: "",
    amount: 0,
    currency: "",
    method: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    campaignId: "0",
  };
}

export const Payment: MessageFns<Payment> = {
  encode(message: Payment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentId !== "") {
      writer.uint32(10).string(message.paymentId);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.amount !== 0) {
      writer.uint32(33).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.method !== "") {
      writer.uint32(50).string(message.method);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(82).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(88).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Payment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.method = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payment {
    return {
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      status: isSet(object.status) ? paymentStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Payment): unknown {
    const obj: any = {};
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.status !== 0) {
      obj.status = paymentStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payment>, I>>(base?: I): Payment {
    return Payment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payment>, I>>(object: I): Payment {
    const message = createBasePayment();
    message.paymentId = object.paymentId ?? "";
    message.orderId = object.orderId ?? "";
    message.userId = object.userId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.method = object.method ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetTransactionRequest(): GetTransactionRequest {
  return { transactionId: "", campaignId: "0" };
}

export const GetTransactionRequest: MessageFns<GetTransactionRequest> = {
  encode(message: GetTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== "") {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionRequest {
    return {
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetTransactionRequest): unknown {
    const obj: any = {};
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionRequest>, I>>(base?: I): GetTransactionRequest {
    return GetTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionRequest>, I>>(object: I): GetTransactionRequest {
    const message = createBaseGetTransactionRequest();
    message.transactionId = object.transactionId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetTransactionResponse(): GetTransactionResponse {
  return { transaction: undefined };
}

export const GetTransactionResponse: MessageFns<GetTransactionResponse> = {
  encode(message: GetTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      Transaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transaction = Transaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTransactionResponse {
    return { transaction: isSet(object.transaction) ? Transaction.fromJSON(object.transaction) : undefined };
  },

  toJSON(message: GetTransactionResponse): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = Transaction.toJSON(message.transaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTransactionResponse>, I>>(base?: I): GetTransactionResponse {
    return GetTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTransactionResponse>, I>>(object: I): GetTransactionResponse {
    const message = createBaseGetTransactionResponse();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? Transaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseListTransactionsRequest(): ListTransactionsRequest {
  return { userId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const ListTransactionsRequest: MessageFns<ListTransactionsRequest> = {
  encode(message: ListTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTransactionsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListTransactionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTransactionsRequest>, I>>(base?: I): ListTransactionsRequest {
    return ListTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTransactionsRequest>, I>>(object: I): ListTransactionsRequest {
    const message = createBaseListTransactionsRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListTransactionsResponse(): ListTransactionsResponse {
  return { transactions: [], total: 0 };
}

export const ListTransactionsResponse: MessageFns<ListTransactionsResponse> = {
  encode(message: ListTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTransactionsResponse>, I>>(base?: I): ListTransactionsResponse {
    return ListTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTransactionsResponse>, I>>(object: I): ListTransactionsResponse {
    const message = createBaseListTransactionsResponse();
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    transactionId: "",
    paymentId: "",
    userId: "",
    type: 0,
    amount: 0,
    currency: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    campaignId: "0",
  };
}

export const Transaction: MessageFns<Transaction> = {
  encode(message: Transaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== "") {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.paymentId !== "") {
      writer.uint32(18).string(message.paymentId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.amount !== 0) {
      writer.uint32(41).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(82).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(88).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      paymentId: isSet(object.paymentId) ? globalThis.String(object.paymentId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      type: isSet(object.type) ? transactionTypeFromJSON(object.type) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? transactionStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.paymentId !== "") {
      obj.paymentId = message.paymentId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.type !== 0) {
      obj.type = transactionTypeToJSON(message.type);
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== 0) {
      obj.status = transactionStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Transaction>, I>>(base?: I): Transaction {
    return Transaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Transaction>, I>>(object: I): Transaction {
    const message = createBaseTransaction();
    message.transactionId = object.transactionId ?? "";
    message.paymentId = object.paymentId ?? "";
    message.userId = object.userId ?? "";
    message.type = object.type ?? 0;
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetBalanceRequest(): GetBalanceRequest {
  return { userId: "", currency: "", campaignId: "0" };
}

export const GetBalanceRequest: MessageFns<GetBalanceRequest> = {
  encode(message: GetBalanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.currency !== "") {
      writer.uint32(18).string(message.currency);
    }
    if (message.campaignId !== "0") {
      writer.uint32(24).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalanceRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetBalanceRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBalanceRequest>, I>>(base?: I): GetBalanceRequest {
    return GetBalanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBalanceRequest>, I>>(object: I): GetBalanceRequest {
    const message = createBaseGetBalanceRequest();
    message.userId = object.userId ?? "";
    message.currency = object.currency ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetBalanceResponse(): GetBalanceResponse {
  return { balance: undefined };
}

export const GetBalanceResponse: MessageFns<GetBalanceResponse> = {
  encode(message: GetBalanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== undefined) {
      Balance.encode(message.balance, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBalanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balance = Balance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalanceResponse {
    return { balance: isSet(object.balance) ? Balance.fromJSON(object.balance) : undefined };
  },

  toJSON(message: GetBalanceResponse): unknown {
    const obj: any = {};
    if (message.balance !== undefined) {
      obj.balance = Balance.toJSON(message.balance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBalanceResponse>, I>>(base?: I): GetBalanceResponse {
    return GetBalanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBalanceResponse>, I>>(object: I): GetBalanceResponse {
    const message = createBaseGetBalanceResponse();
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Balance.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseListBalancesRequest(): ListBalancesRequest {
  return { userId: "", campaignId: "0" };
}

export const ListBalancesRequest: MessageFns<ListBalancesRequest> = {
  encode(message: ListBalancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBalancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBalancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBalancesRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListBalancesRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBalancesRequest>, I>>(base?: I): ListBalancesRequest {
    return ListBalancesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBalancesRequest>, I>>(object: I): ListBalancesRequest {
    const message = createBaseListBalancesRequest();
    message.userId = object.userId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListBalancesResponse(): ListBalancesResponse {
  return { balances: [] };
}

export const ListBalancesResponse: MessageFns<ListBalancesResponse> = {
  encode(message: ListBalancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.balances) {
      Balance.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBalancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBalancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balances.push(Balance.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBalancesResponse {
    return {
      balances: globalThis.Array.isArray(object?.balances) ? object.balances.map((e: any) => Balance.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListBalancesResponse): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => Balance.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListBalancesResponse>, I>>(base?: I): ListBalancesResponse {
    return ListBalancesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListBalancesResponse>, I>>(object: I): ListBalancesResponse {
    const message = createBaseListBalancesResponse();
    message.balances = object.balances?.map((e) => Balance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBalance(): Balance {
  return { userId: "", currency: "", amount: 0, updatedAt: undefined, metadata: undefined, campaignId: "0" };
}

export const Balance: MessageFns<Balance> = {
  encode(message: Balance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.currency !== "") {
      writer.uint32(18).string(message.currency);
    }
    if (message.amount !== 0) {
      writer.uint32(25).double(message.amount);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(34).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Balance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Balance {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Balance): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Balance>, I>>(base?: I): Balance {
    return Balance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Balance>, I>>(object: I): Balance {
    const message = createBaseBalance();
    message.userId = object.userId ?? "";
    message.currency = object.currency ?? "";
    message.amount = object.amount ?? 0;
    message.updatedAt = object.updatedAt ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListEventsRequest(): ListEventsRequest {
  return { entityId: "", entityType: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const ListEventsRequest: MessageFns<ListEventsRequest> = {
  encode(message: ListEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityId !== "") {
      writer.uint32(10).string(message.entityId);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsRequest {
    return {
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListEventsRequest): unknown {
    const obj: any = {};
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListEventsRequest>, I>>(base?: I): ListEventsRequest {
    return ListEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListEventsRequest>, I>>(object: I): ListEventsRequest {
    const message = createBaseListEventsRequest();
    message.entityId = object.entityId ?? "";
    message.entityType = object.entityType ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListEventsResponse(): ListEventsResponse {
  return { events: [], total: 0 };
}

export const ListEventsResponse: MessageFns<ListEventsResponse> = {
  encode(message: ListEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      CommerceEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(CommerceEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => CommerceEvent.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => CommerceEvent.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListEventsResponse>, I>>(base?: I): ListEventsResponse {
    return ListEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListEventsResponse>, I>>(object: I): ListEventsResponse {
    const message = createBaseListEventsResponse();
    message.events = object.events?.map((e) => CommerceEvent.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseCommerceEvent(): CommerceEvent {
  return {
    eventId: "",
    entityId: "",
    entityType: "",
    eventType: "",
    payload: undefined,
    createdAt: undefined,
    metadata: undefined,
    campaignId: "0",
  };
}

export const CommerceEvent: MessageFns<CommerceEvent> = {
  encode(message: CommerceEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.entityId !== "") {
      writer.uint32(18).string(message.entityId);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.eventType !== "") {
      writer.uint32(34).string(message.eventType);
    }
    if (message.payload !== undefined) {
      Struct.encode(Struct.wrap(message.payload), writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(64).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommerceEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommerceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommerceEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      payload: isObject(object.payload) ? object.payload : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: CommerceEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommerceEvent>, I>>(base?: I): CommerceEvent {
    return CommerceEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommerceEvent>, I>>(object: I): CommerceEvent {
    const message = createBaseCommerceEvent();
    message.eventId = object.eventId ?? "";
    message.entityId = object.entityId ?? "";
    message.entityType = object.entityType ?? "";
    message.eventType = object.eventType ?? "";
    message.payload = object.payload ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseParty(): Party {
  return { partyId: "", type: "", name: "", metadata: undefined };
}

export const Party: MessageFns<Party> = {
  encode(message: Party, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partyId !== "") {
      writer.uint32(10).string(message.partyId);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Party {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.partyId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Party {
    return {
      partyId: isSet(object.partyId) ? globalThis.String(object.partyId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Party): unknown {
    const obj: any = {};
    if (message.partyId !== "") {
      obj.partyId = message.partyId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Party>, I>>(base?: I): Party {
    return Party.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Party>, I>>(object: I): Party {
    const message = createBaseParty();
    message.partyId = object.partyId ?? "";
    message.type = object.type ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAccount(): Account {
  return { accountId: "", partyId: "", type: "", currency: "", balance: 0, metadata: undefined };
}

export const Account: MessageFns<Account> = {
  encode(message: Account, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.partyId !== "") {
      writer.uint32(18).string(message.partyId);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.balance !== 0) {
      writer.uint32(41).double(message.balance);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Account {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partyId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.balance = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Account {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      partyId: isSet(object.partyId) ? globalThis.String(object.partyId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Account): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.partyId !== "") {
      obj.partyId = message.partyId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.balance !== 0) {
      obj.balance = message.balance;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Account>, I>>(base?: I): Account {
    return Account.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Account>, I>>(object: I): Account {
    const message = createBaseAccount();
    message.accountId = object.accountId ?? "";
    message.partyId = object.partyId ?? "";
    message.type = object.type ?? "";
    message.currency = object.currency ?? "";
    message.balance = object.balance ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseInvestmentAccount(): InvestmentAccount {
  return {
    accountId: "",
    ownerId: "",
    type: "",
    currency: "",
    balance: 0,
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    campaignId: "0",
  };
}

export const InvestmentAccount: MessageFns<InvestmentAccount> = {
  encode(message: InvestmentAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.ownerId !== "") {
      writer.uint32(18).string(message.ownerId);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.balance !== 0) {
      writer.uint32(41).double(message.balance);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(66).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(72).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvestmentAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvestmentAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.balance = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvestmentAccount {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      ownerId: isSet(object.ownerId) ? globalThis.String(object.ownerId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: InvestmentAccount): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.ownerId !== "") {
      obj.ownerId = message.ownerId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.balance !== 0) {
      obj.balance = message.balance;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvestmentAccount>, I>>(base?: I): InvestmentAccount {
    return InvestmentAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvestmentAccount>, I>>(object: I): InvestmentAccount {
    const message = createBaseInvestmentAccount();
    message.accountId = object.accountId ?? "";
    message.ownerId = object.ownerId ?? "";
    message.type = object.type ?? "";
    message.currency = object.currency ?? "";
    message.balance = object.balance ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseInvestmentOrder(): InvestmentOrder {
  return {
    orderId: "",
    accountId: "",
    assetId: "",
    quantity: 0,
    price: 0,
    orderType: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
    campaignId: "0",
  };
}

export const InvestmentOrder: MessageFns<InvestmentOrder> = {
  encode(message: InvestmentOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    if (message.assetId !== "") {
      writer.uint32(26).string(message.assetId);
    }
    if (message.quantity !== 0) {
      writer.uint32(33).double(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(41).double(message.price);
    }
    if (message.orderType !== "") {
      writer.uint32(50).string(message.orderType);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(80).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvestmentOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvestmentOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.quantity = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.orderType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvestmentOrder {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      orderType: isSet(object.orderType) ? globalThis.String(object.orderType) : "",
      status: isSet(object.status) ? investmentOrderStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: InvestmentOrder): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.quantity !== 0) {
      obj.quantity = message.quantity;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.orderType !== "") {
      obj.orderType = message.orderType;
    }
    if (message.status !== 0) {
      obj.status = investmentOrderStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvestmentOrder>, I>>(base?: I): InvestmentOrder {
    return InvestmentOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvestmentOrder>, I>>(object: I): InvestmentOrder {
    const message = createBaseInvestmentOrder();
    message.orderId = object.orderId ?? "";
    message.accountId = object.accountId ?? "";
    message.assetId = object.assetId ?? "";
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    message.orderType = object.orderType ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseAsset(): Asset {
  return {
    assetId: "",
    symbol: "",
    name: "",
    type: "",
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Asset>, I>>(base?: I): Asset {
    return Asset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Asset>, I>>(object: I): Asset {
    const message = createBaseAsset();
    message.assetId = object.assetId ?? "";
    message.symbol = object.symbol ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBasePortfolio(): Portfolio {
  return {
    portfolioId: "",
    accountId: "",
    positions: [],
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    campaignId: "0",
  };
}

export const Portfolio: MessageFns<Portfolio> = {
  encode(message: Portfolio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.portfolioId !== "") {
      writer.uint32(10).string(message.portfolioId);
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    for (const v of message.positions) {
      AssetPosition.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(56).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Portfolio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.portfolioId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.positions.push(AssetPosition.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Portfolio {
    return {
      portfolioId: isSet(object.portfolioId) ? globalThis.String(object.portfolioId) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      positions: globalThis.Array.isArray(object?.positions)
        ? object.positions.map((e: any) => AssetPosition.fromJSON(e))
        : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Portfolio): unknown {
    const obj: any = {};
    if (message.portfolioId !== "") {
      obj.portfolioId = message.portfolioId;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.positions?.length) {
      obj.positions = message.positions.map((e) => AssetPosition.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Portfolio>, I>>(base?: I): Portfolio {
    return Portfolio.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Portfolio>, I>>(object: I): Portfolio {
    const message = createBasePortfolio();
    message.portfolioId = object.portfolioId ?? "";
    message.accountId = object.accountId ?? "";
    message.positions = object.positions?.map((e) => AssetPosition.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseAssetPosition(): AssetPosition {
  return { assetId: "", quantity: 0, averagePrice: 0, metadata: undefined, createdAt: undefined, updatedAt: undefined };
}

export const AssetPosition: MessageFns<AssetPosition> = {
  encode(message: AssetPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.quantity !== 0) {
      writer.uint32(17).double(message.quantity);
    }
    if (message.averagePrice !== 0) {
      writer.uint32(25).double(message.averagePrice);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.quantity = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.averagePrice = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetPosition {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      averagePrice: isSet(object.averagePrice) ? globalThis.Number(object.averagePrice) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: AssetPosition): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.quantity !== 0) {
      obj.quantity = message.quantity;
    }
    if (message.averagePrice !== 0) {
      obj.averagePrice = message.averagePrice;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetPosition>, I>>(base?: I): AssetPosition {
    return AssetPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetPosition>, I>>(object: I): AssetPosition {
    const message = createBaseAssetPosition();
    message.assetId = object.assetId ?? "";
    message.quantity = object.quantity ?? 0;
    message.averagePrice = object.averagePrice ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseBankAccount(): BankAccount {
  return { accountId: "", userId: "", iban: "", bic: "", currency: "", balance: 0, metadata: undefined };
}

export const BankAccount: MessageFns<BankAccount> = {
  encode(message: BankAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.iban !== "") {
      writer.uint32(26).string(message.iban);
    }
    if (message.bic !== "") {
      writer.uint32(34).string(message.bic);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.balance !== 0) {
      writer.uint32(49).double(message.balance);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BankAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBankAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.iban = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bic = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.balance = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BankAccount {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      iban: isSet(object.iban) ? globalThis.String(object.iban) : "",
      bic: isSet(object.bic) ? globalThis.String(object.bic) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: BankAccount): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.iban !== "") {
      obj.iban = message.iban;
    }
    if (message.bic !== "") {
      obj.bic = message.bic;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.balance !== 0) {
      obj.balance = message.balance;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BankAccount>, I>>(base?: I): BankAccount {
    return BankAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BankAccount>, I>>(object: I): BankAccount {
    const message = createBaseBankAccount();
    message.accountId = object.accountId ?? "";
    message.userId = object.userId ?? "";
    message.iban = object.iban ?? "";
    message.bic = object.bic ?? "";
    message.currency = object.currency ?? "";
    message.balance = object.balance ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseBankTransfer(): BankTransfer {
  return {
    transferId: "",
    fromAccountId: "",
    toAccountId: "",
    amount: 0,
    currency: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
  };
}

export const BankTransfer: MessageFns<BankTransfer> = {
  encode(message: BankTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.fromAccountId !== "") {
      writer.uint32(18).string(message.fromAccountId);
    }
    if (message.toAccountId !== "") {
      writer.uint32(26).string(message.toAccountId);
    }
    if (message.amount !== 0) {
      writer.uint32(33).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BankTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBankTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fromAccountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toAccountId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BankTransfer {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      fromAccountId: isSet(object.fromAccountId) ? globalThis.String(object.fromAccountId) : "",
      toAccountId: isSet(object.toAccountId) ? globalThis.String(object.toAccountId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? bankTransferStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: BankTransfer): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.fromAccountId !== "") {
      obj.fromAccountId = message.fromAccountId;
    }
    if (message.toAccountId !== "") {
      obj.toAccountId = message.toAccountId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== 0) {
      obj.status = bankTransferStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BankTransfer>, I>>(base?: I): BankTransfer {
    return BankTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BankTransfer>, I>>(object: I): BankTransfer {
    const message = createBaseBankTransfer();
    message.transferId = object.transferId ?? "";
    message.fromAccountId = object.fromAccountId ?? "";
    message.toAccountId = object.toAccountId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseBankStatement(): BankStatement {
  return { accountId: "", transactions: [], metadata: undefined };
}

export const BankStatement: MessageFns<BankStatement> = {
  encode(message: BankStatement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    for (const v of message.transactions) {
      Transaction.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BankStatement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBankStatement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transactions.push(Transaction.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BankStatement {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => Transaction.fromJSON(e))
        : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: BankStatement): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => Transaction.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BankStatement>, I>>(base?: I): BankStatement {
    return BankStatement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BankStatement>, I>>(object: I): BankStatement {
    const message = createBaseBankStatement();
    message.accountId = object.accountId ?? "";
    message.transactions = object.transactions?.map((e) => Transaction.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseMarketplaceListing(): MarketplaceListing {
  return {
    listingId: "",
    sellerId: "",
    productId: "",
    price: 0,
    currency: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
  };
}

export const MarketplaceListing: MessageFns<MarketplaceListing> = {
  encode(message: MarketplaceListing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listingId !== "") {
      writer.uint32(10).string(message.listingId);
    }
    if (message.sellerId !== "") {
      writer.uint32(18).string(message.sellerId);
    }
    if (message.productId !== "") {
      writer.uint32(26).string(message.productId);
    }
    if (message.price !== 0) {
      writer.uint32(33).double(message.price);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketplaceListing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketplaceListing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.listingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sellerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketplaceListing {
    return {
      listingId: isSet(object.listingId) ? globalThis.String(object.listingId) : "",
      sellerId: isSet(object.sellerId) ? globalThis.String(object.sellerId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? listingStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: MarketplaceListing): unknown {
    const obj: any = {};
    if (message.listingId !== "") {
      obj.listingId = message.listingId;
    }
    if (message.sellerId !== "") {
      obj.sellerId = message.sellerId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== 0) {
      obj.status = listingStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketplaceListing>, I>>(base?: I): MarketplaceListing {
    return MarketplaceListing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketplaceListing>, I>>(object: I): MarketplaceListing {
    const message = createBaseMarketplaceListing();
    message.listingId = object.listingId ?? "";
    message.sellerId = object.sellerId ?? "";
    message.productId = object.productId ?? "";
    message.price = object.price ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseMarketplaceOrder(): MarketplaceOrder {
  return {
    orderId: "",
    listingId: "",
    buyerId: "",
    price: 0,
    currency: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
  };
}

export const MarketplaceOrder: MessageFns<MarketplaceOrder> = {
  encode(message: MarketplaceOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.listingId !== "") {
      writer.uint32(18).string(message.listingId);
    }
    if (message.buyerId !== "") {
      writer.uint32(26).string(message.buyerId);
    }
    if (message.price !== 0) {
      writer.uint32(33).double(message.price);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketplaceOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketplaceOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.listingId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buyerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketplaceOrder {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      listingId: isSet(object.listingId) ? globalThis.String(object.listingId) : "",
      buyerId: isSet(object.buyerId) ? globalThis.String(object.buyerId) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? marketplaceOrderStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: MarketplaceOrder): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.listingId !== "") {
      obj.listingId = message.listingId;
    }
    if (message.buyerId !== "") {
      obj.buyerId = message.buyerId;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== 0) {
      obj.status = marketplaceOrderStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketplaceOrder>, I>>(base?: I): MarketplaceOrder {
    return MarketplaceOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketplaceOrder>, I>>(object: I): MarketplaceOrder {
    const message = createBaseMarketplaceOrder();
    message.orderId = object.orderId ?? "";
    message.listingId = object.listingId ?? "";
    message.buyerId = object.buyerId ?? "";
    message.price = object.price ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseMarketplaceOffer(): MarketplaceOffer {
  return {
    offerId: "",
    listingId: "",
    buyerId: "",
    offerPrice: 0,
    currency: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
  };
}

export const MarketplaceOffer: MessageFns<MarketplaceOffer> = {
  encode(message: MarketplaceOffer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offerId !== "") {
      writer.uint32(10).string(message.offerId);
    }
    if (message.listingId !== "") {
      writer.uint32(18).string(message.listingId);
    }
    if (message.buyerId !== "") {
      writer.uint32(26).string(message.buyerId);
    }
    if (message.offerPrice !== 0) {
      writer.uint32(33).double(message.offerPrice);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketplaceOffer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketplaceOffer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.listingId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buyerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.offerPrice = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketplaceOffer {
    return {
      offerId: isSet(object.offerId) ? globalThis.String(object.offerId) : "",
      listingId: isSet(object.listingId) ? globalThis.String(object.listingId) : "",
      buyerId: isSet(object.buyerId) ? globalThis.String(object.buyerId) : "",
      offerPrice: isSet(object.offerPrice) ? globalThis.Number(object.offerPrice) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      status: isSet(object.status) ? offerStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: MarketplaceOffer): unknown {
    const obj: any = {};
    if (message.offerId !== "") {
      obj.offerId = message.offerId;
    }
    if (message.listingId !== "") {
      obj.listingId = message.listingId;
    }
    if (message.buyerId !== "") {
      obj.buyerId = message.buyerId;
    }
    if (message.offerPrice !== 0) {
      obj.offerPrice = message.offerPrice;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.status !== 0) {
      obj.status = offerStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketplaceOffer>, I>>(base?: I): MarketplaceOffer {
    return MarketplaceOffer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketplaceOffer>, I>>(object: I): MarketplaceOffer {
    const message = createBaseMarketplaceOffer();
    message.offerId = object.offerId ?? "";
    message.listingId = object.listingId ?? "";
    message.buyerId = object.buyerId ?? "";
    message.offerPrice = object.offerPrice ?? 0;
    message.currency = object.currency ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseExchangeOrder(): ExchangeOrder {
  return {
    orderId: "",
    accountId: "",
    pair: "",
    amount: 0,
    price: 0,
    orderType: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
  };
}

export const ExchangeOrder: MessageFns<ExchangeOrder> = {
  encode(message: ExchangeOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    if (message.pair !== "") {
      writer.uint32(26).string(message.pair);
    }
    if (message.amount !== 0) {
      writer.uint32(33).double(message.amount);
    }
    if (message.price !== 0) {
      writer.uint32(41).double(message.price);
    }
    if (message.orderType !== "") {
      writer.uint32(50).string(message.orderType);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangeOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pair = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.orderType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExchangeOrder {
    return {
      orderId: isSet(object.orderId) ? globalThis.String(object.orderId) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      pair: isSet(object.pair) ? globalThis.String(object.pair) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      orderType: isSet(object.orderType) ? globalThis.String(object.orderType) : "",
      status: isSet(object.status) ? exchangeOrderStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: ExchangeOrder): unknown {
    const obj: any = {};
    if (message.orderId !== "") {
      obj.orderId = message.orderId;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.pair !== "") {
      obj.pair = message.pair;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.orderType !== "") {
      obj.orderType = message.orderType;
    }
    if (message.status !== 0) {
      obj.status = exchangeOrderStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangeOrder>, I>>(base?: I): ExchangeOrder {
    return ExchangeOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangeOrder>, I>>(object: I): ExchangeOrder {
    const message = createBaseExchangeOrder();
    message.orderId = object.orderId ?? "";
    message.accountId = object.accountId ?? "";
    message.pair = object.pair ?? "";
    message.amount = object.amount ?? 0;
    message.price = object.price ?? 0;
    message.orderType = object.orderType ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseExchangePair(): ExchangePair {
  return { pairId: "", baseAsset: "", quoteAsset: "", metadata: undefined, campaignId: "0" };
}

export const ExchangePair: MessageFns<ExchangePair> = {
  encode(message: ExchangePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairId !== "") {
      writer.uint32(10).string(message.pairId);
    }
    if (message.baseAsset !== "") {
      writer.uint32(18).string(message.baseAsset);
    }
    if (message.quoteAsset !== "") {
      writer.uint32(26).string(message.quoteAsset);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseAsset = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quoteAsset = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExchangePair {
    return {
      pairId: isSet(object.pairId) ? globalThis.String(object.pairId) : "",
      baseAsset: isSet(object.baseAsset) ? globalThis.String(object.baseAsset) : "",
      quoteAsset: isSet(object.quoteAsset) ? globalThis.String(object.quoteAsset) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ExchangePair): unknown {
    const obj: any = {};
    if (message.pairId !== "") {
      obj.pairId = message.pairId;
    }
    if (message.baseAsset !== "") {
      obj.baseAsset = message.baseAsset;
    }
    if (message.quoteAsset !== "") {
      obj.quoteAsset = message.quoteAsset;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangePair>, I>>(base?: I): ExchangePair {
    return ExchangePair.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangePair>, I>>(object: I): ExchangePair {
    const message = createBaseExchangePair();
    message.pairId = object.pairId ?? "";
    message.baseAsset = object.baseAsset ?? "";
    message.quoteAsset = object.quoteAsset ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseExchangeRate(): ExchangeRate {
  return { pairId: "", rate: 0, timestamp: undefined, metadata: undefined, campaignId: "0" };
}

export const ExchangeRate: MessageFns<ExchangeRate> = {
  encode(message: ExchangeRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairId !== "") {
      writer.uint32(10).string(message.pairId);
    }
    if (message.rate !== 0) {
      writer.uint32(17).double(message.rate);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExchangeRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExchangeRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.rate = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExchangeRate {
    return {
      pairId: isSet(object.pairId) ? globalThis.String(object.pairId) : "",
      rate: isSet(object.rate) ? globalThis.Number(object.rate) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ExchangeRate): unknown {
    const obj: any = {};
    if (message.pairId !== "") {
      obj.pairId = message.pairId;
    }
    if (message.rate !== 0) {
      obj.rate = message.rate;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExchangeRate>, I>>(base?: I): ExchangeRate {
    return ExchangeRate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExchangeRate>, I>>(object: I): ExchangeRate {
    const message = createBaseExchangeRate();
    message.pairId = object.pairId ?? "";
    message.rate = object.rate ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCreateInvestmentAccountRequest(): CreateInvestmentAccountRequest {
  return { ownerId: "", type: "", currency: "", balance: 0, metadata: undefined, campaignId: "0" };
}

export const CreateInvestmentAccountRequest: MessageFns<CreateInvestmentAccountRequest> = {
  encode(message: CreateInvestmentAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerId !== "") {
      writer.uint32(10).string(message.ownerId);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.balance !== 0) {
      writer.uint32(33).double(message.balance);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvestmentAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvestmentAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.balance = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvestmentAccountRequest {
    return {
      ownerId: isSet(object.ownerId) ? globalThis.String(object.ownerId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: CreateInvestmentAccountRequest): unknown {
    const obj: any = {};
    if (message.ownerId !== "") {
      obj.ownerId = message.ownerId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.balance !== 0) {
      obj.balance = message.balance;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvestmentAccountRequest>, I>>(base?: I): CreateInvestmentAccountRequest {
    return CreateInvestmentAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvestmentAccountRequest>, I>>(
    object: I,
  ): CreateInvestmentAccountRequest {
    const message = createBaseCreateInvestmentAccountRequest();
    message.ownerId = object.ownerId ?? "";
    message.type = object.type ?? "";
    message.currency = object.currency ?? "";
    message.balance = object.balance ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCreateInvestmentAccountResponse(): CreateInvestmentAccountResponse {
  return { account: undefined };
}

export const CreateInvestmentAccountResponse: MessageFns<CreateInvestmentAccountResponse> = {
  encode(message: CreateInvestmentAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== undefined) {
      InvestmentAccount.encode(message.account, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInvestmentAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInvestmentAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = InvestmentAccount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInvestmentAccountResponse {
    return { account: isSet(object.account) ? InvestmentAccount.fromJSON(object.account) : undefined };
  },

  toJSON(message: CreateInvestmentAccountResponse): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = InvestmentAccount.toJSON(message.account);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateInvestmentAccountResponse>, I>>(base?: I): CreateInvestmentAccountResponse {
    return CreateInvestmentAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateInvestmentAccountResponse>, I>>(
    object: I,
  ): CreateInvestmentAccountResponse {
    const message = createBaseCreateInvestmentAccountResponse();
    message.account = (object.account !== undefined && object.account !== null)
      ? InvestmentAccount.fromPartial(object.account)
      : undefined;
    return message;
  },
};

function createBaseGetInvestmentAccountRequest(): GetInvestmentAccountRequest {
  return { accountId: "", campaignId: "0" };
}

export const GetInvestmentAccountRequest: MessageFns<GetInvestmentAccountRequest> = {
  encode(message: GetInvestmentAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvestmentAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvestmentAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvestmentAccountRequest {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetInvestmentAccountRequest): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInvestmentAccountRequest>, I>>(base?: I): GetInvestmentAccountRequest {
    return GetInvestmentAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInvestmentAccountRequest>, I>>(object: I): GetInvestmentAccountRequest {
    const message = createBaseGetInvestmentAccountRequest();
    message.accountId = object.accountId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetInvestmentAccountResponse(): GetInvestmentAccountResponse {
  return { account: undefined };
}

export const GetInvestmentAccountResponse: MessageFns<GetInvestmentAccountResponse> = {
  encode(message: GetInvestmentAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== undefined) {
      InvestmentAccount.encode(message.account, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInvestmentAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInvestmentAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = InvestmentAccount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInvestmentAccountResponse {
    return { account: isSet(object.account) ? InvestmentAccount.fromJSON(object.account) : undefined };
  },

  toJSON(message: GetInvestmentAccountResponse): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = InvestmentAccount.toJSON(message.account);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetInvestmentAccountResponse>, I>>(base?: I): GetInvestmentAccountResponse {
    return GetInvestmentAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetInvestmentAccountResponse>, I>>(object: I): GetInvestmentAccountResponse {
    const message = createBaseGetInvestmentAccountResponse();
    message.account = (object.account !== undefined && object.account !== null)
      ? InvestmentAccount.fromPartial(object.account)
      : undefined;
    return message;
  },
};

function createBasePlaceInvestmentOrderRequest(): PlaceInvestmentOrderRequest {
  return { accountId: "", assetId: "", quantity: 0, price: 0, orderType: "", metadata: undefined, campaignId: "0" };
}

export const PlaceInvestmentOrderRequest: MessageFns<PlaceInvestmentOrderRequest> = {
  encode(message: PlaceInvestmentOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.assetId !== "") {
      writer.uint32(18).string(message.assetId);
    }
    if (message.quantity !== 0) {
      writer.uint32(25).double(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(33).double(message.price);
    }
    if (message.orderType !== "") {
      writer.uint32(42).string(message.orderType);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(56).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceInvestmentOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceInvestmentOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.quantity = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.orderType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceInvestmentOrderRequest {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      orderType: isSet(object.orderType) ? globalThis.String(object.orderType) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: PlaceInvestmentOrderRequest): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.quantity !== 0) {
      obj.quantity = message.quantity;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.orderType !== "") {
      obj.orderType = message.orderType;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceInvestmentOrderRequest>, I>>(base?: I): PlaceInvestmentOrderRequest {
    return PlaceInvestmentOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceInvestmentOrderRequest>, I>>(object: I): PlaceInvestmentOrderRequest {
    const message = createBasePlaceInvestmentOrderRequest();
    message.accountId = object.accountId ?? "";
    message.assetId = object.assetId ?? "";
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    message.orderType = object.orderType ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBasePlaceInvestmentOrderResponse(): PlaceInvestmentOrderResponse {
  return { order: undefined };
}

export const PlaceInvestmentOrderResponse: MessageFns<PlaceInvestmentOrderResponse> = {
  encode(message: PlaceInvestmentOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      InvestmentOrder.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceInvestmentOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceInvestmentOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = InvestmentOrder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceInvestmentOrderResponse {
    return { order: isSet(object.order) ? InvestmentOrder.fromJSON(object.order) : undefined };
  },

  toJSON(message: PlaceInvestmentOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = InvestmentOrder.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceInvestmentOrderResponse>, I>>(base?: I): PlaceInvestmentOrderResponse {
    return PlaceInvestmentOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceInvestmentOrderResponse>, I>>(object: I): PlaceInvestmentOrderResponse {
    const message = createBasePlaceInvestmentOrderResponse();
    message.order = (object.order !== undefined && object.order !== null)
      ? InvestmentOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseGetPortfolioRequest(): GetPortfolioRequest {
  return { portfolioId: "", campaignId: "0" };
}

export const GetPortfolioRequest: MessageFns<GetPortfolioRequest> = {
  encode(message: GetPortfolioRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.portfolioId !== "") {
      writer.uint32(10).string(message.portfolioId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortfolioRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortfolioRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.portfolioId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortfolioRequest {
    return {
      portfolioId: isSet(object.portfolioId) ? globalThis.String(object.portfolioId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetPortfolioRequest): unknown {
    const obj: any = {};
    if (message.portfolioId !== "") {
      obj.portfolioId = message.portfolioId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortfolioRequest>, I>>(base?: I): GetPortfolioRequest {
    return GetPortfolioRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortfolioRequest>, I>>(object: I): GetPortfolioRequest {
    const message = createBaseGetPortfolioRequest();
    message.portfolioId = object.portfolioId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetPortfolioResponse(): GetPortfolioResponse {
  return { portfolio: undefined };
}

export const GetPortfolioResponse: MessageFns<GetPortfolioResponse> = {
  encode(message: GetPortfolioResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.portfolio !== undefined) {
      Portfolio.encode(message.portfolio, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPortfolioResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPortfolioResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.portfolio = Portfolio.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPortfolioResponse {
    return { portfolio: isSet(object.portfolio) ? Portfolio.fromJSON(object.portfolio) : undefined };
  },

  toJSON(message: GetPortfolioResponse): unknown {
    const obj: any = {};
    if (message.portfolio !== undefined) {
      obj.portfolio = Portfolio.toJSON(message.portfolio);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPortfolioResponse>, I>>(base?: I): GetPortfolioResponse {
    return GetPortfolioResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPortfolioResponse>, I>>(object: I): GetPortfolioResponse {
    const message = createBaseGetPortfolioResponse();
    message.portfolio = (object.portfolio !== undefined && object.portfolio !== null)
      ? Portfolio.fromPartial(object.portfolio)
      : undefined;
    return message;
  },
};

function createBaseListPortfoliosRequest(): ListPortfoliosRequest {
  return { accountId: "", campaignId: "0" };
}

export const ListPortfoliosRequest: MessageFns<ListPortfoliosRequest> = {
  encode(message: ListPortfoliosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPortfoliosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPortfoliosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPortfoliosRequest {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListPortfoliosRequest): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPortfoliosRequest>, I>>(base?: I): ListPortfoliosRequest {
    return ListPortfoliosRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPortfoliosRequest>, I>>(object: I): ListPortfoliosRequest {
    const message = createBaseListPortfoliosRequest();
    message.accountId = object.accountId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListPortfoliosResponse(): ListPortfoliosResponse {
  return { portfolios: [] };
}

export const ListPortfoliosResponse: MessageFns<ListPortfoliosResponse> = {
  encode(message: ListPortfoliosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.portfolios) {
      Portfolio.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPortfoliosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPortfoliosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.portfolios.push(Portfolio.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPortfoliosResponse {
    return {
      portfolios: globalThis.Array.isArray(object?.portfolios)
        ? object.portfolios.map((e: any) => Portfolio.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListPortfoliosResponse): unknown {
    const obj: any = {};
    if (message.portfolios?.length) {
      obj.portfolios = message.portfolios.map((e) => Portfolio.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPortfoliosResponse>, I>>(base?: I): ListPortfoliosResponse {
    return ListPortfoliosResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPortfoliosResponse>, I>>(object: I): ListPortfoliosResponse {
    const message = createBaseListPortfoliosResponse();
    message.portfolios = object.portfolios?.map((e) => Portfolio.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListAssetsRequest(): ListAssetsRequest {
  return { userId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const ListAssetsRequest: MessageFns<ListAssetsRequest> = {
  encode(message: ListAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListAssetsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAssetsRequest>, I>>(base?: I): ListAssetsRequest {
    return ListAssetsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAssetsRequest>, I>>(object: I): ListAssetsRequest {
    const message = createBaseListAssetsRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListAssetsResponse(): ListAssetsResponse {
  return { assets: [], total: 0 };
}

export const ListAssetsResponse: MessageFns<ListAssetsResponse> = {
  encode(message: ListAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assets) {
      Asset.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assets.push(Asset.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsResponse {
    return {
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => Asset.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListAssetsResponse): unknown {
    const obj: any = {};
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => Asset.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAssetsResponse>, I>>(base?: I): ListAssetsResponse {
    return ListAssetsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAssetsResponse>, I>>(object: I): ListAssetsResponse {
    const message = createBaseListAssetsResponse();
    message.assets = object.assets?.map((e) => Asset.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseCreateBankAccountRequest(): CreateBankAccountRequest {
  return { userId: "", iban: "", bic: "", currency: "", balance: 0, metadata: undefined, campaignId: "0" };
}

export const CreateBankAccountRequest: MessageFns<CreateBankAccountRequest> = {
  encode(message: CreateBankAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.iban !== "") {
      writer.uint32(18).string(message.iban);
    }
    if (message.bic !== "") {
      writer.uint32(26).string(message.bic);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.balance !== 0) {
      writer.uint32(41).double(message.balance);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(56).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBankAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBankAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.iban = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bic = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.balance = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBankAccountRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      iban: isSet(object.iban) ? globalThis.String(object.iban) : "",
      bic: isSet(object.bic) ? globalThis.String(object.bic) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: CreateBankAccountRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.iban !== "") {
      obj.iban = message.iban;
    }
    if (message.bic !== "") {
      obj.bic = message.bic;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.balance !== 0) {
      obj.balance = message.balance;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBankAccountRequest>, I>>(base?: I): CreateBankAccountRequest {
    return CreateBankAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBankAccountRequest>, I>>(object: I): CreateBankAccountRequest {
    const message = createBaseCreateBankAccountRequest();
    message.userId = object.userId ?? "";
    message.iban = object.iban ?? "";
    message.bic = object.bic ?? "";
    message.currency = object.currency ?? "";
    message.balance = object.balance ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCreateBankAccountResponse(): CreateBankAccountResponse {
  return { account: undefined };
}

export const CreateBankAccountResponse: MessageFns<CreateBankAccountResponse> = {
  encode(message: CreateBankAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== undefined) {
      BankAccount.encode(message.account, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBankAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBankAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = BankAccount.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBankAccountResponse {
    return { account: isSet(object.account) ? BankAccount.fromJSON(object.account) : undefined };
  },

  toJSON(message: CreateBankAccountResponse): unknown {
    const obj: any = {};
    if (message.account !== undefined) {
      obj.account = BankAccount.toJSON(message.account);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateBankAccountResponse>, I>>(base?: I): CreateBankAccountResponse {
    return CreateBankAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateBankAccountResponse>, I>>(object: I): CreateBankAccountResponse {
    const message = createBaseCreateBankAccountResponse();
    message.account = (object.account !== undefined && object.account !== null)
      ? BankAccount.fromPartial(object.account)
      : undefined;
    return message;
  },
};

function createBaseInitiateBankTransferRequest(): InitiateBankTransferRequest {
  return { fromAccountId: "", toAccountId: "", amount: 0, currency: "", metadata: undefined, campaignId: "0" };
}

export const InitiateBankTransferRequest: MessageFns<InitiateBankTransferRequest> = {
  encode(message: InitiateBankTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromAccountId !== "") {
      writer.uint32(10).string(message.fromAccountId);
    }
    if (message.toAccountId !== "") {
      writer.uint32(18).string(message.toAccountId);
    }
    if (message.amount !== 0) {
      writer.uint32(25).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateBankTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateBankTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromAccountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toAccountId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateBankTransferRequest {
    return {
      fromAccountId: isSet(object.fromAccountId) ? globalThis.String(object.fromAccountId) : "",
      toAccountId: isSet(object.toAccountId) ? globalThis.String(object.toAccountId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: InitiateBankTransferRequest): unknown {
    const obj: any = {};
    if (message.fromAccountId !== "") {
      obj.fromAccountId = message.fromAccountId;
    }
    if (message.toAccountId !== "") {
      obj.toAccountId = message.toAccountId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateBankTransferRequest>, I>>(base?: I): InitiateBankTransferRequest {
    return InitiateBankTransferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateBankTransferRequest>, I>>(object: I): InitiateBankTransferRequest {
    const message = createBaseInitiateBankTransferRequest();
    message.fromAccountId = object.fromAccountId ?? "";
    message.toAccountId = object.toAccountId ?? "";
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseInitiateBankTransferResponse(): InitiateBankTransferResponse {
  return { transfer: undefined };
}

export const InitiateBankTransferResponse: MessageFns<InitiateBankTransferResponse> = {
  encode(message: InitiateBankTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      BankTransfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateBankTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateBankTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = BankTransfer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateBankTransferResponse {
    return { transfer: isSet(object.transfer) ? BankTransfer.fromJSON(object.transfer) : undefined };
  },

  toJSON(message: InitiateBankTransferResponse): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = BankTransfer.toJSON(message.transfer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateBankTransferResponse>, I>>(base?: I): InitiateBankTransferResponse {
    return InitiateBankTransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateBankTransferResponse>, I>>(object: I): InitiateBankTransferResponse {
    const message = createBaseInitiateBankTransferResponse();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? BankTransfer.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseGetBankStatementRequest(): GetBankStatementRequest {
  return { accountId: "", campaignId: "0" };
}

export const GetBankStatementRequest: MessageFns<GetBankStatementRequest> = {
  encode(message: GetBankStatementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBankStatementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBankStatementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBankStatementRequest {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetBankStatementRequest): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBankStatementRequest>, I>>(base?: I): GetBankStatementRequest {
    return GetBankStatementRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBankStatementRequest>, I>>(object: I): GetBankStatementRequest {
    const message = createBaseGetBankStatementRequest();
    message.accountId = object.accountId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetBankStatementResponse(): GetBankStatementResponse {
  return { statement: undefined };
}

export const GetBankStatementResponse: MessageFns<GetBankStatementResponse> = {
  encode(message: GetBankStatementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statement !== undefined) {
      BankStatement.encode(message.statement, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBankStatementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBankStatementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statement = BankStatement.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBankStatementResponse {
    return { statement: isSet(object.statement) ? BankStatement.fromJSON(object.statement) : undefined };
  },

  toJSON(message: GetBankStatementResponse): unknown {
    const obj: any = {};
    if (message.statement !== undefined) {
      obj.statement = BankStatement.toJSON(message.statement);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBankStatementResponse>, I>>(base?: I): GetBankStatementResponse {
    return GetBankStatementResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBankStatementResponse>, I>>(object: I): GetBankStatementResponse {
    const message = createBaseGetBankStatementResponse();
    message.statement = (object.statement !== undefined && object.statement !== null)
      ? BankStatement.fromPartial(object.statement)
      : undefined;
    return message;
  },
};

function createBaseCreateListingRequest(): CreateListingRequest {
  return { sellerId: "", productId: "", price: 0, currency: "", metadata: undefined, campaignId: "0" };
}

export const CreateListingRequest: MessageFns<CreateListingRequest> = {
  encode(message: CreateListingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sellerId !== "") {
      writer.uint32(10).string(message.sellerId);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.price !== 0) {
      writer.uint32(25).double(message.price);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateListingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateListingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sellerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateListingRequest {
    return {
      sellerId: isSet(object.sellerId) ? globalThis.String(object.sellerId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: CreateListingRequest): unknown {
    const obj: any = {};
    if (message.sellerId !== "") {
      obj.sellerId = message.sellerId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateListingRequest>, I>>(base?: I): CreateListingRequest {
    return CreateListingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateListingRequest>, I>>(object: I): CreateListingRequest {
    const message = createBaseCreateListingRequest();
    message.sellerId = object.sellerId ?? "";
    message.productId = object.productId ?? "";
    message.price = object.price ?? 0;
    message.currency = object.currency ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCreateListingResponse(): CreateListingResponse {
  return { listing: undefined };
}

export const CreateListingResponse: MessageFns<CreateListingResponse> = {
  encode(message: CreateListingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listing !== undefined) {
      MarketplaceListing.encode(message.listing, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateListingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateListingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.listing = MarketplaceListing.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateListingResponse {
    return { listing: isSet(object.listing) ? MarketplaceListing.fromJSON(object.listing) : undefined };
  },

  toJSON(message: CreateListingResponse): unknown {
    const obj: any = {};
    if (message.listing !== undefined) {
      obj.listing = MarketplaceListing.toJSON(message.listing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateListingResponse>, I>>(base?: I): CreateListingResponse {
    return CreateListingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateListingResponse>, I>>(object: I): CreateListingResponse {
    const message = createBaseCreateListingResponse();
    message.listing = (object.listing !== undefined && object.listing !== null)
      ? MarketplaceListing.fromPartial(object.listing)
      : undefined;
    return message;
  },
};

function createBasePlaceMarketplaceOrderRequest(): PlaceMarketplaceOrderRequest {
  return { listingId: "", buyerId: "", price: 0, currency: "", metadata: undefined, campaignId: "0" };
}

export const PlaceMarketplaceOrderRequest: MessageFns<PlaceMarketplaceOrderRequest> = {
  encode(message: PlaceMarketplaceOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listingId !== "") {
      writer.uint32(10).string(message.listingId);
    }
    if (message.buyerId !== "") {
      writer.uint32(18).string(message.buyerId);
    }
    if (message.price !== 0) {
      writer.uint32(25).double(message.price);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceMarketplaceOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceMarketplaceOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.listingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.buyerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceMarketplaceOrderRequest {
    return {
      listingId: isSet(object.listingId) ? globalThis.String(object.listingId) : "",
      buyerId: isSet(object.buyerId) ? globalThis.String(object.buyerId) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: PlaceMarketplaceOrderRequest): unknown {
    const obj: any = {};
    if (message.listingId !== "") {
      obj.listingId = message.listingId;
    }
    if (message.buyerId !== "") {
      obj.buyerId = message.buyerId;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceMarketplaceOrderRequest>, I>>(base?: I): PlaceMarketplaceOrderRequest {
    return PlaceMarketplaceOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceMarketplaceOrderRequest>, I>>(object: I): PlaceMarketplaceOrderRequest {
    const message = createBasePlaceMarketplaceOrderRequest();
    message.listingId = object.listingId ?? "";
    message.buyerId = object.buyerId ?? "";
    message.price = object.price ?? 0;
    message.currency = object.currency ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBasePlaceMarketplaceOrderResponse(): PlaceMarketplaceOrderResponse {
  return { order: undefined };
}

export const PlaceMarketplaceOrderResponse: MessageFns<PlaceMarketplaceOrderResponse> = {
  encode(message: PlaceMarketplaceOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      MarketplaceOrder.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceMarketplaceOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceMarketplaceOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = MarketplaceOrder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceMarketplaceOrderResponse {
    return { order: isSet(object.order) ? MarketplaceOrder.fromJSON(object.order) : undefined };
  },

  toJSON(message: PlaceMarketplaceOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = MarketplaceOrder.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceMarketplaceOrderResponse>, I>>(base?: I): PlaceMarketplaceOrderResponse {
    return PlaceMarketplaceOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceMarketplaceOrderResponse>, I>>(
    object: I,
  ): PlaceMarketplaceOrderResponse {
    const message = createBasePlaceMarketplaceOrderResponse();
    message.order = (object.order !== undefined && object.order !== null)
      ? MarketplaceOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseMakeOfferRequest(): MakeOfferRequest {
  return { listingId: "", buyerId: "", offerPrice: 0, currency: "", metadata: undefined, campaignId: "0" };
}

export const MakeOfferRequest: MessageFns<MakeOfferRequest> = {
  encode(message: MakeOfferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.listingId !== "") {
      writer.uint32(10).string(message.listingId);
    }
    if (message.buyerId !== "") {
      writer.uint32(18).string(message.buyerId);
    }
    if (message.offerPrice !== 0) {
      writer.uint32(25).double(message.offerPrice);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MakeOfferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMakeOfferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.listingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.buyerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.offerPrice = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MakeOfferRequest {
    return {
      listingId: isSet(object.listingId) ? globalThis.String(object.listingId) : "",
      buyerId: isSet(object.buyerId) ? globalThis.String(object.buyerId) : "",
      offerPrice: isSet(object.offerPrice) ? globalThis.Number(object.offerPrice) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: MakeOfferRequest): unknown {
    const obj: any = {};
    if (message.listingId !== "") {
      obj.listingId = message.listingId;
    }
    if (message.buyerId !== "") {
      obj.buyerId = message.buyerId;
    }
    if (message.offerPrice !== 0) {
      obj.offerPrice = message.offerPrice;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MakeOfferRequest>, I>>(base?: I): MakeOfferRequest {
    return MakeOfferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MakeOfferRequest>, I>>(object: I): MakeOfferRequest {
    const message = createBaseMakeOfferRequest();
    message.listingId = object.listingId ?? "";
    message.buyerId = object.buyerId ?? "";
    message.offerPrice = object.offerPrice ?? 0;
    message.currency = object.currency ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseMakeOfferResponse(): MakeOfferResponse {
  return { offer: undefined };
}

export const MakeOfferResponse: MessageFns<MakeOfferResponse> = {
  encode(message: MakeOfferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offer !== undefined) {
      MarketplaceOffer.encode(message.offer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MakeOfferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMakeOfferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offer = MarketplaceOffer.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MakeOfferResponse {
    return { offer: isSet(object.offer) ? MarketplaceOffer.fromJSON(object.offer) : undefined };
  },

  toJSON(message: MakeOfferResponse): unknown {
    const obj: any = {};
    if (message.offer !== undefined) {
      obj.offer = MarketplaceOffer.toJSON(message.offer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MakeOfferResponse>, I>>(base?: I): MakeOfferResponse {
    return MakeOfferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MakeOfferResponse>, I>>(object: I): MakeOfferResponse {
    const message = createBaseMakeOfferResponse();
    message.offer = (object.offer !== undefined && object.offer !== null)
      ? MarketplaceOffer.fromPartial(object.offer)
      : undefined;
    return message;
  },
};

function createBaseListListingsRequest(): ListListingsRequest {
  return { userId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const ListListingsRequest: MessageFns<ListListingsRequest> = {
  encode(message: ListListingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListListingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListListingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListListingsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListListingsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListListingsRequest>, I>>(base?: I): ListListingsRequest {
    return ListListingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListListingsRequest>, I>>(object: I): ListListingsRequest {
    const message = createBaseListListingsRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListListingsResponse(): ListListingsResponse {
  return { listings: [], total: 0 };
}

export const ListListingsResponse: MessageFns<ListListingsResponse> = {
  encode(message: ListListingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.listings) {
      MarketplaceListing.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListListingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListListingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.listings.push(MarketplaceListing.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListListingsResponse {
    return {
      listings: globalThis.Array.isArray(object?.listings)
        ? object.listings.map((e: any) => MarketplaceListing.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListListingsResponse): unknown {
    const obj: any = {};
    if (message.listings?.length) {
      obj.listings = message.listings.map((e) => MarketplaceListing.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListListingsResponse>, I>>(base?: I): ListListingsResponse {
    return ListListingsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListListingsResponse>, I>>(object: I): ListListingsResponse {
    const message = createBaseListListingsResponse();
    message.listings = object.listings?.map((e) => MarketplaceListing.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBasePlaceExchangeOrderRequest(): PlaceExchangeOrderRequest {
  return { accountId: "", pair: "", amount: 0, price: 0, orderType: "", metadata: undefined, campaignId: "0" };
}

export const PlaceExchangeOrderRequest: MessageFns<PlaceExchangeOrderRequest> = {
  encode(message: PlaceExchangeOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.pair !== "") {
      writer.uint32(18).string(message.pair);
    }
    if (message.amount !== 0) {
      writer.uint32(25).double(message.amount);
    }
    if (message.price !== 0) {
      writer.uint32(33).double(message.price);
    }
    if (message.orderType !== "") {
      writer.uint32(42).string(message.orderType);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(56).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceExchangeOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceExchangeOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pair = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.orderType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceExchangeOrderRequest {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      pair: isSet(object.pair) ? globalThis.String(object.pair) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      orderType: isSet(object.orderType) ? globalThis.String(object.orderType) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: PlaceExchangeOrderRequest): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.pair !== "") {
      obj.pair = message.pair;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.orderType !== "") {
      obj.orderType = message.orderType;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceExchangeOrderRequest>, I>>(base?: I): PlaceExchangeOrderRequest {
    return PlaceExchangeOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceExchangeOrderRequest>, I>>(object: I): PlaceExchangeOrderRequest {
    const message = createBasePlaceExchangeOrderRequest();
    message.accountId = object.accountId ?? "";
    message.pair = object.pair ?? "";
    message.amount = object.amount ?? 0;
    message.price = object.price ?? 0;
    message.orderType = object.orderType ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBasePlaceExchangeOrderResponse(): PlaceExchangeOrderResponse {
  return { order: undefined };
}

export const PlaceExchangeOrderResponse: MessageFns<PlaceExchangeOrderResponse> = {
  encode(message: PlaceExchangeOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      ExchangeOrder.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlaceExchangeOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlaceExchangeOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = ExchangeOrder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlaceExchangeOrderResponse {
    return { order: isSet(object.order) ? ExchangeOrder.fromJSON(object.order) : undefined };
  },

  toJSON(message: PlaceExchangeOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = ExchangeOrder.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlaceExchangeOrderResponse>, I>>(base?: I): PlaceExchangeOrderResponse {
    return PlaceExchangeOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlaceExchangeOrderResponse>, I>>(object: I): PlaceExchangeOrderResponse {
    const message = createBasePlaceExchangeOrderResponse();
    message.order = (object.order !== undefined && object.order !== null)
      ? ExchangeOrder.fromPartial(object.order)
      : undefined;
    return message;
  },
};

function createBaseGetExchangeRateRequest(): GetExchangeRateRequest {
  return { pairId: "", campaignId: "0" };
}

export const GetExchangeRateRequest: MessageFns<GetExchangeRateRequest> = {
  encode(message: GetExchangeRateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairId !== "") {
      writer.uint32(10).string(message.pairId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExchangeRateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangeRateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangeRateRequest {
    return {
      pairId: isSet(object.pairId) ? globalThis.String(object.pairId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetExchangeRateRequest): unknown {
    const obj: any = {};
    if (message.pairId !== "") {
      obj.pairId = message.pairId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExchangeRateRequest>, I>>(base?: I): GetExchangeRateRequest {
    return GetExchangeRateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExchangeRateRequest>, I>>(object: I): GetExchangeRateRequest {
    const message = createBaseGetExchangeRateRequest();
    message.pairId = object.pairId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetExchangeRateResponse(): GetExchangeRateResponse {
  return { rate: undefined };
}

export const GetExchangeRateResponse: MessageFns<GetExchangeRateResponse> = {
  encode(message: GetExchangeRateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rate !== undefined) {
      ExchangeRate.encode(message.rate, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExchangeRateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangeRateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rate = ExchangeRate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangeRateResponse {
    return { rate: isSet(object.rate) ? ExchangeRate.fromJSON(object.rate) : undefined };
  },

  toJSON(message: GetExchangeRateResponse): unknown {
    const obj: any = {};
    if (message.rate !== undefined) {
      obj.rate = ExchangeRate.toJSON(message.rate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetExchangeRateResponse>, I>>(base?: I): GetExchangeRateResponse {
    return GetExchangeRateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetExchangeRateResponse>, I>>(object: I): GetExchangeRateResponse {
    const message = createBaseGetExchangeRateResponse();
    message.rate = (object.rate !== undefined && object.rate !== null)
      ? ExchangeRate.fromPartial(object.rate)
      : undefined;
    return message;
  },
};

function createBaseListExchangePairsRequest(): ListExchangePairsRequest {
  return { userId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const ListExchangePairsRequest: MessageFns<ListExchangePairsRequest> = {
  encode(message: ListExchangePairsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExchangePairsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExchangePairsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExchangePairsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListExchangePairsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListExchangePairsRequest>, I>>(base?: I): ListExchangePairsRequest {
    return ListExchangePairsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListExchangePairsRequest>, I>>(object: I): ListExchangePairsRequest {
    const message = createBaseListExchangePairsRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListExchangePairsResponse(): ListExchangePairsResponse {
  return { pairs: [], total: 0 };
}

export const ListExchangePairsResponse: MessageFns<ListExchangePairsResponse> = {
  encode(message: ListExchangePairsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pairs) {
      ExchangePair.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExchangePairsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExchangePairsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairs.push(ExchangePair.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExchangePairsResponse {
    return {
      pairs: globalThis.Array.isArray(object?.pairs) ? object.pairs.map((e: any) => ExchangePair.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListExchangePairsResponse): unknown {
    const obj: any = {};
    if (message.pairs?.length) {
      obj.pairs = message.pairs.map((e) => ExchangePair.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListExchangePairsResponse>, I>>(base?: I): ListExchangePairsResponse {
    return ListExchangePairsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListExchangePairsResponse>, I>>(object: I): ListExchangePairsResponse {
    const message = createBaseListExchangePairsResponse();
    message.pairs = object.pairs?.map((e) => ExchangePair.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseCreateExchangePairRequest(): CreateExchangePairRequest {
  return { pairId: "", baseAsset: "", quoteAsset: "", metadata: undefined };
}

export const CreateExchangePairRequest: MessageFns<CreateExchangePairRequest> = {
  encode(message: CreateExchangePairRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairId !== "") {
      writer.uint32(10).string(message.pairId);
    }
    if (message.baseAsset !== "") {
      writer.uint32(18).string(message.baseAsset);
    }
    if (message.quoteAsset !== "") {
      writer.uint32(26).string(message.quoteAsset);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExchangePairRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExchangePairRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseAsset = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quoteAsset = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExchangePairRequest {
    return {
      pairId: isSet(object.pairId) ? globalThis.String(object.pairId) : "",
      baseAsset: isSet(object.baseAsset) ? globalThis.String(object.baseAsset) : "",
      quoteAsset: isSet(object.quoteAsset) ? globalThis.String(object.quoteAsset) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: CreateExchangePairRequest): unknown {
    const obj: any = {};
    if (message.pairId !== "") {
      obj.pairId = message.pairId;
    }
    if (message.baseAsset !== "") {
      obj.baseAsset = message.baseAsset;
    }
    if (message.quoteAsset !== "") {
      obj.quoteAsset = message.quoteAsset;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateExchangePairRequest>, I>>(base?: I): CreateExchangePairRequest {
    return CreateExchangePairRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateExchangePairRequest>, I>>(object: I): CreateExchangePairRequest {
    const message = createBaseCreateExchangePairRequest();
    message.pairId = object.pairId ?? "";
    message.baseAsset = object.baseAsset ?? "";
    message.quoteAsset = object.quoteAsset ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseCreateExchangePairResponse(): CreateExchangePairResponse {
  return { pair: undefined };
}

export const CreateExchangePairResponse: MessageFns<CreateExchangePairResponse> = {
  encode(message: CreateExchangePairResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pair !== undefined) {
      ExchangePair.encode(message.pair, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExchangePairResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExchangePairResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pair = ExchangePair.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExchangePairResponse {
    return { pair: isSet(object.pair) ? ExchangePair.fromJSON(object.pair) : undefined };
  },

  toJSON(message: CreateExchangePairResponse): unknown {
    const obj: any = {};
    if (message.pair !== undefined) {
      obj.pair = ExchangePair.toJSON(message.pair);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateExchangePairResponse>, I>>(base?: I): CreateExchangePairResponse {
    return CreateExchangePairResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateExchangePairResponse>, I>>(object: I): CreateExchangePairResponse {
    const message = createBaseCreateExchangePairResponse();
    message.pair = (object.pair !== undefined && object.pair !== null)
      ? ExchangePair.fromPartial(object.pair)
      : undefined;
    return message;
  },
};

function createBaseCreateExchangeRateRequest(): CreateExchangeRateRequest {
  return { pairId: "", rate: 0, timestamp: undefined, metadata: undefined, campaignId: "0" };
}

export const CreateExchangeRateRequest: MessageFns<CreateExchangeRateRequest> = {
  encode(message: CreateExchangeRateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pairId !== "") {
      writer.uint32(10).string(message.pairId);
    }
    if (message.rate !== 0) {
      writer.uint32(17).double(message.rate);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExchangeRateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExchangeRateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pairId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.rate = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExchangeRateRequest {
    return {
      pairId: isSet(object.pairId) ? globalThis.String(object.pairId) : "",
      rate: isSet(object.rate) ? globalThis.Number(object.rate) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: CreateExchangeRateRequest): unknown {
    const obj: any = {};
    if (message.pairId !== "") {
      obj.pairId = message.pairId;
    }
    if (message.rate !== 0) {
      obj.rate = message.rate;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateExchangeRateRequest>, I>>(base?: I): CreateExchangeRateRequest {
    return CreateExchangeRateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateExchangeRateRequest>, I>>(object: I): CreateExchangeRateRequest {
    const message = createBaseCreateExchangeRateRequest();
    message.pairId = object.pairId ?? "";
    message.rate = object.rate ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCreateExchangeRateResponse(): CreateExchangeRateResponse {
  return { rate: undefined };
}

export const CreateExchangeRateResponse: MessageFns<CreateExchangeRateResponse> = {
  encode(message: CreateExchangeRateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rate !== undefined) {
      ExchangeRate.encode(message.rate, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExchangeRateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExchangeRateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rate = ExchangeRate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExchangeRateResponse {
    return { rate: isSet(object.rate) ? ExchangeRate.fromJSON(object.rate) : undefined };
  },

  toJSON(message: CreateExchangeRateResponse): unknown {
    const obj: any = {};
    if (message.rate !== undefined) {
      obj.rate = ExchangeRate.toJSON(message.rate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateExchangeRateResponse>, I>>(base?: I): CreateExchangeRateResponse {
    return CreateExchangeRateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateExchangeRateResponse>, I>>(object: I): CreateExchangeRateResponse {
    const message = createBaseCreateExchangeRateResponse();
    message.rate = (object.rate !== undefined && object.rate !== null)
      ? ExchangeRate.fromPartial(object.rate)
      : undefined;
    return message;
  },
};

export interface CommerceService {
  /** Quotes */
  CreateQuote(request: CreateQuoteRequest): Promise<CreateQuoteResponse>;
  GetQuote(request: GetQuoteRequest): Promise<GetQuoteResponse>;
  ListQuotes(request: ListQuotesRequest): Promise<ListQuotesResponse>;
  /** Orders */
  CreateOrder(request: CreateOrderRequest): Promise<CreateOrderResponse>;
  GetOrder(request: GetOrderRequest): Promise<GetOrderResponse>;
  ListOrders(request: ListOrdersRequest): Promise<ListOrdersResponse>;
  UpdateOrderStatus(request: UpdateOrderStatusRequest): Promise<UpdateOrderStatusResponse>;
  /** Payments */
  InitiatePayment(request: InitiatePaymentRequest): Promise<InitiatePaymentResponse>;
  ConfirmPayment(request: ConfirmPaymentRequest): Promise<ConfirmPaymentResponse>;
  RefundPayment(request: RefundPaymentRequest): Promise<RefundPaymentResponse>;
  /** Transactions */
  GetTransaction(request: GetTransactionRequest): Promise<GetTransactionResponse>;
  ListTransactions(request: ListTransactionsRequest): Promise<ListTransactionsResponse>;
  /** Balances */
  GetBalance(request: GetBalanceRequest): Promise<GetBalanceResponse>;
  ListBalances(request: ListBalancesRequest): Promise<ListBalancesResponse>;
  /** Events (for analytics/audit) */
  ListEvents(request: ListEventsRequest): Promise<ListEventsResponse>;
  /** Investment */
  CreateInvestmentAccount(request: CreateInvestmentAccountRequest): Promise<CreateInvestmentAccountResponse>;
  GetInvestmentAccount(request: GetInvestmentAccountRequest): Promise<GetInvestmentAccountResponse>;
  PlaceInvestmentOrder(request: PlaceInvestmentOrderRequest): Promise<PlaceInvestmentOrderResponse>;
  GetPortfolio(request: GetPortfolioRequest): Promise<GetPortfolioResponse>;
  ListAssets(request: ListAssetsRequest): Promise<ListAssetsResponse>;
  ListPortfolios(request: ListPortfoliosRequest): Promise<ListPortfoliosResponse>;
  /** Banking */
  CreateBankAccount(request: CreateBankAccountRequest): Promise<CreateBankAccountResponse>;
  InitiateBankTransfer(request: InitiateBankTransferRequest): Promise<InitiateBankTransferResponse>;
  GetBankStatement(request: GetBankStatementRequest): Promise<GetBankStatementResponse>;
  /** Marketplace */
  CreateListing(request: CreateListingRequest): Promise<CreateListingResponse>;
  PlaceMarketplaceOrder(request: PlaceMarketplaceOrderRequest): Promise<PlaceMarketplaceOrderResponse>;
  MakeOffer(request: MakeOfferRequest): Promise<MakeOfferResponse>;
  ListListings(request: ListListingsRequest): Promise<ListListingsResponse>;
  /** Exchange */
  PlaceExchangeOrder(request: PlaceExchangeOrderRequest): Promise<PlaceExchangeOrderResponse>;
  GetExchangeRate(request: GetExchangeRateRequest): Promise<GetExchangeRateResponse>;
  ListExchangePairs(request: ListExchangePairsRequest): Promise<ListExchangePairsResponse>;
  CreateExchangePair(request: CreateExchangePairRequest): Promise<CreateExchangePairResponse>;
  CreateExchangeRate(request: CreateExchangeRateRequest): Promise<CreateExchangeRateResponse>;
}

export const CommerceServiceServiceName = "commerce.v1.CommerceService";
export class CommerceServiceClientImpl implements CommerceService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || CommerceServiceServiceName;
    this.rpc = rpc;
    this.CreateQuote = this.CreateQuote.bind(this);
    this.GetQuote = this.GetQuote.bind(this);
    this.ListQuotes = this.ListQuotes.bind(this);
    this.CreateOrder = this.CreateOrder.bind(this);
    this.GetOrder = this.GetOrder.bind(this);
    this.ListOrders = this.ListOrders.bind(this);
    this.UpdateOrderStatus = this.UpdateOrderStatus.bind(this);
    this.InitiatePayment = this.InitiatePayment.bind(this);
    this.ConfirmPayment = this.ConfirmPayment.bind(this);
    this.RefundPayment = this.RefundPayment.bind(this);
    this.GetTransaction = this.GetTransaction.bind(this);
    this.ListTransactions = this.ListTransactions.bind(this);
    this.GetBalance = this.GetBalance.bind(this);
    this.ListBalances = this.ListBalances.bind(this);
    this.ListEvents = this.ListEvents.bind(this);
    this.CreateInvestmentAccount = this.CreateInvestmentAccount.bind(this);
    this.GetInvestmentAccount = this.GetInvestmentAccount.bind(this);
    this.PlaceInvestmentOrder = this.PlaceInvestmentOrder.bind(this);
    this.GetPortfolio = this.GetPortfolio.bind(this);
    this.ListAssets = this.ListAssets.bind(this);
    this.ListPortfolios = this.ListPortfolios.bind(this);
    this.CreateBankAccount = this.CreateBankAccount.bind(this);
    this.InitiateBankTransfer = this.InitiateBankTransfer.bind(this);
    this.GetBankStatement = this.GetBankStatement.bind(this);
    this.CreateListing = this.CreateListing.bind(this);
    this.PlaceMarketplaceOrder = this.PlaceMarketplaceOrder.bind(this);
    this.MakeOffer = this.MakeOffer.bind(this);
    this.ListListings = this.ListListings.bind(this);
    this.PlaceExchangeOrder = this.PlaceExchangeOrder.bind(this);
    this.GetExchangeRate = this.GetExchangeRate.bind(this);
    this.ListExchangePairs = this.ListExchangePairs.bind(this);
    this.CreateExchangePair = this.CreateExchangePair.bind(this);
    this.CreateExchangeRate = this.CreateExchangeRate.bind(this);
  }
  CreateQuote(request: CreateQuoteRequest): Promise<CreateQuoteResponse> {
    const data = CreateQuoteRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateQuote", data);
    return promise.then((data) => CreateQuoteResponse.decode(new BinaryReader(data)));
  }

  GetQuote(request: GetQuoteRequest): Promise<GetQuoteResponse> {
    const data = GetQuoteRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetQuote", data);
    return promise.then((data) => GetQuoteResponse.decode(new BinaryReader(data)));
  }

  ListQuotes(request: ListQuotesRequest): Promise<ListQuotesResponse> {
    const data = ListQuotesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListQuotes", data);
    return promise.then((data) => ListQuotesResponse.decode(new BinaryReader(data)));
  }

  CreateOrder(request: CreateOrderRequest): Promise<CreateOrderResponse> {
    const data = CreateOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOrder", data);
    return promise.then((data) => CreateOrderResponse.decode(new BinaryReader(data)));
  }

  GetOrder(request: GetOrderRequest): Promise<GetOrderResponse> {
    const data = GetOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOrder", data);
    return promise.then((data) => GetOrderResponse.decode(new BinaryReader(data)));
  }

  ListOrders(request: ListOrdersRequest): Promise<ListOrdersResponse> {
    const data = ListOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListOrders", data);
    return promise.then((data) => ListOrdersResponse.decode(new BinaryReader(data)));
  }

  UpdateOrderStatus(request: UpdateOrderStatusRequest): Promise<UpdateOrderStatusResponse> {
    const data = UpdateOrderStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateOrderStatus", data);
    return promise.then((data) => UpdateOrderStatusResponse.decode(new BinaryReader(data)));
  }

  InitiatePayment(request: InitiatePaymentRequest): Promise<InitiatePaymentResponse> {
    const data = InitiatePaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InitiatePayment", data);
    return promise.then((data) => InitiatePaymentResponse.decode(new BinaryReader(data)));
  }

  ConfirmPayment(request: ConfirmPaymentRequest): Promise<ConfirmPaymentResponse> {
    const data = ConfirmPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ConfirmPayment", data);
    return promise.then((data) => ConfirmPaymentResponse.decode(new BinaryReader(data)));
  }

  RefundPayment(request: RefundPaymentRequest): Promise<RefundPaymentResponse> {
    const data = RefundPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RefundPayment", data);
    return promise.then((data) => RefundPaymentResponse.decode(new BinaryReader(data)));
  }

  GetTransaction(request: GetTransactionRequest): Promise<GetTransactionResponse> {
    const data = GetTransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTransaction", data);
    return promise.then((data) => GetTransactionResponse.decode(new BinaryReader(data)));
  }

  ListTransactions(request: ListTransactionsRequest): Promise<ListTransactionsResponse> {
    const data = ListTransactionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListTransactions", data);
    return promise.then((data) => ListTransactionsResponse.decode(new BinaryReader(data)));
  }

  GetBalance(request: GetBalanceRequest): Promise<GetBalanceResponse> {
    const data = GetBalanceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBalance", data);
    return promise.then((data) => GetBalanceResponse.decode(new BinaryReader(data)));
  }

  ListBalances(request: ListBalancesRequest): Promise<ListBalancesResponse> {
    const data = ListBalancesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListBalances", data);
    return promise.then((data) => ListBalancesResponse.decode(new BinaryReader(data)));
  }

  ListEvents(request: ListEventsRequest): Promise<ListEventsResponse> {
    const data = ListEventsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListEvents", data);
    return promise.then((data) => ListEventsResponse.decode(new BinaryReader(data)));
  }

  CreateInvestmentAccount(request: CreateInvestmentAccountRequest): Promise<CreateInvestmentAccountResponse> {
    const data = CreateInvestmentAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateInvestmentAccount", data);
    return promise.then((data) => CreateInvestmentAccountResponse.decode(new BinaryReader(data)));
  }

  GetInvestmentAccount(request: GetInvestmentAccountRequest): Promise<GetInvestmentAccountResponse> {
    const data = GetInvestmentAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetInvestmentAccount", data);
    return promise.then((data) => GetInvestmentAccountResponse.decode(new BinaryReader(data)));
  }

  PlaceInvestmentOrder(request: PlaceInvestmentOrderRequest): Promise<PlaceInvestmentOrderResponse> {
    const data = PlaceInvestmentOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PlaceInvestmentOrder", data);
    return promise.then((data) => PlaceInvestmentOrderResponse.decode(new BinaryReader(data)));
  }

  GetPortfolio(request: GetPortfolioRequest): Promise<GetPortfolioResponse> {
    const data = GetPortfolioRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPortfolio", data);
    return promise.then((data) => GetPortfolioResponse.decode(new BinaryReader(data)));
  }

  ListAssets(request: ListAssetsRequest): Promise<ListAssetsResponse> {
    const data = ListAssetsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListAssets", data);
    return promise.then((data) => ListAssetsResponse.decode(new BinaryReader(data)));
  }

  ListPortfolios(request: ListPortfoliosRequest): Promise<ListPortfoliosResponse> {
    const data = ListPortfoliosRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListPortfolios", data);
    return promise.then((data) => ListPortfoliosResponse.decode(new BinaryReader(data)));
  }

  CreateBankAccount(request: CreateBankAccountRequest): Promise<CreateBankAccountResponse> {
    const data = CreateBankAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateBankAccount", data);
    return promise.then((data) => CreateBankAccountResponse.decode(new BinaryReader(data)));
  }

  InitiateBankTransfer(request: InitiateBankTransferRequest): Promise<InitiateBankTransferResponse> {
    const data = InitiateBankTransferRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InitiateBankTransfer", data);
    return promise.then((data) => InitiateBankTransferResponse.decode(new BinaryReader(data)));
  }

  GetBankStatement(request: GetBankStatementRequest): Promise<GetBankStatementResponse> {
    const data = GetBankStatementRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBankStatement", data);
    return promise.then((data) => GetBankStatementResponse.decode(new BinaryReader(data)));
  }

  CreateListing(request: CreateListingRequest): Promise<CreateListingResponse> {
    const data = CreateListingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateListing", data);
    return promise.then((data) => CreateListingResponse.decode(new BinaryReader(data)));
  }

  PlaceMarketplaceOrder(request: PlaceMarketplaceOrderRequest): Promise<PlaceMarketplaceOrderResponse> {
    const data = PlaceMarketplaceOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PlaceMarketplaceOrder", data);
    return promise.then((data) => PlaceMarketplaceOrderResponse.decode(new BinaryReader(data)));
  }

  MakeOffer(request: MakeOfferRequest): Promise<MakeOfferResponse> {
    const data = MakeOfferRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MakeOffer", data);
    return promise.then((data) => MakeOfferResponse.decode(new BinaryReader(data)));
  }

  ListListings(request: ListListingsRequest): Promise<ListListingsResponse> {
    const data = ListListingsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListListings", data);
    return promise.then((data) => ListListingsResponse.decode(new BinaryReader(data)));
  }

  PlaceExchangeOrder(request: PlaceExchangeOrderRequest): Promise<PlaceExchangeOrderResponse> {
    const data = PlaceExchangeOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PlaceExchangeOrder", data);
    return promise.then((data) => PlaceExchangeOrderResponse.decode(new BinaryReader(data)));
  }

  GetExchangeRate(request: GetExchangeRateRequest): Promise<GetExchangeRateResponse> {
    const data = GetExchangeRateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetExchangeRate", data);
    return promise.then((data) => GetExchangeRateResponse.decode(new BinaryReader(data)));
  }

  ListExchangePairs(request: ListExchangePairsRequest): Promise<ListExchangePairsResponse> {
    const data = ListExchangePairsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListExchangePairs", data);
    return promise.then((data) => ListExchangePairsResponse.decode(new BinaryReader(data)));
  }

  CreateExchangePair(request: CreateExchangePairRequest): Promise<CreateExchangePairResponse> {
    const data = CreateExchangePairRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateExchangePair", data);
    return promise.then((data) => CreateExchangePairResponse.decode(new BinaryReader(data)));
  }

  CreateExchangeRate(request: CreateExchangeRateRequest): Promise<CreateExchangeRateResponse> {
    const data = CreateExchangeRateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateExchangeRate", data);
    return promise.then((data) => CreateExchangeRateResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
