// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: scheduler/v1/scheduler.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Metadata } from "../../common/v1/metadata";

export const protobufPackage = "scheduler.v1";

export enum TriggerType {
  TRIGGER_TYPE_UNSPECIFIED = 0,
  TRIGGER_TYPE_CRON = 1,
  TRIGGER_TYPE_INTERVAL = 2,
  TRIGGER_TYPE_CDC = 3,
  UNRECOGNIZED = -1,
}

export function triggerTypeFromJSON(object: any): TriggerType {
  switch (object) {
    case 0:
    case "TRIGGER_TYPE_UNSPECIFIED":
      return TriggerType.TRIGGER_TYPE_UNSPECIFIED;
    case 1:
    case "TRIGGER_TYPE_CRON":
      return TriggerType.TRIGGER_TYPE_CRON;
    case 2:
    case "TRIGGER_TYPE_INTERVAL":
      return TriggerType.TRIGGER_TYPE_INTERVAL;
    case 3:
    case "TRIGGER_TYPE_CDC":
      return TriggerType.TRIGGER_TYPE_CDC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TriggerType.UNRECOGNIZED;
  }
}

export function triggerTypeToJSON(object: TriggerType): string {
  switch (object) {
    case TriggerType.TRIGGER_TYPE_UNSPECIFIED:
      return "TRIGGER_TYPE_UNSPECIFIED";
    case TriggerType.TRIGGER_TYPE_CRON:
      return "TRIGGER_TYPE_CRON";
    case TriggerType.TRIGGER_TYPE_INTERVAL:
      return "TRIGGER_TYPE_INTERVAL";
    case TriggerType.TRIGGER_TYPE_CDC:
      return "TRIGGER_TYPE_CDC";
    case TriggerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** JobType classifies the type of job for better filtering and handling. */
export enum JobType {
  JOB_TYPE_UNSPECIFIED = 0,
  JOB_TYPE_MAINTENANCE = 1,
  JOB_TYPE_CLEANUP = 2,
  JOB_TYPE_NOTIFY = 3,
  JOB_TYPE_CUSTOM = 4,
  UNRECOGNIZED = -1,
}

export function jobTypeFromJSON(object: any): JobType {
  switch (object) {
    case 0:
    case "JOB_TYPE_UNSPECIFIED":
      return JobType.JOB_TYPE_UNSPECIFIED;
    case 1:
    case "JOB_TYPE_MAINTENANCE":
      return JobType.JOB_TYPE_MAINTENANCE;
    case 2:
    case "JOB_TYPE_CLEANUP":
      return JobType.JOB_TYPE_CLEANUP;
    case 3:
    case "JOB_TYPE_NOTIFY":
      return JobType.JOB_TYPE_NOTIFY;
    case 4:
    case "JOB_TYPE_CUSTOM":
      return JobType.JOB_TYPE_CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobType.UNRECOGNIZED;
  }
}

export function jobTypeToJSON(object: JobType): string {
  switch (object) {
    case JobType.JOB_TYPE_UNSPECIFIED:
      return "JOB_TYPE_UNSPECIFIED";
    case JobType.JOB_TYPE_MAINTENANCE:
      return "JOB_TYPE_MAINTENANCE";
    case JobType.JOB_TYPE_CLEANUP:
      return "JOB_TYPE_CLEANUP";
    case JobType.JOB_TYPE_NOTIFY:
      return "JOB_TYPE_NOTIFY";
    case JobType.JOB_TYPE_CUSTOM:
      return "JOB_TYPE_CUSTOM";
    case JobType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** JobStatus provides canonical job status values. */
export enum JobStatus {
  JOB_STATUS_UNSPECIFIED = 0,
  JOB_STATUS_ACTIVE = 1,
  JOB_STATUS_PAUSED = 2,
  JOB_STATUS_DISABLED = 3,
  JOB_STATUS_COMPLETED = 4,
  JOB_STATUS_FAILED = 5,
  UNRECOGNIZED = -1,
}

export function jobStatusFromJSON(object: any): JobStatus {
  switch (object) {
    case 0:
    case "JOB_STATUS_UNSPECIFIED":
      return JobStatus.JOB_STATUS_UNSPECIFIED;
    case 1:
    case "JOB_STATUS_ACTIVE":
      return JobStatus.JOB_STATUS_ACTIVE;
    case 2:
    case "JOB_STATUS_PAUSED":
      return JobStatus.JOB_STATUS_PAUSED;
    case 3:
    case "JOB_STATUS_DISABLED":
      return JobStatus.JOB_STATUS_DISABLED;
    case 4:
    case "JOB_STATUS_COMPLETED":
      return JobStatus.JOB_STATUS_COMPLETED;
    case 5:
    case "JOB_STATUS_FAILED":
      return JobStatus.JOB_STATUS_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobStatus.UNRECOGNIZED;
  }
}

export function jobStatusToJSON(object: JobStatus): string {
  switch (object) {
    case JobStatus.JOB_STATUS_UNSPECIFIED:
      return "JOB_STATUS_UNSPECIFIED";
    case JobStatus.JOB_STATUS_ACTIVE:
      return "JOB_STATUS_ACTIVE";
    case JobStatus.JOB_STATUS_PAUSED:
      return "JOB_STATUS_PAUSED";
    case JobStatus.JOB_STATUS_DISABLED:
      return "JOB_STATUS_DISABLED";
    case JobStatus.JOB_STATUS_COMPLETED:
      return "JOB_STATUS_COMPLETED";
    case JobStatus.JOB_STATUS_FAILED:
      return "JOB_STATUS_FAILED";
    case JobStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RetryPolicy defines how failed jobs are retried. */
export interface RetryPolicy {
  /** Maximum number of retry attempts */
  maxAttempts: number;
  /** Backoff between retries in seconds */
  backoffSeconds: string;
  /** Use exponential backoff if true */
  exponential: boolean;
}

/** JobHistory tracks past runs for a job (optional, for future use). */
export interface JobHistory {
  runs: JobRun[];
}

/** CDCTrigger defines a change data capture trigger for event-based jobs. */
export interface CDCTrigger {
  /** Table to watch */
  table: string;
  /** insert, update, delete */
  eventType: string;
  /** e.g., JSONPath or SQL WHERE */
  filter: string;
}

/** Job represents a scheduled or event-driven job. */
export interface Job {
  /** Unique job ID */
  id: string;
  /** Human-readable job name */
  name: string;
  /** Cron or interval expression */
  schedule: string;
  /** Opaque payload for the job handler */
  payload: string;
  /** Canonical job status */
  status: JobStatus;
  /** Extensible metadata */
  metadata?:
    | Metadata
    | undefined;
  /** Last run ID */
  lastRunId: string;
  /** Creation timestamp (unix seconds) */
  createdAt: string;
  /** Last update timestamp (unix seconds) */
  updatedAt: string;
  /** How the job is triggered */
  triggerType: TriggerType;
  /** CDC trigger details (if event-based) */
  cdcTrigger?:
    | CDCTrigger
    | undefined;
  /** Classification of the job */
  jobType: JobType;
  /** Retry policy for failed jobs */
  retryPolicy?:
    | RetryPolicy
    | undefined;
  /** User or service that owns the job */
  owner: string;
  /** Next scheduled run (unix seconds) */
  nextRunTime: string;
  /** Arbitrary labels for filtering */
  labels: { [key: string]: string };
  /** (Optional) History of job runs */
  history?:
    | JobHistory
    | undefined;
  /** Master UUID */
  masterUuid: string;
  /** campaign/tenant context */
  campaignId: string;
}

export interface Job_LabelsEntry {
  key: string;
  value: string;
}

export interface CreateJobRequest {
  job?:
    | Job
    | undefined;
  /** campaign/tenant context */
  campaignId: string;
}

export interface CreateJobResponse {
  job?: Job | undefined;
}

export interface UpdateJobRequest {
  job?:
    | Job
    | undefined;
  /** campaign/tenant context */
  campaignId: string;
}

export interface UpdateJobResponse {
  job?: Job | undefined;
}

export interface DeleteJobRequest {
  jobId: string;
  /** campaign/tenant context */
  campaignId: string;
}

export interface DeleteJobResponse {
  success: boolean;
}

export interface ListJobsRequest {
  page: number;
  pageSize: number;
  status: string;
  /** campaign/tenant context */
  campaignId: string;
}

export interface ListJobsResponse {
  jobs: Job[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface GetJobRequest {
  jobId: string;
  /** campaign/tenant context */
  campaignId: string;
}

export interface GetJobResponse {
  job?: Job | undefined;
}

export interface RunJobRequest {
  jobId: string;
  /** campaign/tenant context */
  campaignId: string;
}

export interface RunJobResponse {
  run?: JobRun | undefined;
}

export interface ListJobRunsRequest {
  jobId: string;
  page: number;
  pageSize: number;
  /** campaign/tenant context */
  campaignId: string;
}

export interface ListJobRunsResponse {
  runs: JobRun[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface JobRun {
  id: string;
  jobId: string;
  startedAt: string;
  finishedAt: string;
  /** success, failed, running */
  status: string;
  result: string;
  error: string;
  metadata?:
    | Metadata
    | undefined;
  /** Master UUID */
  masterUuid: string;
  /** campaign/tenant context */
  campaignId: string;
}

function createBaseRetryPolicy(): RetryPolicy {
  return { maxAttempts: 0, backoffSeconds: "0", exponential: false };
}

export const RetryPolicy: MessageFns<RetryPolicy> = {
  encode(message: RetryPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxAttempts !== 0) {
      writer.uint32(8).int32(message.maxAttempts);
    }
    if (message.backoffSeconds !== "0") {
      writer.uint32(16).int64(message.backoffSeconds);
    }
    if (message.exponential !== false) {
      writer.uint32(24).bool(message.exponential);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxAttempts = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.backoffSeconds = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exponential = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPolicy {
    return {
      maxAttempts: isSet(object.maxAttempts) ? globalThis.Number(object.maxAttempts) : 0,
      backoffSeconds: isSet(object.backoffSeconds) ? globalThis.String(object.backoffSeconds) : "0",
      exponential: isSet(object.exponential) ? globalThis.Boolean(object.exponential) : false,
    };
  },

  toJSON(message: RetryPolicy): unknown {
    const obj: any = {};
    if (message.maxAttempts !== 0) {
      obj.maxAttempts = Math.round(message.maxAttempts);
    }
    if (message.backoffSeconds !== "0") {
      obj.backoffSeconds = message.backoffSeconds;
    }
    if (message.exponential !== false) {
      obj.exponential = message.exponential;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryPolicy>, I>>(base?: I): RetryPolicy {
    return RetryPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryPolicy>, I>>(object: I): RetryPolicy {
    const message = createBaseRetryPolicy();
    message.maxAttempts = object.maxAttempts ?? 0;
    message.backoffSeconds = object.backoffSeconds ?? "0";
    message.exponential = object.exponential ?? false;
    return message;
  },
};

function createBaseJobHistory(): JobHistory {
  return { runs: [] };
}

export const JobHistory: MessageFns<JobHistory> = {
  encode(message: JobHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runs) {
      JobRun.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runs.push(JobRun.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobHistory {
    return { runs: globalThis.Array.isArray(object?.runs) ? object.runs.map((e: any) => JobRun.fromJSON(e)) : [] };
  },

  toJSON(message: JobHistory): unknown {
    const obj: any = {};
    if (message.runs?.length) {
      obj.runs = message.runs.map((e) => JobRun.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JobHistory>, I>>(base?: I): JobHistory {
    return JobHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JobHistory>, I>>(object: I): JobHistory {
    const message = createBaseJobHistory();
    message.runs = object.runs?.map((e) => JobRun.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCDCTrigger(): CDCTrigger {
  return { table: "", eventType: "", filter: "" };
}

export const CDCTrigger: MessageFns<CDCTrigger> = {
  encode(message: CDCTrigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== "") {
      writer.uint32(10).string(message.table);
    }
    if (message.eventType !== "") {
      writer.uint32(18).string(message.eventType);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CDCTrigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCDCTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CDCTrigger {
    return {
      table: isSet(object.table) ? globalThis.String(object.table) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: CDCTrigger): unknown {
    const obj: any = {};
    if (message.table !== "") {
      obj.table = message.table;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CDCTrigger>, I>>(base?: I): CDCTrigger {
    return CDCTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CDCTrigger>, I>>(object: I): CDCTrigger {
    const message = createBaseCDCTrigger();
    message.table = object.table ?? "";
    message.eventType = object.eventType ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseJob(): Job {
  return {
    id: "",
    name: "",
    schedule: "",
    payload: "",
    status: 0,
    metadata: undefined,
    lastRunId: "",
    createdAt: "0",
    updatedAt: "0",
    triggerType: 0,
    cdcTrigger: undefined,
    jobType: 0,
    retryPolicy: undefined,
    owner: "",
    nextRunTime: "0",
    labels: {},
    history: undefined,
    masterUuid: "",
    campaignId: "0",
  };
}

export const Job: MessageFns<Job> = {
  encode(message: Job, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.schedule !== "") {
      writer.uint32(26).string(message.schedule);
    }
    if (message.payload !== "") {
      writer.uint32(34).string(message.payload);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.lastRunId !== "") {
      writer.uint32(58).string(message.lastRunId);
    }
    if (message.createdAt !== "0") {
      writer.uint32(64).int64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(72).int64(message.updatedAt);
    }
    if (message.triggerType !== 0) {
      writer.uint32(80).int32(message.triggerType);
    }
    if (message.cdcTrigger !== undefined) {
      CDCTrigger.encode(message.cdcTrigger, writer.uint32(90).fork()).join();
    }
    if (message.jobType !== 0) {
      writer.uint32(96).int32(message.jobType);
    }
    if (message.retryPolicy !== undefined) {
      RetryPolicy.encode(message.retryPolicy, writer.uint32(106).fork()).join();
    }
    if (message.owner !== "") {
      writer.uint32(114).string(message.owner);
    }
    if (message.nextRunTime !== "0") {
      writer.uint32(120).int64(message.nextRunTime);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Job_LabelsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.history !== undefined) {
      JobHistory.encode(message.history, writer.uint32(138).fork()).join();
    }
    if (message.masterUuid !== "") {
      writer.uint32(146).string(message.masterUuid);
    }
    if (message.campaignId !== "0") {
      writer.uint32(152).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lastRunId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.createdAt = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.updatedAt = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.triggerType = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.cdcTrigger = CDCTrigger.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.jobType = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.retryPolicy = RetryPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.nextRunTime = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          const entry16 = Job_LabelsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.labels[entry16.key] = entry16.value;
          }
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.history = JobHistory.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      status: isSet(object.status) ? jobStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      lastRunId: isSet(object.lastRunId) ? globalThis.String(object.lastRunId) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "0",
      triggerType: isSet(object.triggerType) ? triggerTypeFromJSON(object.triggerType) : 0,
      cdcTrigger: isSet(object.cdcTrigger) ? CDCTrigger.fromJSON(object.cdcTrigger) : undefined,
      jobType: isSet(object.jobType) ? jobTypeFromJSON(object.jobType) : 0,
      retryPolicy: isSet(object.retryPolicy) ? RetryPolicy.fromJSON(object.retryPolicy) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      nextRunTime: isSet(object.nextRunTime) ? globalThis.String(object.nextRunTime) : "0",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      history: isSet(object.history) ? JobHistory.fromJSON(object.history) : undefined,
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Job): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.status !== 0) {
      obj.status = jobStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.lastRunId !== "") {
      obj.lastRunId = message.lastRunId;
    }
    if (message.createdAt !== "0") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "0") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.triggerType !== 0) {
      obj.triggerType = triggerTypeToJSON(message.triggerType);
    }
    if (message.cdcTrigger !== undefined) {
      obj.cdcTrigger = CDCTrigger.toJSON(message.cdcTrigger);
    }
    if (message.jobType !== 0) {
      obj.jobType = jobTypeToJSON(message.jobType);
    }
    if (message.retryPolicy !== undefined) {
      obj.retryPolicy = RetryPolicy.toJSON(message.retryPolicy);
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.nextRunTime !== "0") {
      obj.nextRunTime = message.nextRunTime;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.history !== undefined) {
      obj.history = JobHistory.toJSON(message.history);
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Job>, I>>(base?: I): Job {
    return Job.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Job>, I>>(object: I): Job {
    const message = createBaseJob();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.schedule = object.schedule ?? "";
    message.payload = object.payload ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.lastRunId = object.lastRunId ?? "";
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    message.triggerType = object.triggerType ?? 0;
    message.cdcTrigger = (object.cdcTrigger !== undefined && object.cdcTrigger !== null)
      ? CDCTrigger.fromPartial(object.cdcTrigger)
      : undefined;
    message.jobType = object.jobType ?? 0;
    message.retryPolicy = (object.retryPolicy !== undefined && object.retryPolicy !== null)
      ? RetryPolicy.fromPartial(object.retryPolicy)
      : undefined;
    message.owner = object.owner ?? "";
    message.nextRunTime = object.nextRunTime ?? "0";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.history = (object.history !== undefined && object.history !== null)
      ? JobHistory.fromPartial(object.history)
      : undefined;
    message.masterUuid = object.masterUuid ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseJob_LabelsEntry(): Job_LabelsEntry {
  return { key: "", value: "" };
}

export const Job_LabelsEntry: MessageFns<Job_LabelsEntry> = {
  encode(message: Job_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Job_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Job_LabelsEntry>, I>>(base?: I): Job_LabelsEntry {
    return Job_LabelsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Job_LabelsEntry>, I>>(object: I): Job_LabelsEntry {
    const message = createBaseJob_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateJobRequest(): CreateJobRequest {
  return { job: undefined, campaignId: "0" };
}

export const CreateJobRequest: MessageFns<CreateJobRequest> = {
  encode(message: CreateJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateJobRequest {
    return {
      job: isSet(object.job) ? Job.fromJSON(object.job) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: CreateJobRequest): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateJobRequest>, I>>(base?: I): CreateJobRequest {
    return CreateJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateJobRequest>, I>>(object: I): CreateJobRequest {
    const message = createBaseCreateJobRequest();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseCreateJobResponse(): CreateJobResponse {
  return { job: undefined };
}

export const CreateJobResponse: MessageFns<CreateJobResponse> = {
  encode(message: CreateJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateJobResponse {
    return { job: isSet(object.job) ? Job.fromJSON(object.job) : undefined };
  },

  toJSON(message: CreateJobResponse): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateJobResponse>, I>>(base?: I): CreateJobResponse {
    return CreateJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateJobResponse>, I>>(object: I): CreateJobResponse {
    const message = createBaseCreateJobResponse();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    return message;
  },
};

function createBaseUpdateJobRequest(): UpdateJobRequest {
  return { job: undefined, campaignId: "0" };
}

export const UpdateJobRequest: MessageFns<UpdateJobRequest> = {
  encode(message: UpdateJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateJobRequest {
    return {
      job: isSet(object.job) ? Job.fromJSON(object.job) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: UpdateJobRequest): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateJobRequest>, I>>(base?: I): UpdateJobRequest {
    return UpdateJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateJobRequest>, I>>(object: I): UpdateJobRequest {
    const message = createBaseUpdateJobRequest();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseUpdateJobResponse(): UpdateJobResponse {
  return { job: undefined };
}

export const UpdateJobResponse: MessageFns<UpdateJobResponse> = {
  encode(message: UpdateJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateJobResponse {
    return { job: isSet(object.job) ? Job.fromJSON(object.job) : undefined };
  },

  toJSON(message: UpdateJobResponse): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateJobResponse>, I>>(base?: I): UpdateJobResponse {
    return UpdateJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateJobResponse>, I>>(object: I): UpdateJobResponse {
    const message = createBaseUpdateJobResponse();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    return message;
  },
};

function createBaseDeleteJobRequest(): DeleteJobRequest {
  return { jobId: "", campaignId: "0" };
}

export const DeleteJobRequest: MessageFns<DeleteJobRequest> = {
  encode(message: DeleteJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteJobRequest {
    return {
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: DeleteJobRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteJobRequest>, I>>(base?: I): DeleteJobRequest {
    return DeleteJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteJobRequest>, I>>(object: I): DeleteJobRequest {
    const message = createBaseDeleteJobRequest();
    message.jobId = object.jobId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseDeleteJobResponse(): DeleteJobResponse {
  return { success: false };
}

export const DeleteJobResponse: MessageFns<DeleteJobResponse> = {
  encode(message: DeleteJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteJobResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteJobResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteJobResponse>, I>>(base?: I): DeleteJobResponse {
    return DeleteJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteJobResponse>, I>>(object: I): DeleteJobResponse {
    const message = createBaseDeleteJobResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListJobsRequest(): ListJobsRequest {
  return { page: 0, pageSize: 0, status: "", campaignId: "0" };
}

export const ListJobsRequest: MessageFns<ListJobsRequest> = {
  encode(message: ListJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListJobsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListJobsRequest>, I>>(base?: I): ListJobsRequest {
    return ListJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListJobsRequest>, I>>(object: I): ListJobsRequest {
    const message = createBaseListJobsRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.status = object.status ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListJobsResponse(): ListJobsResponse {
  return { jobs: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListJobsResponse: MessageFns<ListJobsResponse> = {
  encode(message: ListJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      Job.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(Job.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobsResponse {
    return {
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => Job.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListJobsResponse): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => Job.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListJobsResponse>, I>>(base?: I): ListJobsResponse {
    return ListJobsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListJobsResponse>, I>>(object: I): ListJobsResponse {
    const message = createBaseListJobsResponse();
    message.jobs = object.jobs?.map((e) => Job.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseGetJobRequest(): GetJobRequest {
  return { jobId: "", campaignId: "0" };
}

export const GetJobRequest: MessageFns<GetJobRequest> = {
  encode(message: GetJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJobRequest {
    return {
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: GetJobRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJobRequest>, I>>(base?: I): GetJobRequest {
    return GetJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJobRequest>, I>>(object: I): GetJobRequest {
    const message = createBaseGetJobRequest();
    message.jobId = object.jobId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseGetJobResponse(): GetJobResponse {
  return { job: undefined };
}

export const GetJobResponse: MessageFns<GetJobResponse> = {
  encode(message: GetJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJobResponse {
    return { job: isSet(object.job) ? Job.fromJSON(object.job) : undefined };
  },

  toJSON(message: GetJobResponse): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJobResponse>, I>>(base?: I): GetJobResponse {
    return GetJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJobResponse>, I>>(object: I): GetJobResponse {
    const message = createBaseGetJobResponse();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    return message;
  },
};

function createBaseRunJobRequest(): RunJobRequest {
  return { jobId: "", campaignId: "0" };
}

export const RunJobRequest: MessageFns<RunJobRequest> = {
  encode(message: RunJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(16).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunJobRequest {
    return {
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: RunJobRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunJobRequest>, I>>(base?: I): RunJobRequest {
    return RunJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunJobRequest>, I>>(object: I): RunJobRequest {
    const message = createBaseRunJobRequest();
    message.jobId = object.jobId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseRunJobResponse(): RunJobResponse {
  return { run: undefined };
}

export const RunJobResponse: MessageFns<RunJobResponse> = {
  encode(message: RunJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.run !== undefined) {
      JobRun.encode(message.run, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.run = JobRun.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunJobResponse {
    return { run: isSet(object.run) ? JobRun.fromJSON(object.run) : undefined };
  },

  toJSON(message: RunJobResponse): unknown {
    const obj: any = {};
    if (message.run !== undefined) {
      obj.run = JobRun.toJSON(message.run);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunJobResponse>, I>>(base?: I): RunJobResponse {
    return RunJobResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunJobResponse>, I>>(object: I): RunJobResponse {
    const message = createBaseRunJobResponse();
    message.run = (object.run !== undefined && object.run !== null) ? JobRun.fromPartial(object.run) : undefined;
    return message;
  },
};

function createBaseListJobRunsRequest(): ListJobRunsRequest {
  return { jobId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const ListJobRunsRequest: MessageFns<ListJobRunsRequest> = {
  encode(message: ListJobRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobRunsRequest {
    return {
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListJobRunsRequest): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListJobRunsRequest>, I>>(base?: I): ListJobRunsRequest {
    return ListJobRunsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListJobRunsRequest>, I>>(object: I): ListJobRunsRequest {
    const message = createBaseListJobRunsRequest();
    message.jobId = object.jobId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListJobRunsResponse(): ListJobRunsResponse {
  return { runs: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListJobRunsResponse: MessageFns<ListJobRunsResponse> = {
  encode(message: ListJobRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runs) {
      JobRun.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runs.push(JobRun.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobRunsResponse {
    return {
      runs: globalThis.Array.isArray(object?.runs) ? object.runs.map((e: any) => JobRun.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListJobRunsResponse): unknown {
    const obj: any = {};
    if (message.runs?.length) {
      obj.runs = message.runs.map((e) => JobRun.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListJobRunsResponse>, I>>(base?: I): ListJobRunsResponse {
    return ListJobRunsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListJobRunsResponse>, I>>(object: I): ListJobRunsResponse {
    const message = createBaseListJobRunsResponse();
    message.runs = object.runs?.map((e) => JobRun.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseJobRun(): JobRun {
  return {
    id: "",
    jobId: "",
    startedAt: "0",
    finishedAt: "0",
    status: "",
    result: "",
    error: "",
    metadata: undefined,
    masterUuid: "",
    campaignId: "0",
  };
}

export const JobRun: MessageFns<JobRun> = {
  encode(message: JobRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.jobId !== "") {
      writer.uint32(18).string(message.jobId);
    }
    if (message.startedAt !== "0") {
      writer.uint32(24).int64(message.startedAt);
    }
    if (message.finishedAt !== "0") {
      writer.uint32(32).int64(message.finishedAt);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.result !== "") {
      writer.uint32(50).string(message.result);
    }
    if (message.error !== "") {
      writer.uint32(58).string(message.error);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    if (message.masterUuid !== "") {
      writer.uint32(74).string(message.masterUuid);
    }
    if (message.campaignId !== "0") {
      writer.uint32(80).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startedAt = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.finishedAt = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.result = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobRun {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      startedAt: isSet(object.startedAt) ? globalThis.String(object.startedAt) : "0",
      finishedAt: isSet(object.finishedAt) ? globalThis.String(object.finishedAt) : "0",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: JobRun): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.startedAt !== "0") {
      obj.startedAt = message.startedAt;
    }
    if (message.finishedAt !== "0") {
      obj.finishedAt = message.finishedAt;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JobRun>, I>>(base?: I): JobRun {
    return JobRun.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JobRun>, I>>(object: I): JobRun {
    const message = createBaseJobRun();
    message.id = object.id ?? "";
    message.jobId = object.jobId ?? "";
    message.startedAt = object.startedAt ?? "0";
    message.finishedAt = object.finishedAt ?? "0";
    message.status = object.status ?? "";
    message.result = object.result ?? "";
    message.error = object.error ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.masterUuid = object.masterUuid ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

export interface SchedulerService {
  CreateJob(request: CreateJobRequest): Promise<CreateJobResponse>;
  UpdateJob(request: UpdateJobRequest): Promise<UpdateJobResponse>;
  DeleteJob(request: DeleteJobRequest): Promise<DeleteJobResponse>;
  ListJobs(request: ListJobsRequest): Promise<ListJobsResponse>;
  GetJob(request: GetJobRequest): Promise<GetJobResponse>;
  RunJob(request: RunJobRequest): Promise<RunJobResponse>;
  ListJobRuns(request: ListJobRunsRequest): Promise<ListJobRunsResponse>;
}

export const SchedulerServiceServiceName = "scheduler.v1.SchedulerService";
export class SchedulerServiceClientImpl implements SchedulerService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || SchedulerServiceServiceName;
    this.rpc = rpc;
    this.CreateJob = this.CreateJob.bind(this);
    this.UpdateJob = this.UpdateJob.bind(this);
    this.DeleteJob = this.DeleteJob.bind(this);
    this.ListJobs = this.ListJobs.bind(this);
    this.GetJob = this.GetJob.bind(this);
    this.RunJob = this.RunJob.bind(this);
    this.ListJobRuns = this.ListJobRuns.bind(this);
  }
  CreateJob(request: CreateJobRequest): Promise<CreateJobResponse> {
    const data = CreateJobRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateJob", data);
    return promise.then((data) => CreateJobResponse.decode(new BinaryReader(data)));
  }

  UpdateJob(request: UpdateJobRequest): Promise<UpdateJobResponse> {
    const data = UpdateJobRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateJob", data);
    return promise.then((data) => UpdateJobResponse.decode(new BinaryReader(data)));
  }

  DeleteJob(request: DeleteJobRequest): Promise<DeleteJobResponse> {
    const data = DeleteJobRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteJob", data);
    return promise.then((data) => DeleteJobResponse.decode(new BinaryReader(data)));
  }

  ListJobs(request: ListJobsRequest): Promise<ListJobsResponse> {
    const data = ListJobsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListJobs", data);
    return promise.then((data) => ListJobsResponse.decode(new BinaryReader(data)));
  }

  GetJob(request: GetJobRequest): Promise<GetJobResponse> {
    const data = GetJobRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetJob", data);
    return promise.then((data) => GetJobResponse.decode(new BinaryReader(data)));
  }

  RunJob(request: RunJobRequest): Promise<RunJobResponse> {
    const data = RunJobRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RunJob", data);
    return promise.then((data) => RunJobResponse.decode(new BinaryReader(data)));
  }

  ListJobRuns(request: ListJobRunsRequest): Promise<ListJobRunsResponse> {
    const data = ListJobRunsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListJobRuns", data);
    return promise.then((data) => ListJobRunsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
