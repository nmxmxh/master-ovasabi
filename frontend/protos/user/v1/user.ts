// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: user/v1/user.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Metadata } from "../../common/v1/metadata";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "user.v1";

export enum UserStatus {
  USER_STATUS_UNSPECIFIED = 0,
  USER_STATUS_ACTIVE = 1,
  USER_STATUS_INACTIVE = 2,
  USER_STATUS_SUSPENDED = 3,
  USER_STATUS_PENDING = 4,
  UNRECOGNIZED = -1,
}

export function userStatusFromJSON(object: any): UserStatus {
  switch (object) {
    case 0:
    case "USER_STATUS_UNSPECIFIED":
      return UserStatus.USER_STATUS_UNSPECIFIED;
    case 1:
    case "USER_STATUS_ACTIVE":
      return UserStatus.USER_STATUS_ACTIVE;
    case 2:
    case "USER_STATUS_INACTIVE":
      return UserStatus.USER_STATUS_INACTIVE;
    case 3:
    case "USER_STATUS_SUSPENDED":
      return UserStatus.USER_STATUS_SUSPENDED;
    case 4:
    case "USER_STATUS_PENDING":
      return UserStatus.USER_STATUS_PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserStatus.UNRECOGNIZED;
  }
}

export function userStatusToJSON(object: UserStatus): string {
  switch (object) {
    case UserStatus.USER_STATUS_UNSPECIFIED:
      return "USER_STATUS_UNSPECIFIED";
    case UserStatus.USER_STATUS_ACTIVE:
      return "USER_STATUS_ACTIVE";
    case UserStatus.USER_STATUS_INACTIVE:
      return "USER_STATUS_INACTIVE";
    case UserStatus.USER_STATUS_SUSPENDED:
      return "USER_STATUS_SUSPENDED";
    case UserStatus.USER_STATUS_PENDING:
      return "USER_STATUS_PENDING";
    case UserStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FriendshipStatus {
  FRIENDSHIP_STATUS_UNSPECIFIED = 0,
  FRIENDSHIP_STATUS_PENDING = 1,
  FRIENDSHIP_STATUS_ACCEPTED = 2,
  FRIENDSHIP_STATUS_BLOCKED = 3,
  FRIENDSHIP_STATUS_REJECTED = 4,
  UNRECOGNIZED = -1,
}

export function friendshipStatusFromJSON(object: any): FriendshipStatus {
  switch (object) {
    case 0:
    case "FRIENDSHIP_STATUS_UNSPECIFIED":
      return FriendshipStatus.FRIENDSHIP_STATUS_UNSPECIFIED;
    case 1:
    case "FRIENDSHIP_STATUS_PENDING":
      return FriendshipStatus.FRIENDSHIP_STATUS_PENDING;
    case 2:
    case "FRIENDSHIP_STATUS_ACCEPTED":
      return FriendshipStatus.FRIENDSHIP_STATUS_ACCEPTED;
    case 3:
    case "FRIENDSHIP_STATUS_BLOCKED":
      return FriendshipStatus.FRIENDSHIP_STATUS_BLOCKED;
    case 4:
    case "FRIENDSHIP_STATUS_REJECTED":
      return FriendshipStatus.FRIENDSHIP_STATUS_REJECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FriendshipStatus.UNRECOGNIZED;
  }
}

export function friendshipStatusToJSON(object: FriendshipStatus): string {
  switch (object) {
    case FriendshipStatus.FRIENDSHIP_STATUS_UNSPECIFIED:
      return "FRIENDSHIP_STATUS_UNSPECIFIED";
    case FriendshipStatus.FRIENDSHIP_STATUS_PENDING:
      return "FRIENDSHIP_STATUS_PENDING";
    case FriendshipStatus.FRIENDSHIP_STATUS_ACCEPTED:
      return "FRIENDSHIP_STATUS_ACCEPTED";
    case FriendshipStatus.FRIENDSHIP_STATUS_BLOCKED:
      return "FRIENDSHIP_STATUS_BLOCKED";
    case FriendshipStatus.FRIENDSHIP_STATUS_REJECTED:
      return "FRIENDSHIP_STATUS_REJECTED";
    case FriendshipStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FollowStatus {
  FOLLOW_STATUS_UNSPECIFIED = 0,
  FOLLOW_STATUS_ACTIVE = 1,
  FOLLOW_STATUS_BLOCKED = 2,
  UNRECOGNIZED = -1,
}

export function followStatusFromJSON(object: any): FollowStatus {
  switch (object) {
    case 0:
    case "FOLLOW_STATUS_UNSPECIFIED":
      return FollowStatus.FOLLOW_STATUS_UNSPECIFIED;
    case 1:
    case "FOLLOW_STATUS_ACTIVE":
      return FollowStatus.FOLLOW_STATUS_ACTIVE;
    case 2:
    case "FOLLOW_STATUS_BLOCKED":
      return FollowStatus.FOLLOW_STATUS_BLOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FollowStatus.UNRECOGNIZED;
  }
}

export function followStatusToJSON(object: FollowStatus): string {
  switch (object) {
    case FollowStatus.FOLLOW_STATUS_UNSPECIFIED:
      return "FOLLOW_STATUS_UNSPECIFIED";
    case FollowStatus.FOLLOW_STATUS_ACTIVE:
      return "FOLLOW_STATUS_ACTIVE";
    case FollowStatus.FOLLOW_STATUS_BLOCKED:
      return "FOLLOW_STATUS_BLOCKED";
    case FollowStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface User {
  /** UUID */
  id: string;
  /** Internal integer ID for analytics/unified queries */
  masterId: string;
  /** Global UUID for external APIs and global uniqueness */
  masterUuid: string;
  username: string;
  email: string;
  referralCode: string;
  referredBy: string;
  deviceHash: string;
  /** External user ID */
  userId: string;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  passwordHash: string;
  metadata?: Metadata | undefined;
  profile?: UserProfile | undefined;
  roles: string[];
  status: UserStatus;
  tags: string[];
  externalIds: { [key: string]: string };
  locations: string[];
  /** --- Social graph fields --- */
  userGroupIds: string[];
  friendIds: string[];
  followerIds: string[];
  followingIds: string[];
}

export interface User_ExternalIdsEntry {
  key: string;
  value: string;
}

export interface UserProfile {
  firstName: string;
  lastName: string;
  phoneNumber: string;
  avatarUrl: string;
  bio: string;
  timezone: string;
  language: string;
  customFields: { [key: string]: string };
}

export interface UserProfile_CustomFieldsEntry {
  key: string;
  value: string;
}

/**
 * --- Social Entities ---
 * UserGroup: Identity/social group for membership, RBAC, and social graph.
 */
export interface UserGroup {
  id: string;
  name: string;
  description: string;
  memberIds: string[];
  /** user_id -> role (admin, member, etc.) */
  roles: { [key: string]: string };
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
}

export interface UserGroup_RolesEntry {
  key: string;
  value: string;
}

export interface Friendship {
  id: string;
  userId: string;
  friendId: string;
  status: FriendshipStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
}

export interface Follow {
  id: string;
  followerId: string;
  followeeId: string;
  status: FollowStatus;
  metadata?: Metadata | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
}

/**
 * --- Requests/Responses ---
 * User CRUD
 */
export interface CreateUserRequest {
  username: string;
  email: string;
  password: string;
  profile?: UserProfile | undefined;
  roles: string[];
  metadata?: Metadata | undefined;
}

export interface CreateUserResponse {
  user?: User | undefined;
}

export interface GetUserRequest {
  userId: string;
}

export interface GetUserResponse {
  user?: User | undefined;
}

export interface GetUserByUsernameRequest {
  username: string;
}

export interface GetUserByUsernameResponse {
  user?: User | undefined;
}

export interface GetUserByEmailRequest {
  email: string;
}

export interface GetUserByEmailResponse {
  user?: User | undefined;
}

export interface UpdateUserRequest {
  userId: string;
  user?: User | undefined;
  fieldsToUpdates: string[];
  metadata?: Metadata | undefined;
}

export interface UpdateUserResponse {
  user?: User | undefined;
}

export interface DeleteUserRequest {
  userId: string;
  hardDelete: boolean;
  metadata?: Metadata | undefined;
}

export interface DeleteUserResponse {
  success: boolean;
}

export interface ListUsersRequest {
  page: number;
  pageSize: number;
  sortBy: string;
  sortDesc: boolean;
  filters?: Metadata | undefined;
  searchQuery: string;
  tags: string[];
  metadata?: Metadata | undefined;
}

export interface ListUsersResponse {
  users: User[];
  totalCount: number;
  page: number;
  totalPages: number;
}

/** Password/Profile */
export interface UpdatePasswordRequest {
  userId: string;
  currentPassword: string;
  newPassword: string;
}

export interface UpdatePasswordResponse {
  success: boolean;
  updatedAt: string;
}

export interface UpdateProfileRequest {
  userId: string;
  profile?: UserProfile | undefined;
  fieldsToUpdates: string[];
}

export interface UpdateProfileResponse {
  user?: User | undefined;
}

/** Session */
export interface CreateSessionRequest {
  userId: string;
  password: string;
  deviceInfo: string;
}

export interface CreateSessionResponse {
  session?: Session | undefined;
}

export interface GetSessionRequest {
  sessionId: string;
}

export interface GetSessionResponse {
  session?: Session | undefined;
}

export interface RevokeSessionRequest {
  sessionId: string;
}

export interface RevokeSessionResponse {
  success: boolean;
}

export interface ListSessionsRequest {
  userId: string;
}

export interface ListSessionsResponse {
  sessions: Session[];
}

export interface Session {
  id: string;
  userId: string;
  deviceInfo: string;
  createdAt?: Date | undefined;
  expiresAt?: Date | undefined;
  refreshToken: string;
  accessToken: string;
  ipAddress: string;
  metadata?: Metadata | undefined;
}

/** RBAC */
export interface AssignRoleRequest {
  userId: string;
  role: string;
}

export interface AssignRoleResponse {
  success: boolean;
}

export interface RemoveRoleRequest {
  userId: string;
  role: string;
}

export interface RemoveRoleResponse {
  success: boolean;
}

export interface ListRolesRequest {
  userId: string;
}

export interface ListRolesResponse {
  roles: string[];
}

export interface ListPermissionsRequest {
  userId: string;
}

export interface ListPermissionsResponse {
  permissions: string[];
}

/** Audit/Event */
export interface ListUserEventsRequest {
  userId: string;
  page: number;
  pageSize: number;
}

export interface ListUserEventsResponse {
  events: UserEvent[];
  totalCount: number;
}

export interface ListAuditLogsRequest {
  userId: string;
  page: number;
  pageSize: number;
}

export interface ListAuditLogsResponse {
  logs: AuditLog[];
  totalCount: number;
}

export interface UserEvent {
  id: string;
  masterId: string;
  masterUuid: string;
  userId: string;
  eventType: string;
  description: string;
  occurredAt?: Date | undefined;
  metadata?: Metadata | undefined;
  payload: { [key: string]: string };
}

export interface UserEvent_PayloadEntry {
  key: string;
  value: string;
}

export interface AuditLog {
  id: string;
  masterId: string;
  masterUuid: string;
  userId: string;
  action: string;
  resource: string;
  occurredAt?: Date | undefined;
  metadata?: Metadata | undefined;
  payload: { [key: string]: string };
}

export interface AuditLog_PayloadEntry {
  key: string;
  value: string;
}

/** SSO/MFA/SCIM */
export interface InitiateSSORequest {
  provider: string;
  redirectUri: string;
}

export interface InitiateSSOResponse {
  ssoUrl: string;
}

export interface InitiateMFARequest {
  userId: string;
  mfaType: string;
}

export interface InitiateMFAResponse {
  initiated: boolean;
  challengeId: string;
}

export interface SyncSCIMRequest {
  scimPayload: string;
}

export interface SyncSCIMResponse {
  success: boolean;
}

/** Social Graph */
export interface AddFriendRequest {
  userId: string;
  friendId: string;
  metadata?: Metadata | undefined;
}

export interface AddFriendResponse {
  friendship?: Friendship | undefined;
}

export interface RemoveFriendRequest {
  userId: string;
  friendId: string;
  metadata?: Metadata | undefined;
}

export interface RemoveFriendResponse {
  success: boolean;
}

export interface ListFriendsRequest {
  userId: string;
  page: number;
  pageSize: number;
  metadata?: Metadata | undefined;
}

export interface ListFriendsResponse {
  friends: User[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface FollowUserRequest {
  followerId: string;
  followeeId: string;
  metadata?: Metadata | undefined;
}

export interface FollowUserResponse {
  follow?: Follow | undefined;
}

export interface UnfollowUserRequest {
  followerId: string;
  followeeId: string;
  metadata?: Metadata | undefined;
}

export interface UnfollowUserResponse {
  success: boolean;
}

export interface ListFollowersRequest {
  userId: string;
  page: number;
  pageSize: number;
  metadata?: Metadata | undefined;
}

export interface ListFollowersResponse {
  followers: User[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface ListFollowingRequest {
  userId: string;
  page: number;
  pageSize: number;
  metadata?: Metadata | undefined;
}

export interface ListFollowingResponse {
  followings: User[];
  totalCount: number;
  page: number;
  totalPages: number;
}

/** Groups */
export interface CreateUserGroupRequest {
  name: string;
  description: string;
  memberIds: string[];
  roles: { [key: string]: string };
  metadata?: Metadata | undefined;
}

export interface CreateUserGroupRequest_RolesEntry {
  key: string;
  value: string;
}

export interface CreateUserGroupResponse {
  userGroup?: UserGroup | undefined;
}

export interface UpdateUserGroupRequest {
  userGroupId: string;
  userGroup?: UserGroup | undefined;
  fieldsToUpdates: string[];
  metadata?: Metadata | undefined;
}

export interface UpdateUserGroupResponse {
  userGroup?: UserGroup | undefined;
}

export interface DeleteUserGroupRequest {
  userGroupId: string;
  metadata?: Metadata | undefined;
}

export interface DeleteUserGroupResponse {
  success: boolean;
}

export interface ListUserGroupsRequest {
  userId: string;
  page: number;
  pageSize: number;
  metadata?: Metadata | undefined;
}

export interface ListUserGroupsResponse {
  userGroups: UserGroup[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface ListUserGroupMembersRequest {
  userGroupId: string;
  page: number;
  pageSize: number;
  metadata?: Metadata | undefined;
}

export interface ListUserGroupMembersResponse {
  members: User[];
  totalCount: number;
  page: number;
  totalPages: number;
}

/** Social Graph Discovery */
export interface SuggestConnectionsRequest {
  userId: string;
  metadata?: Metadata | undefined;
}

export interface SuggestConnectionsResponse {
  suggestions: User[];
}

export interface ListConnectionsRequest {
  userId: string;
  type: string;
  metadata?: Metadata | undefined;
}

export interface ListConnectionsResponse {
  users: User[];
}

/** Moderation/Interaction APIs */
export interface BlockUserRequest {
  /** The user performing the block */
  userId: string;
  /** The user being blocked */
  targetUserId: string;
  metadata?: Metadata | undefined;
}

export interface BlockUserResponse {
  success: boolean;
}

export interface UnblockUserRequest {
  targetUserId: string;
}

export interface UnblockUserResponse {
  success: boolean;
}

export interface MuteUserRequest {
  userId: string;
  targetUserId: string;
  /** Optional: mute duration */
  durationMinutes: number;
  metadata?: Metadata | undefined;
}

export interface MuteUserResponse {
  success: boolean;
}

export interface UnmuteUserRequest {
  targetUserId: string;
}

export interface UnmuteUserResponse {
  success: boolean;
}

export interface ReportUserRequest {
  reporterUserId: string;
  reportedUserId: string;
  reason: string;
  details: string;
  metadata?: Metadata | undefined;
}

export interface ReportUserResponse {
  success: boolean;
  reportId: string;
}

/** Group/content moderation */
export interface BlockGroupContentRequest {
  userId: string;
  groupId: string;
  contentId: string;
  metadata?: Metadata | undefined;
}

export interface BlockGroupContentResponse {
  success: boolean;
}

export interface ReportGroupContentRequest {
  reporterUserId: string;
  groupId: string;
  contentId: string;
  reason: string;
  details: string;
  metadata?: Metadata | undefined;
}

export interface ReportGroupContentResponse {
  success: boolean;
  reportId: string;
}

export interface MuteGroupContentRequest {
  userId: string;
  groupId: string;
  contentId: string;
  durationMinutes: number;
  metadata?: Metadata | undefined;
}

export interface MuteGroupContentResponse {
  success: boolean;
}

/** Mute all members of a group for a user (optionally, with a duration) */
export interface MuteGroupIndividualsRequest {
  userId: string;
  groupId: string;
  durationMinutes: number;
  metadata?: Metadata | undefined;
}

export interface MuteGroupIndividualsResponse {
  success: boolean;
  mutedUserIds: string[];
}

export interface BlockGroupIndividualsRequest {
  userId: string;
  groupId: string;
  durationMinutes: number;
  metadata?: Metadata | undefined;
}

export interface BlockGroupIndividualsResponse {
  success: boolean;
  blockedUserIds: string[];
}

export interface UnmuteGroupRequest {
  userId: string;
  groupId: string;
}

export interface UnmuteGroupResponse {
  success: boolean;
}

export interface UnmuteGroupIndividualsRequest {
  userId: string;
  groupId: string;
  targetUserIds: string[];
}

export interface UnmuteGroupIndividualsResponse {
  success: boolean;
  unmutedUserIds: string[];
}

export interface UnblockGroupIndividualsRequest {
  userId: string;
  groupId: string;
  targetUserIds: string[];
}

export interface UnblockGroupIndividualsResponse {
  success: boolean;
  unblockedUserIds: string[];
}

export interface RegisterInterestRequest {
  email: string;
}

export interface RegisterInterestResponse {
  user?: User | undefined;
}

export interface CreateReferralRequest {
  userId: string;
  campaignSlug: string;
}

export interface CreateReferralResponse {
  referralCode: string;
  success: boolean;
}

export interface RefreshSessionRequest {
  refreshToken: string;
}

export interface RefreshSessionResponse {
  refreshToken: string;
  accessToken: string;
}

function createBaseUser(): User {
  return {
    id: "",
    masterId: "0",
    masterUuid: "",
    username: "",
    email: "",
    referralCode: "",
    referredBy: "",
    deviceHash: "",
    userId: "",
    createdAt: undefined,
    updatedAt: undefined,
    passwordHash: "",
    metadata: undefined,
    profile: undefined,
    roles: [],
    status: 0,
    tags: [],
    externalIds: {},
    locations: [],
    userGroupIds: [],
    friendIds: [],
    followerIds: [],
    followingIds: [],
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.masterId !== "0") {
      writer.uint32(16).int64(message.masterId);
    }
    if (message.masterUuid !== "") {
      writer.uint32(26).string(message.masterUuid);
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(42).string(message.email);
    }
    if (message.referralCode !== "") {
      writer.uint32(50).string(message.referralCode);
    }
    if (message.referredBy !== "") {
      writer.uint32(58).string(message.referredBy);
    }
    if (message.deviceHash !== "") {
      writer.uint32(66).string(message.deviceHash);
    }
    if (message.userId !== "") {
      writer.uint32(74).string(message.userId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(90).fork()).join();
    }
    if (message.passwordHash !== "") {
      writer.uint32(98).string(message.passwordHash);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(106).fork()).join();
    }
    if (message.profile !== undefined) {
      UserProfile.encode(message.profile, writer.uint32(114).fork()).join();
    }
    for (const v of message.roles) {
      writer.uint32(122).string(v!);
    }
    if (message.status !== 0) {
      writer.uint32(128).int32(message.status);
    }
    for (const v of message.tags) {
      writer.uint32(138).string(v!);
    }
    Object.entries(message.externalIds).forEach(([key, value]) => {
      User_ExternalIdsEntry.encode({ key: key as any, value }, writer.uint32(146).fork()).join();
    });
    for (const v of message.locations) {
      writer.uint32(154).string(v!);
    }
    for (const v of message.userGroupIds) {
      writer.uint32(242).string(v!);
    }
    for (const v of message.friendIds) {
      writer.uint32(250).string(v!);
    }
    for (const v of message.followerIds) {
      writer.uint32(258).string(v!);
    }
    for (const v of message.followingIds) {
      writer.uint32(266).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.masterId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.referralCode = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.referredBy = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.deviceHash = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.passwordHash = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.profile = UserProfile.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          const entry18 = User_ExternalIdsEntry.decode(reader, reader.uint32());
          if (entry18.value !== undefined) {
            message.externalIds[entry18.key] = entry18.value;
          }
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.locations.push(reader.string());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.userGroupIds.push(reader.string());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.friendIds.push(reader.string());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.followerIds.push(reader.string());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.followingIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      masterId: isSet(object.masterId) ? globalThis.String(object.masterId) : "0",
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      referralCode: isSet(object.referralCode) ? globalThis.String(object.referralCode) : "",
      referredBy: isSet(object.referredBy) ? globalThis.String(object.referredBy) : "",
      deviceHash: isSet(object.deviceHash) ? globalThis.String(object.deviceHash) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      passwordHash: isSet(object.passwordHash) ? globalThis.String(object.passwordHash) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      profile: isSet(object.profile) ? UserProfile.fromJSON(object.profile) : undefined,
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => globalThis.String(e)) : [],
      status: isSet(object.status) ? userStatusFromJSON(object.status) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      externalIds: isObject(object.externalIds)
        ? Object.entries(object.externalIds).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => globalThis.String(e))
        : [],
      userGroupIds: globalThis.Array.isArray(object?.userGroupIds)
        ? object.userGroupIds.map((e: any) => globalThis.String(e))
        : [],
      friendIds: globalThis.Array.isArray(object?.friendIds)
        ? object.friendIds.map((e: any) => globalThis.String(e))
        : [],
      followerIds: globalThis.Array.isArray(object?.followerIds)
        ? object.followerIds.map((e: any) => globalThis.String(e))
        : [],
      followingIds: globalThis.Array.isArray(object?.followingIds)
        ? object.followingIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.masterId !== "0") {
      obj.masterId = message.masterId;
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.referralCode !== "") {
      obj.referralCode = message.referralCode;
    }
    if (message.referredBy !== "") {
      obj.referredBy = message.referredBy;
    }
    if (message.deviceHash !== "") {
      obj.deviceHash = message.deviceHash;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.passwordHash !== "") {
      obj.passwordHash = message.passwordHash;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.profile !== undefined) {
      obj.profile = UserProfile.toJSON(message.profile);
    }
    if (message.roles?.length) {
      obj.roles = message.roles;
    }
    if (message.status !== 0) {
      obj.status = userStatusToJSON(message.status);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.externalIds) {
      const entries = Object.entries(message.externalIds);
      if (entries.length > 0) {
        obj.externalIds = {};
        entries.forEach(([k, v]) => {
          obj.externalIds[k] = v;
        });
      }
    }
    if (message.locations?.length) {
      obj.locations = message.locations;
    }
    if (message.userGroupIds?.length) {
      obj.userGroupIds = message.userGroupIds;
    }
    if (message.friendIds?.length) {
      obj.friendIds = message.friendIds;
    }
    if (message.followerIds?.length) {
      obj.followerIds = message.followerIds;
    }
    if (message.followingIds?.length) {
      obj.followingIds = message.followingIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.masterId = object.masterId ?? "0";
    message.masterUuid = object.masterUuid ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.referralCode = object.referralCode ?? "";
    message.referredBy = object.referredBy ?? "";
    message.deviceHash = object.deviceHash ?? "";
    message.userId = object.userId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.passwordHash = object.passwordHash ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? UserProfile.fromPartial(object.profile)
      : undefined;
    message.roles = object.roles?.map((e) => e) || [];
    message.status = object.status ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.externalIds = Object.entries(object.externalIds ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.locations = object.locations?.map((e) => e) || [];
    message.userGroupIds = object.userGroupIds?.map((e) => e) || [];
    message.friendIds = object.friendIds?.map((e) => e) || [];
    message.followerIds = object.followerIds?.map((e) => e) || [];
    message.followingIds = object.followingIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUser_ExternalIdsEntry(): User_ExternalIdsEntry {
  return { key: "", value: "" };
}

export const User_ExternalIdsEntry: MessageFns<User_ExternalIdsEntry> = {
  encode(message: User_ExternalIdsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User_ExternalIdsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_ExternalIdsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User_ExternalIdsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: User_ExternalIdsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User_ExternalIdsEntry>, I>>(base?: I): User_ExternalIdsEntry {
    return User_ExternalIdsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User_ExternalIdsEntry>, I>>(object: I): User_ExternalIdsEntry {
    const message = createBaseUser_ExternalIdsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUserProfile(): UserProfile {
  return {
    firstName: "",
    lastName: "",
    phoneNumber: "",
    avatarUrl: "",
    bio: "",
    timezone: "",
    language: "",
    customFields: {},
  };
}

export const UserProfile: MessageFns<UserProfile> = {
  encode(message: UserProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstName !== "") {
      writer.uint32(10).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(18).string(message.lastName);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(26).string(message.phoneNumber);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(34).string(message.avatarUrl);
    }
    if (message.bio !== "") {
      writer.uint32(42).string(message.bio);
    }
    if (message.timezone !== "") {
      writer.uint32(58).string(message.timezone);
    }
    if (message.language !== "") {
      writer.uint32(66).string(message.language);
    }
    Object.entries(message.customFields).forEach(([key, value]) => {
      UserProfile_CustomFieldsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bio = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = UserProfile_CustomFieldsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.customFields[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile {
    return {
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "",
      bio: isSet(object.bio) ? globalThis.String(object.bio) : "",
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      customFields: isObject(object.customFields)
        ? Object.entries(object.customFields).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UserProfile): unknown {
    const obj: any = {};
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.bio !== "") {
      obj.bio = message.bio;
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.customFields) {
      const entries = Object.entries(message.customFields);
      if (entries.length > 0) {
        obj.customFields = {};
        entries.forEach(([k, v]) => {
          obj.customFields[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfile>, I>>(base?: I): UserProfile {
    return UserProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfile>, I>>(object: I): UserProfile {
    const message = createBaseUserProfile();
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.phoneNumber = object.phoneNumber ?? "";
    message.avatarUrl = object.avatarUrl ?? "";
    message.bio = object.bio ?? "";
    message.timezone = object.timezone ?? "";
    message.language = object.language ?? "";
    message.customFields = Object.entries(object.customFields ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUserProfile_CustomFieldsEntry(): UserProfile_CustomFieldsEntry {
  return { key: "", value: "" };
}

export const UserProfile_CustomFieldsEntry: MessageFns<UserProfile_CustomFieldsEntry> = {
  encode(message: UserProfile_CustomFieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfile_CustomFieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile_CustomFieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile_CustomFieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UserProfile_CustomFieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfile_CustomFieldsEntry>, I>>(base?: I): UserProfile_CustomFieldsEntry {
    return UserProfile_CustomFieldsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfile_CustomFieldsEntry>, I>>(
    object: I,
  ): UserProfile_CustomFieldsEntry {
    const message = createBaseUserProfile_CustomFieldsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUserGroup(): UserGroup {
  return {
    id: "",
    name: "",
    description: "",
    memberIds: [],
    roles: {},
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const UserGroup: MessageFns<UserGroup> = {
  encode(message: UserGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.memberIds) {
      writer.uint32(34).string(v!);
    }
    Object.entries(message.roles).forEach(([key, value]) => {
      UserGroup_RolesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.memberIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = UserGroup_RolesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.roles[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserGroup {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      memberIds: globalThis.Array.isArray(object?.memberIds)
        ? object.memberIds.map((e: any) => globalThis.String(e))
        : [],
      roles: isObject(object.roles)
        ? Object.entries(object.roles).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: UserGroup): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.memberIds?.length) {
      obj.memberIds = message.memberIds;
    }
    if (message.roles) {
      const entries = Object.entries(message.roles);
      if (entries.length > 0) {
        obj.roles = {};
        entries.forEach(([k, v]) => {
          obj.roles[k] = v;
        });
      }
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserGroup>, I>>(base?: I): UserGroup {
    return UserGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserGroup>, I>>(object: I): UserGroup {
    const message = createBaseUserGroup();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.memberIds = object.memberIds?.map((e) => e) || [];
    message.roles = Object.entries(object.roles ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseUserGroup_RolesEntry(): UserGroup_RolesEntry {
  return { key: "", value: "" };
}

export const UserGroup_RolesEntry: MessageFns<UserGroup_RolesEntry> = {
  encode(message: UserGroup_RolesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserGroup_RolesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserGroup_RolesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserGroup_RolesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UserGroup_RolesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserGroup_RolesEntry>, I>>(base?: I): UserGroup_RolesEntry {
    return UserGroup_RolesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserGroup_RolesEntry>, I>>(object: I): UserGroup_RolesEntry {
    const message = createBaseUserGroup_RolesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFriendship(): Friendship {
  return {
    id: "",
    userId: "",
    friendId: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const Friendship: MessageFns<Friendship> = {
  encode(message: Friendship, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.friendId !== "") {
      writer.uint32(26).string(message.friendId);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Friendship {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFriendship();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.friendId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Friendship {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      friendId: isSet(object.friendId) ? globalThis.String(object.friendId) : "",
      status: isSet(object.status) ? friendshipStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Friendship): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.friendId !== "") {
      obj.friendId = message.friendId;
    }
    if (message.status !== 0) {
      obj.status = friendshipStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Friendship>, I>>(base?: I): Friendship {
    return Friendship.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Friendship>, I>>(object: I): Friendship {
    const message = createBaseFriendship();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.friendId = object.friendId ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseFollow(): Follow {
  return {
    id: "",
    followerId: "",
    followeeId: "",
    status: 0,
    metadata: undefined,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const Follow: MessageFns<Follow> = {
  encode(message: Follow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.followerId !== "") {
      writer.uint32(18).string(message.followerId);
    }
    if (message.followeeId !== "") {
      writer.uint32(26).string(message.followeeId);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Follow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFollow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.followerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.followeeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Follow {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      followerId: isSet(object.followerId) ? globalThis.String(object.followerId) : "",
      followeeId: isSet(object.followeeId) ? globalThis.String(object.followeeId) : "",
      status: isSet(object.status) ? followStatusFromJSON(object.status) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Follow): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.followerId !== "") {
      obj.followerId = message.followerId;
    }
    if (message.followeeId !== "") {
      obj.followeeId = message.followeeId;
    }
    if (message.status !== 0) {
      obj.status = followStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Follow>, I>>(base?: I): Follow {
    return Follow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Follow>, I>>(object: I): Follow {
    const message = createBaseFollow();
    message.id = object.id ?? "";
    message.followerId = object.followerId ?? "";
    message.followeeId = object.followeeId ?? "";
    message.status = object.status ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseCreateUserRequest(): CreateUserRequest {
  return { username: "", email: "", password: "", profile: undefined, roles: [], metadata: undefined };
}

export const CreateUserRequest: MessageFns<CreateUserRequest> = {
  encode(message: CreateUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.profile !== undefined) {
      UserProfile.encode(message.profile, writer.uint32(34).fork()).join();
    }
    for (const v of message.roles) {
      writer.uint32(42).string(v!);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profile = UserProfile.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      profile: isSet(object.profile) ? UserProfile.fromJSON(object.profile) : undefined,
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => globalThis.String(e)) : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: CreateUserRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.profile !== undefined) {
      obj.profile = UserProfile.toJSON(message.profile);
    }
    if (message.roles?.length) {
      obj.roles = message.roles;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserRequest>, I>>(base?: I): CreateUserRequest {
    return CreateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserRequest>, I>>(object: I): CreateUserRequest {
    const message = createBaseCreateUserRequest();
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? UserProfile.fromPartial(object.profile)
      : undefined;
    message.roles = object.roles?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseCreateUserResponse(): CreateUserResponse {
  return { user: undefined };
}

export const CreateUserResponse: MessageFns<CreateUserResponse> = {
  encode(message: CreateUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: CreateUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserResponse>, I>>(base?: I): CreateUserResponse {
    return CreateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserResponse>, I>>(object: I): CreateUserResponse {
    const message = createBaseCreateUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseGetUserRequest(): GetUserRequest {
  return { userId: "" };
}

export const GetUserRequest: MessageFns<GetUserRequest> = {
  encode(message: GetUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserRequest>, I>>(base?: I): GetUserRequest {
    return GetUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserRequest>, I>>(object: I): GetUserRequest {
    const message = createBaseGetUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUserResponse(): GetUserResponse {
  return { user: undefined };
}

export const GetUserResponse: MessageFns<GetUserResponse> = {
  encode(message: GetUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: GetUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserResponse>, I>>(base?: I): GetUserResponse {
    return GetUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserResponse>, I>>(object: I): GetUserResponse {
    const message = createBaseGetUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseGetUserByUsernameRequest(): GetUserByUsernameRequest {
  return { username: "" };
}

export const GetUserByUsernameRequest: MessageFns<GetUserByUsernameRequest> = {
  encode(message: GetUserByUsernameRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserByUsernameRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByUsernameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserByUsernameRequest {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: GetUserByUsernameRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserByUsernameRequest>, I>>(base?: I): GetUserByUsernameRequest {
    return GetUserByUsernameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserByUsernameRequest>, I>>(object: I): GetUserByUsernameRequest {
    const message = createBaseGetUserByUsernameRequest();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseGetUserByUsernameResponse(): GetUserByUsernameResponse {
  return { user: undefined };
}

export const GetUserByUsernameResponse: MessageFns<GetUserByUsernameResponse> = {
  encode(message: GetUserByUsernameResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserByUsernameResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByUsernameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserByUsernameResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: GetUserByUsernameResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserByUsernameResponse>, I>>(base?: I): GetUserByUsernameResponse {
    return GetUserByUsernameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserByUsernameResponse>, I>>(object: I): GetUserByUsernameResponse {
    const message = createBaseGetUserByUsernameResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseGetUserByEmailRequest(): GetUserByEmailRequest {
  return { email: "" };
}

export const GetUserByEmailRequest: MessageFns<GetUserByEmailRequest> = {
  encode(message: GetUserByEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserByEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserByEmailRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: GetUserByEmailRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserByEmailRequest>, I>>(base?: I): GetUserByEmailRequest {
    return GetUserByEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserByEmailRequest>, I>>(object: I): GetUserByEmailRequest {
    const message = createBaseGetUserByEmailRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseGetUserByEmailResponse(): GetUserByEmailResponse {
  return { user: undefined };
}

export const GetUserByEmailResponse: MessageFns<GetUserByEmailResponse> = {
  encode(message: GetUserByEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserByEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserByEmailResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: GetUserByEmailResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserByEmailResponse>, I>>(base?: I): GetUserByEmailResponse {
    return GetUserByEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserByEmailResponse>, I>>(object: I): GetUserByEmailResponse {
    const message = createBaseGetUserByEmailResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUpdateUserRequest(): UpdateUserRequest {
  return { userId: "", user: undefined, fieldsToUpdates: [], metadata: undefined };
}

export const UpdateUserRequest: MessageFns<UpdateUserRequest> = {
  encode(message: UpdateUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    for (const v of message.fieldsToUpdates) {
      writer.uint32(26).string(v!);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fieldsToUpdates.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      fieldsToUpdates: globalThis.Array.isArray(object?.fieldsToUpdates)
        ? object.fieldsToUpdates.map((e: any) => globalThis.String(e))
        : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: UpdateUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.fieldsToUpdates?.length) {
      obj.fieldsToUpdates = message.fieldsToUpdates;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(base?: I): UpdateUserRequest {
    return UpdateUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserRequest>, I>>(object: I): UpdateUserRequest {
    const message = createBaseUpdateUserRequest();
    message.userId = object.userId ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.fieldsToUpdates = object.fieldsToUpdates?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseUpdateUserResponse(): UpdateUserResponse {
  return { user: undefined };
}

export const UpdateUserResponse: MessageFns<UpdateUserResponse> = {
  encode(message: UpdateUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: UpdateUserResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(base?: I): UpdateUserResponse {
    return UpdateUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserResponse>, I>>(object: I): UpdateUserResponse {
    const message = createBaseUpdateUserResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseDeleteUserRequest(): DeleteUserRequest {
  return { userId: "", hardDelete: false, metadata: undefined };
}

export const DeleteUserRequest: MessageFns<DeleteUserRequest> = {
  encode(message: DeleteUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.hardDelete !== false) {
      writer.uint32(16).bool(message.hardDelete);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hardDelete = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      hardDelete: isSet(object.hardDelete) ? globalThis.Boolean(object.hardDelete) : false,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: DeleteUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.hardDelete !== false) {
      obj.hardDelete = message.hardDelete;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(base?: I): DeleteUserRequest {
    return DeleteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserRequest>, I>>(object: I): DeleteUserRequest {
    const message = createBaseDeleteUserRequest();
    message.userId = object.userId ?? "";
    message.hardDelete = object.hardDelete ?? false;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseDeleteUserResponse(): DeleteUserResponse {
  return { success: false };
}

export const DeleteUserResponse: MessageFns<DeleteUserResponse> = {
  encode(message: DeleteUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(base?: I): DeleteUserResponse {
    return DeleteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserResponse>, I>>(object: I): DeleteUserResponse {
    const message = createBaseDeleteUserResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListUsersRequest(): ListUsersRequest {
  return {
    page: 0,
    pageSize: 0,
    sortBy: "",
    sortDesc: false,
    filters: undefined,
    searchQuery: "",
    tags: [],
    metadata: undefined,
  };
}

export const ListUsersRequest: MessageFns<ListUsersRequest> = {
  encode(message: ListUsersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.sortBy !== "") {
      writer.uint32(26).string(message.sortBy);
    }
    if (message.sortDesc !== false) {
      writer.uint32(32).bool(message.sortDesc);
    }
    if (message.filters !== undefined) {
      Metadata.encode(message.filters, writer.uint32(42).fork()).join();
    }
    if (message.searchQuery !== "") {
      writer.uint32(50).string(message.searchQuery);
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sortDesc = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filters = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      sortBy: isSet(object.sortBy) ? globalThis.String(object.sortBy) : "",
      sortDesc: isSet(object.sortDesc) ? globalThis.Boolean(object.sortDesc) : false,
      filters: isSet(object.filters) ? Metadata.fromJSON(object.filters) : undefined,
      searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListUsersRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.sortDesc !== false) {
      obj.sortDesc = message.sortDesc;
    }
    if (message.filters !== undefined) {
      obj.filters = Metadata.toJSON(message.filters);
    }
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersRequest>, I>>(base?: I): ListUsersRequest {
    return ListUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersRequest>, I>>(object: I): ListUsersRequest {
    const message = createBaseListUsersRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.sortBy = object.sortBy ?? "";
    message.sortDesc = object.sortDesc ?? false;
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? Metadata.fromPartial(object.filters)
      : undefined;
    message.searchQuery = object.searchQuery ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListUsersResponse(): ListUsersResponse {
  return { users: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListUsersResponse: MessageFns<ListUsersResponse> = {
  encode(message: ListUsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersResponse {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListUsersResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersResponse>, I>>(base?: I): ListUsersResponse {
    return ListUsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersResponse>, I>>(object: I): ListUsersResponse {
    const message = createBaseListUsersResponse();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseUpdatePasswordRequest(): UpdatePasswordRequest {
  return { userId: "", currentPassword: "", newPassword: "" };
}

export const UpdatePasswordRequest: MessageFns<UpdatePasswordRequest> = {
  encode(message: UpdatePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.currentPassword !== "") {
      writer.uint32(18).string(message.currentPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(26).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.currentPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePasswordRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      currentPassword: isSet(object.currentPassword) ? globalThis.String(object.currentPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: UpdatePasswordRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.currentPassword !== "") {
      obj.currentPassword = message.currentPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePasswordRequest>, I>>(base?: I): UpdatePasswordRequest {
    return UpdatePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePasswordRequest>, I>>(object: I): UpdatePasswordRequest {
    const message = createBaseUpdatePasswordRequest();
    message.userId = object.userId ?? "";
    message.currentPassword = object.currentPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseUpdatePasswordResponse(): UpdatePasswordResponse {
  return { success: false, updatedAt: "0" };
}

export const UpdatePasswordResponse: MessageFns<UpdatePasswordResponse> = {
  encode(message: UpdatePasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(16).int64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.updatedAt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePasswordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "0",
    };
  },

  toJSON(message: UpdatePasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.updatedAt !== "0") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePasswordResponse>, I>>(base?: I): UpdatePasswordResponse {
    return UpdatePasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePasswordResponse>, I>>(object: I): UpdatePasswordResponse {
    const message = createBaseUpdatePasswordResponse();
    message.success = object.success ?? false;
    message.updatedAt = object.updatedAt ?? "0";
    return message;
  },
};

function createBaseUpdateProfileRequest(): UpdateProfileRequest {
  return { userId: "", profile: undefined, fieldsToUpdates: [] };
}

export const UpdateProfileRequest: MessageFns<UpdateProfileRequest> = {
  encode(message: UpdateProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.profile !== undefined) {
      UserProfile.encode(message.profile, writer.uint32(18).fork()).join();
    }
    for (const v of message.fieldsToUpdates) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.profile = UserProfile.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fieldsToUpdates.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProfileRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      profile: isSet(object.profile) ? UserProfile.fromJSON(object.profile) : undefined,
      fieldsToUpdates: globalThis.Array.isArray(object?.fieldsToUpdates)
        ? object.fieldsToUpdates.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UpdateProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.profile !== undefined) {
      obj.profile = UserProfile.toJSON(message.profile);
    }
    if (message.fieldsToUpdates?.length) {
      obj.fieldsToUpdates = message.fieldsToUpdates;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProfileRequest>, I>>(base?: I): UpdateProfileRequest {
    return UpdateProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProfileRequest>, I>>(object: I): UpdateProfileRequest {
    const message = createBaseUpdateProfileRequest();
    message.userId = object.userId ?? "";
    message.profile = (object.profile !== undefined && object.profile !== null)
      ? UserProfile.fromPartial(object.profile)
      : undefined;
    message.fieldsToUpdates = object.fieldsToUpdates?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateProfileResponse(): UpdateProfileResponse {
  return { user: undefined };
}

export const UpdateProfileResponse: MessageFns<UpdateProfileResponse> = {
  encode(message: UpdateProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProfileResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: UpdateProfileResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProfileResponse>, I>>(base?: I): UpdateProfileResponse {
    return UpdateProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProfileResponse>, I>>(object: I): UpdateProfileResponse {
    const message = createBaseUpdateProfileResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { userId: "", password: "", deviceInfo: "" };
}

export const CreateSessionRequest: MessageFns<CreateSessionRequest> = {
  encode(message: CreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.deviceInfo !== "") {
      writer.uint32(26).string(message.deviceInfo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceInfo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      deviceInfo: isSet(object.deviceInfo) ? globalThis.String(object.deviceInfo) : "",
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.deviceInfo !== "") {
      obj.deviceInfo = message.deviceInfo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(base?: I): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(object: I): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.userId = object.userId ?? "";
    message.password = object.password ?? "";
    message.deviceInfo = object.deviceInfo ?? "";
    return message;
  },
};

function createBaseCreateSessionResponse(): CreateSessionResponse {
  return { session: undefined };
}

export const CreateSessionResponse: MessageFns<CreateSessionResponse> = {
  encode(message: CreateSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionResponse {
    return { session: isSet(object.session) ? Session.fromJSON(object.session) : undefined };
  },

  toJSON(message: CreateSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(base?: I): CreateSessionResponse {
    return CreateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(object: I): CreateSessionResponse {
    const message = createBaseCreateSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseGetSessionRequest(): GetSessionRequest {
  return { sessionId: "" };
}

export const GetSessionRequest: MessageFns<GetSessionRequest> = {
  encode(message: GetSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: GetSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionRequest>, I>>(base?: I): GetSessionRequest {
    return GetSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionRequest>, I>>(object: I): GetSessionRequest {
    const message = createBaseGetSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseGetSessionResponse(): GetSessionResponse {
  return { session: undefined };
}

export const GetSessionResponse: MessageFns<GetSessionResponse> = {
  encode(message: GetSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionResponse {
    return { session: isSet(object.session) ? Session.fromJSON(object.session) : undefined };
  },

  toJSON(message: GetSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionResponse>, I>>(base?: I): GetSessionResponse {
    return GetSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionResponse>, I>>(object: I): GetSessionResponse {
    const message = createBaseGetSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseRevokeSessionRequest(): RevokeSessionRequest {
  return { sessionId: "" };
}

export const RevokeSessionRequest: MessageFns<RevokeSessionRequest> = {
  encode(message: RevokeSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: RevokeSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(base?: I): RevokeSessionRequest {
    return RevokeSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(object: I): RevokeSessionRequest {
    const message = createBaseRevokeSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseRevokeSessionResponse(): RevokeSessionResponse {
  return { success: false };
}

export const RevokeSessionResponse: MessageFns<RevokeSessionResponse> = {
  encode(message: RevokeSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeSessionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RevokeSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeSessionResponse>, I>>(base?: I): RevokeSessionResponse {
    return RevokeSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeSessionResponse>, I>>(object: I): RevokeSessionResponse {
    const message = createBaseRevokeSessionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListSessionsRequest(): ListSessionsRequest {
  return { userId: "" };
}

export const ListSessionsRequest: MessageFns<ListSessionsRequest> = {
  encode(message: ListSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: ListSessionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(base?: I): ListSessionsRequest {
    return ListSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(object: I): ListSessionsRequest {
    const message = createBaseListSessionsRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseListSessionsResponse(): ListSessionsResponse {
  return { sessions: [] };
}

export const ListSessionsResponse: MessageFns<ListSessionsResponse> = {
  encode(message: ListSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      Session.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(Session.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions) ? object.sessions.map((e: any) => Session.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => Session.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(base?: I): ListSessionsResponse {
    return ListSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(object: I): ListSessionsResponse {
    const message = createBaseListSessionsResponse();
    message.sessions = object.sessions?.map((e) => Session.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSession(): Session {
  return {
    id: "",
    userId: "",
    deviceInfo: "",
    createdAt: undefined,
    expiresAt: undefined,
    refreshToken: "",
    accessToken: "",
    ipAddress: "",
    metadata: undefined,
  };
}

export const Session: MessageFns<Session> = {
  encode(message: Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.deviceInfo !== "") {
      writer.uint32(26).string(message.deviceInfo);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(42).fork()).join();
    }
    if (message.refreshToken !== "") {
      writer.uint32(50).string(message.refreshToken);
    }
    if (message.accessToken !== "") {
      writer.uint32(58).string(message.accessToken);
    }
    if (message.ipAddress !== "") {
      writer.uint32(66).string(message.ipAddress);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceInfo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      deviceInfo: isSet(object.deviceInfo) ? globalThis.String(object.deviceInfo) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.deviceInfo !== "") {
      obj.deviceInfo = message.deviceInfo;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Session>, I>>(base?: I): Session {
    return Session.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Session>, I>>(object: I): Session {
    const message = createBaseSession();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.deviceInfo = object.deviceInfo ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.refreshToken = object.refreshToken ?? "";
    message.accessToken = object.accessToken ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAssignRoleRequest(): AssignRoleRequest {
  return { userId: "", role: "" };
}

export const AssignRoleRequest: MessageFns<AssignRoleRequest> = {
  encode(message: AssignRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignRoleRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: AssignRoleRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignRoleRequest>, I>>(base?: I): AssignRoleRequest {
    return AssignRoleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignRoleRequest>, I>>(object: I): AssignRoleRequest {
    const message = createBaseAssignRoleRequest();
    message.userId = object.userId ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseAssignRoleResponse(): AssignRoleResponse {
  return { success: false };
}

export const AssignRoleResponse: MessageFns<AssignRoleResponse> = {
  encode(message: AssignRoleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignRoleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignRoleResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: AssignRoleResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignRoleResponse>, I>>(base?: I): AssignRoleResponse {
    return AssignRoleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignRoleResponse>, I>>(object: I): AssignRoleResponse {
    const message = createBaseAssignRoleResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseRemoveRoleRequest(): RemoveRoleRequest {
  return { userId: "", role: "" };
}

export const RemoveRoleRequest: MessageFns<RemoveRoleRequest> = {
  encode(message: RemoveRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveRoleRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: RemoveRoleRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveRoleRequest>, I>>(base?: I): RemoveRoleRequest {
    return RemoveRoleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveRoleRequest>, I>>(object: I): RemoveRoleRequest {
    const message = createBaseRemoveRoleRequest();
    message.userId = object.userId ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseRemoveRoleResponse(): RemoveRoleResponse {
  return { success: false };
}

export const RemoveRoleResponse: MessageFns<RemoveRoleResponse> = {
  encode(message: RemoveRoleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveRoleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveRoleResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RemoveRoleResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveRoleResponse>, I>>(base?: I): RemoveRoleResponse {
    return RemoveRoleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveRoleResponse>, I>>(object: I): RemoveRoleResponse {
    const message = createBaseRemoveRoleResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListRolesRequest(): ListRolesRequest {
  return { userId: "" };
}

export const ListRolesRequest: MessageFns<ListRolesRequest> = {
  encode(message: ListRolesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolesRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: ListRolesRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRolesRequest>, I>>(base?: I): ListRolesRequest {
    return ListRolesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRolesRequest>, I>>(object: I): ListRolesRequest {
    const message = createBaseListRolesRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseListRolesResponse(): ListRolesResponse {
  return { roles: [] };
}

export const ListRolesResponse: MessageFns<ListRolesResponse> = {
  encode(message: ListRolesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.roles) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolesResponse {
    return { roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ListRolesResponse): unknown {
    const obj: any = {};
    if (message.roles?.length) {
      obj.roles = message.roles;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRolesResponse>, I>>(base?: I): ListRolesResponse {
    return ListRolesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRolesResponse>, I>>(object: I): ListRolesResponse {
    const message = createBaseListRolesResponse();
    message.roles = object.roles?.map((e) => e) || [];
    return message;
  },
};

function createBaseListPermissionsRequest(): ListPermissionsRequest {
  return { userId: "" };
}

export const ListPermissionsRequest: MessageFns<ListPermissionsRequest> = {
  encode(message: ListPermissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPermissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPermissionsRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: ListPermissionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPermissionsRequest>, I>>(base?: I): ListPermissionsRequest {
    return ListPermissionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPermissionsRequest>, I>>(object: I): ListPermissionsRequest {
    const message = createBaseListPermissionsRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseListPermissionsResponse(): ListPermissionsResponse {
  return { permissions: [] };
}

export const ListPermissionsResponse: MessageFns<ListPermissionsResponse> = {
  encode(message: ListPermissionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.permissions) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPermissionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPermissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPermissionsResponse {
    return {
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListPermissionsResponse): unknown {
    const obj: any = {};
    if (message.permissions?.length) {
      obj.permissions = message.permissions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPermissionsResponse>, I>>(base?: I): ListPermissionsResponse {
    return ListPermissionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPermissionsResponse>, I>>(object: I): ListPermissionsResponse {
    const message = createBaseListPermissionsResponse();
    message.permissions = object.permissions?.map((e) => e) || [];
    return message;
  },
};

function createBaseListUserEventsRequest(): ListUserEventsRequest {
  return { userId: "", page: 0, pageSize: 0 };
}

export const ListUserEventsRequest: MessageFns<ListUserEventsRequest> = {
  encode(message: ListUserEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserEventsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListUserEventsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserEventsRequest>, I>>(base?: I): ListUserEventsRequest {
    return ListUserEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserEventsRequest>, I>>(object: I): ListUserEventsRequest {
    const message = createBaseListUserEventsRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListUserEventsResponse(): ListUserEventsResponse {
  return { events: [], totalCount: 0 };
}

export const ListUserEventsResponse: MessageFns<ListUserEventsResponse> = {
  encode(message: ListUserEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      UserEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(UserEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => UserEvent.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListUserEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => UserEvent.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserEventsResponse>, I>>(base?: I): ListUserEventsResponse {
    return ListUserEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserEventsResponse>, I>>(object: I): ListUserEventsResponse {
    const message = createBaseListUserEventsResponse();
    message.events = object.events?.map((e) => UserEvent.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseListAuditLogsRequest(): ListAuditLogsRequest {
  return { userId: "", page: 0, pageSize: 0 };
}

export const ListAuditLogsRequest: MessageFns<ListAuditLogsRequest> = {
  encode(message: ListAuditLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuditLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuditLogsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListAuditLogsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAuditLogsRequest>, I>>(base?: I): ListAuditLogsRequest {
    return ListAuditLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAuditLogsRequest>, I>>(object: I): ListAuditLogsRequest {
    const message = createBaseListAuditLogsRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListAuditLogsResponse(): ListAuditLogsResponse {
  return { logs: [], totalCount: 0 };
}

export const ListAuditLogsResponse: MessageFns<ListAuditLogsResponse> = {
  encode(message: ListAuditLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      AuditLog.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAuditLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAuditLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(AuditLog.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAuditLogsResponse {
    return {
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => AuditLog.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
    };
  },

  toJSON(message: ListAuditLogsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => AuditLog.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAuditLogsResponse>, I>>(base?: I): ListAuditLogsResponse {
    return ListAuditLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAuditLogsResponse>, I>>(object: I): ListAuditLogsResponse {
    const message = createBaseListAuditLogsResponse();
    message.logs = object.logs?.map((e) => AuditLog.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseUserEvent(): UserEvent {
  return {
    id: "",
    masterId: "0",
    masterUuid: "",
    userId: "",
    eventType: "",
    description: "",
    occurredAt: undefined,
    metadata: undefined,
    payload: {},
  };
}

export const UserEvent: MessageFns<UserEvent> = {
  encode(message: UserEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.masterId !== "0") {
      writer.uint32(16).int64(message.masterId);
    }
    if (message.masterUuid !== "") {
      writer.uint32(26).string(message.masterUuid);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.eventType !== "") {
      writer.uint32(42).string(message.eventType);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.occurredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.occurredAt), writer.uint32(58).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    Object.entries(message.payload).forEach(([key, value]) => {
      UserEvent_PayloadEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.masterId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.occurredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = UserEvent_PayloadEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.payload[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      masterId: isSet(object.masterId) ? globalThis.String(object.masterId) : "0",
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      occurredAt: isSet(object.occurredAt) ? fromJsonTimestamp(object.occurredAt) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      payload: isObject(object.payload)
        ? Object.entries(object.payload).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UserEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.masterId !== "0") {
      obj.masterId = message.masterId;
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.occurredAt !== undefined) {
      obj.occurredAt = message.occurredAt.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.payload) {
      const entries = Object.entries(message.payload);
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserEvent>, I>>(base?: I): UserEvent {
    return UserEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserEvent>, I>>(object: I): UserEvent {
    const message = createBaseUserEvent();
    message.id = object.id ?? "";
    message.masterId = object.masterId ?? "0";
    message.masterUuid = object.masterUuid ?? "";
    message.userId = object.userId ?? "";
    message.eventType = object.eventType ?? "";
    message.description = object.description ?? "";
    message.occurredAt = object.occurredAt ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.payload = Object.entries(object.payload ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseUserEvent_PayloadEntry(): UserEvent_PayloadEntry {
  return { key: "", value: "" };
}

export const UserEvent_PayloadEntry: MessageFns<UserEvent_PayloadEntry> = {
  encode(message: UserEvent_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserEvent_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserEvent_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserEvent_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UserEvent_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserEvent_PayloadEntry>, I>>(base?: I): UserEvent_PayloadEntry {
    return UserEvent_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserEvent_PayloadEntry>, I>>(object: I): UserEvent_PayloadEntry {
    const message = createBaseUserEvent_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAuditLog(): AuditLog {
  return {
    id: "",
    masterId: "0",
    masterUuid: "",
    userId: "",
    action: "",
    resource: "",
    occurredAt: undefined,
    metadata: undefined,
    payload: {},
  };
}

export const AuditLog: MessageFns<AuditLog> = {
  encode(message: AuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.masterId !== "0") {
      writer.uint32(16).int64(message.masterId);
    }
    if (message.masterUuid !== "") {
      writer.uint32(26).string(message.masterUuid);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    if (message.resource !== "") {
      writer.uint32(50).string(message.resource);
    }
    if (message.occurredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.occurredAt), writer.uint32(58).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    Object.entries(message.payload).forEach(([key, value]) => {
      AuditLog_PayloadEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.masterId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.occurredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = AuditLog_PayloadEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.payload[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLog {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      masterId: isSet(object.masterId) ? globalThis.String(object.masterId) : "0",
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      occurredAt: isSet(object.occurredAt) ? fromJsonTimestamp(object.occurredAt) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      payload: isObject(object.payload)
        ? Object.entries(object.payload).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AuditLog): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.masterId !== "0") {
      obj.masterId = message.masterId;
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.occurredAt !== undefined) {
      obj.occurredAt = message.occurredAt.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.payload) {
      const entries = Object.entries(message.payload);
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLog>, I>>(base?: I): AuditLog {
    return AuditLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLog>, I>>(object: I): AuditLog {
    const message = createBaseAuditLog();
    message.id = object.id ?? "";
    message.masterId = object.masterId ?? "0";
    message.masterUuid = object.masterUuid ?? "";
    message.userId = object.userId ?? "";
    message.action = object.action ?? "";
    message.resource = object.resource ?? "";
    message.occurredAt = object.occurredAt ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.payload = Object.entries(object.payload ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAuditLog_PayloadEntry(): AuditLog_PayloadEntry {
  return { key: "", value: "" };
}

export const AuditLog_PayloadEntry: MessageFns<AuditLog_PayloadEntry> = {
  encode(message: AuditLog_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLog_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLog_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLog_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AuditLog_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuditLog_PayloadEntry>, I>>(base?: I): AuditLog_PayloadEntry {
    return AuditLog_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuditLog_PayloadEntry>, I>>(object: I): AuditLog_PayloadEntry {
    const message = createBaseAuditLog_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInitiateSSORequest(): InitiateSSORequest {
  return { provider: "", redirectUri: "" };
}

export const InitiateSSORequest: MessageFns<InitiateSSORequest> = {
  encode(message: InitiateSSORequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.redirectUri !== "") {
      writer.uint32(18).string(message.redirectUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateSSORequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateSSORequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateSSORequest {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : "",
    };
  },

  toJSON(message: InitiateSSORequest): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateSSORequest>, I>>(base?: I): InitiateSSORequest {
    return InitiateSSORequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateSSORequest>, I>>(object: I): InitiateSSORequest {
    const message = createBaseInitiateSSORequest();
    message.provider = object.provider ?? "";
    message.redirectUri = object.redirectUri ?? "";
    return message;
  },
};

function createBaseInitiateSSOResponse(): InitiateSSOResponse {
  return { ssoUrl: "" };
}

export const InitiateSSOResponse: MessageFns<InitiateSSOResponse> = {
  encode(message: InitiateSSOResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ssoUrl !== "") {
      writer.uint32(10).string(message.ssoUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateSSOResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateSSOResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ssoUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateSSOResponse {
    return { ssoUrl: isSet(object.ssoUrl) ? globalThis.String(object.ssoUrl) : "" };
  },

  toJSON(message: InitiateSSOResponse): unknown {
    const obj: any = {};
    if (message.ssoUrl !== "") {
      obj.ssoUrl = message.ssoUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateSSOResponse>, I>>(base?: I): InitiateSSOResponse {
    return InitiateSSOResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateSSOResponse>, I>>(object: I): InitiateSSOResponse {
    const message = createBaseInitiateSSOResponse();
    message.ssoUrl = object.ssoUrl ?? "";
    return message;
  },
};

function createBaseInitiateMFARequest(): InitiateMFARequest {
  return { userId: "", mfaType: "" };
}

export const InitiateMFARequest: MessageFns<InitiateMFARequest> = {
  encode(message: InitiateMFARequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.mfaType !== "") {
      writer.uint32(18).string(message.mfaType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateMFARequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateMFARequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mfaType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateMFARequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      mfaType: isSet(object.mfaType) ? globalThis.String(object.mfaType) : "",
    };
  },

  toJSON(message: InitiateMFARequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.mfaType !== "") {
      obj.mfaType = message.mfaType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateMFARequest>, I>>(base?: I): InitiateMFARequest {
    return InitiateMFARequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateMFARequest>, I>>(object: I): InitiateMFARequest {
    const message = createBaseInitiateMFARequest();
    message.userId = object.userId ?? "";
    message.mfaType = object.mfaType ?? "";
    return message;
  },
};

function createBaseInitiateMFAResponse(): InitiateMFAResponse {
  return { initiated: false, challengeId: "" };
}

export const InitiateMFAResponse: MessageFns<InitiateMFAResponse> = {
  encode(message: InitiateMFAResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initiated !== false) {
      writer.uint32(8).bool(message.initiated);
    }
    if (message.challengeId !== "") {
      writer.uint32(18).string(message.challengeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateMFAResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateMFAResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.initiated = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.challengeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateMFAResponse {
    return {
      initiated: isSet(object.initiated) ? globalThis.Boolean(object.initiated) : false,
      challengeId: isSet(object.challengeId) ? globalThis.String(object.challengeId) : "",
    };
  },

  toJSON(message: InitiateMFAResponse): unknown {
    const obj: any = {};
    if (message.initiated !== false) {
      obj.initiated = message.initiated;
    }
    if (message.challengeId !== "") {
      obj.challengeId = message.challengeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateMFAResponse>, I>>(base?: I): InitiateMFAResponse {
    return InitiateMFAResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateMFAResponse>, I>>(object: I): InitiateMFAResponse {
    const message = createBaseInitiateMFAResponse();
    message.initiated = object.initiated ?? false;
    message.challengeId = object.challengeId ?? "";
    return message;
  },
};

function createBaseSyncSCIMRequest(): SyncSCIMRequest {
  return { scimPayload: "" };
}

export const SyncSCIMRequest: MessageFns<SyncSCIMRequest> = {
  encode(message: SyncSCIMRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scimPayload !== "") {
      writer.uint32(10).string(message.scimPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncSCIMRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncSCIMRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scimPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncSCIMRequest {
    return { scimPayload: isSet(object.scimPayload) ? globalThis.String(object.scimPayload) : "" };
  },

  toJSON(message: SyncSCIMRequest): unknown {
    const obj: any = {};
    if (message.scimPayload !== "") {
      obj.scimPayload = message.scimPayload;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncSCIMRequest>, I>>(base?: I): SyncSCIMRequest {
    return SyncSCIMRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncSCIMRequest>, I>>(object: I): SyncSCIMRequest {
    const message = createBaseSyncSCIMRequest();
    message.scimPayload = object.scimPayload ?? "";
    return message;
  },
};

function createBaseSyncSCIMResponse(): SyncSCIMResponse {
  return { success: false };
}

export const SyncSCIMResponse: MessageFns<SyncSCIMResponse> = {
  encode(message: SyncSCIMResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncSCIMResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncSCIMResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncSCIMResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: SyncSCIMResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncSCIMResponse>, I>>(base?: I): SyncSCIMResponse {
    return SyncSCIMResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncSCIMResponse>, I>>(object: I): SyncSCIMResponse {
    const message = createBaseSyncSCIMResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseAddFriendRequest(): AddFriendRequest {
  return { userId: "", friendId: "", metadata: undefined };
}

export const AddFriendRequest: MessageFns<AddFriendRequest> = {
  encode(message: AddFriendRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.friendId !== "") {
      writer.uint32(18).string(message.friendId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddFriendRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFriendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.friendId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddFriendRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      friendId: isSet(object.friendId) ? globalThis.String(object.friendId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AddFriendRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.friendId !== "") {
      obj.friendId = message.friendId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddFriendRequest>, I>>(base?: I): AddFriendRequest {
    return AddFriendRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddFriendRequest>, I>>(object: I): AddFriendRequest {
    const message = createBaseAddFriendRequest();
    message.userId = object.userId ?? "";
    message.friendId = object.friendId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAddFriendResponse(): AddFriendResponse {
  return { friendship: undefined };
}

export const AddFriendResponse: MessageFns<AddFriendResponse> = {
  encode(message: AddFriendResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.friendship !== undefined) {
      Friendship.encode(message.friendship, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddFriendResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddFriendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.friendship = Friendship.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddFriendResponse {
    return { friendship: isSet(object.friendship) ? Friendship.fromJSON(object.friendship) : undefined };
  },

  toJSON(message: AddFriendResponse): unknown {
    const obj: any = {};
    if (message.friendship !== undefined) {
      obj.friendship = Friendship.toJSON(message.friendship);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddFriendResponse>, I>>(base?: I): AddFriendResponse {
    return AddFriendResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddFriendResponse>, I>>(object: I): AddFriendResponse {
    const message = createBaseAddFriendResponse();
    message.friendship = (object.friendship !== undefined && object.friendship !== null)
      ? Friendship.fromPartial(object.friendship)
      : undefined;
    return message;
  },
};

function createBaseRemoveFriendRequest(): RemoveFriendRequest {
  return { userId: "", friendId: "", metadata: undefined };
}

export const RemoveFriendRequest: MessageFns<RemoveFriendRequest> = {
  encode(message: RemoveFriendRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.friendId !== "") {
      writer.uint32(18).string(message.friendId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFriendRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFriendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.friendId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFriendRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      friendId: isSet(object.friendId) ? globalThis.String(object.friendId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: RemoveFriendRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.friendId !== "") {
      obj.friendId = message.friendId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFriendRequest>, I>>(base?: I): RemoveFriendRequest {
    return RemoveFriendRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveFriendRequest>, I>>(object: I): RemoveFriendRequest {
    const message = createBaseRemoveFriendRequest();
    message.userId = object.userId ?? "";
    message.friendId = object.friendId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRemoveFriendResponse(): RemoveFriendResponse {
  return { success: false };
}

export const RemoveFriendResponse: MessageFns<RemoveFriendResponse> = {
  encode(message: RemoveFriendResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFriendResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFriendResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFriendResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RemoveFriendResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFriendResponse>, I>>(base?: I): RemoveFriendResponse {
    return RemoveFriendResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveFriendResponse>, I>>(object: I): RemoveFriendResponse {
    const message = createBaseRemoveFriendResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListFriendsRequest(): ListFriendsRequest {
  return { userId: "", page: 0, pageSize: 0, metadata: undefined };
}

export const ListFriendsRequest: MessageFns<ListFriendsRequest> = {
  encode(message: ListFriendsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFriendsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFriendsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFriendsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListFriendsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFriendsRequest>, I>>(base?: I): ListFriendsRequest {
    return ListFriendsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFriendsRequest>, I>>(object: I): ListFriendsRequest {
    const message = createBaseListFriendsRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListFriendsResponse(): ListFriendsResponse {
  return { friends: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListFriendsResponse: MessageFns<ListFriendsResponse> = {
  encode(message: ListFriendsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.friends) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFriendsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFriendsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.friends.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFriendsResponse {
    return {
      friends: globalThis.Array.isArray(object?.friends) ? object.friends.map((e: any) => User.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListFriendsResponse): unknown {
    const obj: any = {};
    if (message.friends?.length) {
      obj.friends = message.friends.map((e) => User.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFriendsResponse>, I>>(base?: I): ListFriendsResponse {
    return ListFriendsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFriendsResponse>, I>>(object: I): ListFriendsResponse {
    const message = createBaseListFriendsResponse();
    message.friends = object.friends?.map((e) => User.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseFollowUserRequest(): FollowUserRequest {
  return { followerId: "", followeeId: "", metadata: undefined };
}

export const FollowUserRequest: MessageFns<FollowUserRequest> = {
  encode(message: FollowUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.followerId !== "") {
      writer.uint32(10).string(message.followerId);
    }
    if (message.followeeId !== "") {
      writer.uint32(18).string(message.followeeId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FollowUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFollowUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.followerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.followeeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FollowUserRequest {
    return {
      followerId: isSet(object.followerId) ? globalThis.String(object.followerId) : "",
      followeeId: isSet(object.followeeId) ? globalThis.String(object.followeeId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: FollowUserRequest): unknown {
    const obj: any = {};
    if (message.followerId !== "") {
      obj.followerId = message.followerId;
    }
    if (message.followeeId !== "") {
      obj.followeeId = message.followeeId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FollowUserRequest>, I>>(base?: I): FollowUserRequest {
    return FollowUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FollowUserRequest>, I>>(object: I): FollowUserRequest {
    const message = createBaseFollowUserRequest();
    message.followerId = object.followerId ?? "";
    message.followeeId = object.followeeId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseFollowUserResponse(): FollowUserResponse {
  return { follow: undefined };
}

export const FollowUserResponse: MessageFns<FollowUserResponse> = {
  encode(message: FollowUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.follow !== undefined) {
      Follow.encode(message.follow, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FollowUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFollowUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.follow = Follow.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FollowUserResponse {
    return { follow: isSet(object.follow) ? Follow.fromJSON(object.follow) : undefined };
  },

  toJSON(message: FollowUserResponse): unknown {
    const obj: any = {};
    if (message.follow !== undefined) {
      obj.follow = Follow.toJSON(message.follow);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FollowUserResponse>, I>>(base?: I): FollowUserResponse {
    return FollowUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FollowUserResponse>, I>>(object: I): FollowUserResponse {
    const message = createBaseFollowUserResponse();
    message.follow = (object.follow !== undefined && object.follow !== null)
      ? Follow.fromPartial(object.follow)
      : undefined;
    return message;
  },
};

function createBaseUnfollowUserRequest(): UnfollowUserRequest {
  return { followerId: "", followeeId: "", metadata: undefined };
}

export const UnfollowUserRequest: MessageFns<UnfollowUserRequest> = {
  encode(message: UnfollowUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.followerId !== "") {
      writer.uint32(10).string(message.followerId);
    }
    if (message.followeeId !== "") {
      writer.uint32(18).string(message.followeeId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnfollowUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnfollowUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.followerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.followeeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnfollowUserRequest {
    return {
      followerId: isSet(object.followerId) ? globalThis.String(object.followerId) : "",
      followeeId: isSet(object.followeeId) ? globalThis.String(object.followeeId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: UnfollowUserRequest): unknown {
    const obj: any = {};
    if (message.followerId !== "") {
      obj.followerId = message.followerId;
    }
    if (message.followeeId !== "") {
      obj.followeeId = message.followeeId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnfollowUserRequest>, I>>(base?: I): UnfollowUserRequest {
    return UnfollowUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnfollowUserRequest>, I>>(object: I): UnfollowUserRequest {
    const message = createBaseUnfollowUserRequest();
    message.followerId = object.followerId ?? "";
    message.followeeId = object.followeeId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseUnfollowUserResponse(): UnfollowUserResponse {
  return { success: false };
}

export const UnfollowUserResponse: MessageFns<UnfollowUserResponse> = {
  encode(message: UnfollowUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnfollowUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnfollowUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnfollowUserResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UnfollowUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnfollowUserResponse>, I>>(base?: I): UnfollowUserResponse {
    return UnfollowUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnfollowUserResponse>, I>>(object: I): UnfollowUserResponse {
    const message = createBaseUnfollowUserResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListFollowersRequest(): ListFollowersRequest {
  return { userId: "", page: 0, pageSize: 0, metadata: undefined };
}

export const ListFollowersRequest: MessageFns<ListFollowersRequest> = {
  encode(message: ListFollowersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFollowersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFollowersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFollowersRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListFollowersRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFollowersRequest>, I>>(base?: I): ListFollowersRequest {
    return ListFollowersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFollowersRequest>, I>>(object: I): ListFollowersRequest {
    const message = createBaseListFollowersRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListFollowersResponse(): ListFollowersResponse {
  return { followers: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListFollowersResponse: MessageFns<ListFollowersResponse> = {
  encode(message: ListFollowersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.followers) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFollowersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFollowersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.followers.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFollowersResponse {
    return {
      followers: globalThis.Array.isArray(object?.followers) ? object.followers.map((e: any) => User.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListFollowersResponse): unknown {
    const obj: any = {};
    if (message.followers?.length) {
      obj.followers = message.followers.map((e) => User.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFollowersResponse>, I>>(base?: I): ListFollowersResponse {
    return ListFollowersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFollowersResponse>, I>>(object: I): ListFollowersResponse {
    const message = createBaseListFollowersResponse();
    message.followers = object.followers?.map((e) => User.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseListFollowingRequest(): ListFollowingRequest {
  return { userId: "", page: 0, pageSize: 0, metadata: undefined };
}

export const ListFollowingRequest: MessageFns<ListFollowingRequest> = {
  encode(message: ListFollowingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFollowingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFollowingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFollowingRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListFollowingRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFollowingRequest>, I>>(base?: I): ListFollowingRequest {
    return ListFollowingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFollowingRequest>, I>>(object: I): ListFollowingRequest {
    const message = createBaseListFollowingRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListFollowingResponse(): ListFollowingResponse {
  return { followings: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListFollowingResponse: MessageFns<ListFollowingResponse> = {
  encode(message: ListFollowingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.followings) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFollowingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFollowingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.followings.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFollowingResponse {
    return {
      followings: globalThis.Array.isArray(object?.followings)
        ? object.followings.map((e: any) => User.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListFollowingResponse): unknown {
    const obj: any = {};
    if (message.followings?.length) {
      obj.followings = message.followings.map((e) => User.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListFollowingResponse>, I>>(base?: I): ListFollowingResponse {
    return ListFollowingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListFollowingResponse>, I>>(object: I): ListFollowingResponse {
    const message = createBaseListFollowingResponse();
    message.followings = object.followings?.map((e) => User.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseCreateUserGroupRequest(): CreateUserGroupRequest {
  return { name: "", description: "", memberIds: [], roles: {}, metadata: undefined };
}

export const CreateUserGroupRequest: MessageFns<CreateUserGroupRequest> = {
  encode(message: CreateUserGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.memberIds) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.roles).forEach(([key, value]) => {
      CreateUserGroupRequest_RolesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.memberIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CreateUserGroupRequest_RolesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.roles[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserGroupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      memberIds: globalThis.Array.isArray(object?.memberIds)
        ? object.memberIds.map((e: any) => globalThis.String(e))
        : [],
      roles: isObject(object.roles)
        ? Object.entries(object.roles).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: CreateUserGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.memberIds?.length) {
      obj.memberIds = message.memberIds;
    }
    if (message.roles) {
      const entries = Object.entries(message.roles);
      if (entries.length > 0) {
        obj.roles = {};
        entries.forEach(([k, v]) => {
          obj.roles[k] = v;
        });
      }
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserGroupRequest>, I>>(base?: I): CreateUserGroupRequest {
    return CreateUserGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserGroupRequest>, I>>(object: I): CreateUserGroupRequest {
    const message = createBaseCreateUserGroupRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.memberIds = object.memberIds?.map((e) => e) || [];
    message.roles = Object.entries(object.roles ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseCreateUserGroupRequest_RolesEntry(): CreateUserGroupRequest_RolesEntry {
  return { key: "", value: "" };
}

export const CreateUserGroupRequest_RolesEntry: MessageFns<CreateUserGroupRequest_RolesEntry> = {
  encode(message: CreateUserGroupRequest_RolesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserGroupRequest_RolesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserGroupRequest_RolesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserGroupRequest_RolesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateUserGroupRequest_RolesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserGroupRequest_RolesEntry>, I>>(
    base?: I,
  ): CreateUserGroupRequest_RolesEntry {
    return CreateUserGroupRequest_RolesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserGroupRequest_RolesEntry>, I>>(
    object: I,
  ): CreateUserGroupRequest_RolesEntry {
    const message = createBaseCreateUserGroupRequest_RolesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateUserGroupResponse(): CreateUserGroupResponse {
  return { userGroup: undefined };
}

export const CreateUserGroupResponse: MessageFns<CreateUserGroupResponse> = {
  encode(message: CreateUserGroupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userGroup !== undefined) {
      UserGroup.encode(message.userGroup, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateUserGroupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userGroup = UserGroup.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateUserGroupResponse {
    return { userGroup: isSet(object.userGroup) ? UserGroup.fromJSON(object.userGroup) : undefined };
  },

  toJSON(message: CreateUserGroupResponse): unknown {
    const obj: any = {};
    if (message.userGroup !== undefined) {
      obj.userGroup = UserGroup.toJSON(message.userGroup);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateUserGroupResponse>, I>>(base?: I): CreateUserGroupResponse {
    return CreateUserGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateUserGroupResponse>, I>>(object: I): CreateUserGroupResponse {
    const message = createBaseCreateUserGroupResponse();
    message.userGroup = (object.userGroup !== undefined && object.userGroup !== null)
      ? UserGroup.fromPartial(object.userGroup)
      : undefined;
    return message;
  },
};

function createBaseUpdateUserGroupRequest(): UpdateUserGroupRequest {
  return { userGroupId: "", userGroup: undefined, fieldsToUpdates: [], metadata: undefined };
}

export const UpdateUserGroupRequest: MessageFns<UpdateUserGroupRequest> = {
  encode(message: UpdateUserGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userGroupId !== "") {
      writer.uint32(10).string(message.userGroupId);
    }
    if (message.userGroup !== undefined) {
      UserGroup.encode(message.userGroup, writer.uint32(18).fork()).join();
    }
    for (const v of message.fieldsToUpdates) {
      writer.uint32(26).string(v!);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userGroupId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userGroup = UserGroup.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fieldsToUpdates.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserGroupRequest {
    return {
      userGroupId: isSet(object.userGroupId) ? globalThis.String(object.userGroupId) : "",
      userGroup: isSet(object.userGroup) ? UserGroup.fromJSON(object.userGroup) : undefined,
      fieldsToUpdates: globalThis.Array.isArray(object?.fieldsToUpdates)
        ? object.fieldsToUpdates.map((e: any) => globalThis.String(e))
        : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: UpdateUserGroupRequest): unknown {
    const obj: any = {};
    if (message.userGroupId !== "") {
      obj.userGroupId = message.userGroupId;
    }
    if (message.userGroup !== undefined) {
      obj.userGroup = UserGroup.toJSON(message.userGroup);
    }
    if (message.fieldsToUpdates?.length) {
      obj.fieldsToUpdates = message.fieldsToUpdates;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserGroupRequest>, I>>(base?: I): UpdateUserGroupRequest {
    return UpdateUserGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserGroupRequest>, I>>(object: I): UpdateUserGroupRequest {
    const message = createBaseUpdateUserGroupRequest();
    message.userGroupId = object.userGroupId ?? "";
    message.userGroup = (object.userGroup !== undefined && object.userGroup !== null)
      ? UserGroup.fromPartial(object.userGroup)
      : undefined;
    message.fieldsToUpdates = object.fieldsToUpdates?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseUpdateUserGroupResponse(): UpdateUserGroupResponse {
  return { userGroup: undefined };
}

export const UpdateUserGroupResponse: MessageFns<UpdateUserGroupResponse> = {
  encode(message: UpdateUserGroupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userGroup !== undefined) {
      UserGroup.encode(message.userGroup, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserGroupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userGroup = UserGroup.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserGroupResponse {
    return { userGroup: isSet(object.userGroup) ? UserGroup.fromJSON(object.userGroup) : undefined };
  },

  toJSON(message: UpdateUserGroupResponse): unknown {
    const obj: any = {};
    if (message.userGroup !== undefined) {
      obj.userGroup = UserGroup.toJSON(message.userGroup);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserGroupResponse>, I>>(base?: I): UpdateUserGroupResponse {
    return UpdateUserGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserGroupResponse>, I>>(object: I): UpdateUserGroupResponse {
    const message = createBaseUpdateUserGroupResponse();
    message.userGroup = (object.userGroup !== undefined && object.userGroup !== null)
      ? UserGroup.fromPartial(object.userGroup)
      : undefined;
    return message;
  },
};

function createBaseDeleteUserGroupRequest(): DeleteUserGroupRequest {
  return { userGroupId: "", metadata: undefined };
}

export const DeleteUserGroupRequest: MessageFns<DeleteUserGroupRequest> = {
  encode(message: DeleteUserGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userGroupId !== "") {
      writer.uint32(10).string(message.userGroupId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userGroupId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserGroupRequest {
    return {
      userGroupId: isSet(object.userGroupId) ? globalThis.String(object.userGroupId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: DeleteUserGroupRequest): unknown {
    const obj: any = {};
    if (message.userGroupId !== "") {
      obj.userGroupId = message.userGroupId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserGroupRequest>, I>>(base?: I): DeleteUserGroupRequest {
    return DeleteUserGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserGroupRequest>, I>>(object: I): DeleteUserGroupRequest {
    const message = createBaseDeleteUserGroupRequest();
    message.userGroupId = object.userGroupId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseDeleteUserGroupResponse(): DeleteUserGroupResponse {
  return { success: false };
}

export const DeleteUserGroupResponse: MessageFns<DeleteUserGroupResponse> = {
  encode(message: DeleteUserGroupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserGroupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserGroupResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteUserGroupResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserGroupResponse>, I>>(base?: I): DeleteUserGroupResponse {
    return DeleteUserGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserGroupResponse>, I>>(object: I): DeleteUserGroupResponse {
    const message = createBaseDeleteUserGroupResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListUserGroupsRequest(): ListUserGroupsRequest {
  return { userId: "", page: 0, pageSize: 0, metadata: undefined };
}

export const ListUserGroupsRequest: MessageFns<ListUserGroupsRequest> = {
  encode(message: ListUserGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserGroupsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListUserGroupsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserGroupsRequest>, I>>(base?: I): ListUserGroupsRequest {
    return ListUserGroupsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserGroupsRequest>, I>>(object: I): ListUserGroupsRequest {
    const message = createBaseListUserGroupsRequest();
    message.userId = object.userId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListUserGroupsResponse(): ListUserGroupsResponse {
  return { userGroups: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListUserGroupsResponse: MessageFns<ListUserGroupsResponse> = {
  encode(message: ListUserGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.userGroups) {
      UserGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userGroups.push(UserGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserGroupsResponse {
    return {
      userGroups: globalThis.Array.isArray(object?.userGroups)
        ? object.userGroups.map((e: any) => UserGroup.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListUserGroupsResponse): unknown {
    const obj: any = {};
    if (message.userGroups?.length) {
      obj.userGroups = message.userGroups.map((e) => UserGroup.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserGroupsResponse>, I>>(base?: I): ListUserGroupsResponse {
    return ListUserGroupsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserGroupsResponse>, I>>(object: I): ListUserGroupsResponse {
    const message = createBaseListUserGroupsResponse();
    message.userGroups = object.userGroups?.map((e) => UserGroup.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseListUserGroupMembersRequest(): ListUserGroupMembersRequest {
  return { userGroupId: "", page: 0, pageSize: 0, metadata: undefined };
}

export const ListUserGroupMembersRequest: MessageFns<ListUserGroupMembersRequest> = {
  encode(message: ListUserGroupMembersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userGroupId !== "") {
      writer.uint32(10).string(message.userGroupId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserGroupMembersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserGroupMembersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userGroupId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserGroupMembersRequest {
    return {
      userGroupId: isSet(object.userGroupId) ? globalThis.String(object.userGroupId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListUserGroupMembersRequest): unknown {
    const obj: any = {};
    if (message.userGroupId !== "") {
      obj.userGroupId = message.userGroupId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserGroupMembersRequest>, I>>(base?: I): ListUserGroupMembersRequest {
    return ListUserGroupMembersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserGroupMembersRequest>, I>>(object: I): ListUserGroupMembersRequest {
    const message = createBaseListUserGroupMembersRequest();
    message.userGroupId = object.userGroupId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListUserGroupMembersResponse(): ListUserGroupMembersResponse {
  return { members: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListUserGroupMembersResponse: MessageFns<ListUserGroupMembersResponse> = {
  encode(message: ListUserGroupMembersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUserGroupMembersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUserGroupMembersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUserGroupMembersResponse {
    return {
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e: any) => User.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListUserGroupMembersResponse): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => User.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUserGroupMembersResponse>, I>>(base?: I): ListUserGroupMembersResponse {
    return ListUserGroupMembersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUserGroupMembersResponse>, I>>(object: I): ListUserGroupMembersResponse {
    const message = createBaseListUserGroupMembersResponse();
    message.members = object.members?.map((e) => User.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseSuggestConnectionsRequest(): SuggestConnectionsRequest {
  return { userId: "", metadata: undefined };
}

export const SuggestConnectionsRequest: MessageFns<SuggestConnectionsRequest> = {
  encode(message: SuggestConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestConnectionsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: SuggestConnectionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SuggestConnectionsRequest>, I>>(base?: I): SuggestConnectionsRequest {
    return SuggestConnectionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SuggestConnectionsRequest>, I>>(object: I): SuggestConnectionsRequest {
    const message = createBaseSuggestConnectionsRequest();
    message.userId = object.userId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseSuggestConnectionsResponse(): SuggestConnectionsResponse {
  return { suggestions: [] };
}

export const SuggestConnectionsResponse: MessageFns<SuggestConnectionsResponse> = {
  encode(message: SuggestConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.suggestions) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.suggestions.push(User.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestConnectionsResponse {
    return {
      suggestions: globalThis.Array.isArray(object?.suggestions)
        ? object.suggestions.map((e: any) => User.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SuggestConnectionsResponse): unknown {
    const obj: any = {};
    if (message.suggestions?.length) {
      obj.suggestions = message.suggestions.map((e) => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SuggestConnectionsResponse>, I>>(base?: I): SuggestConnectionsResponse {
    return SuggestConnectionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SuggestConnectionsResponse>, I>>(object: I): SuggestConnectionsResponse {
    const message = createBaseSuggestConnectionsResponse();
    message.suggestions = object.suggestions?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListConnectionsRequest(): ListConnectionsRequest {
  return { userId: "", type: "", metadata: undefined };
}

export const ListConnectionsRequest: MessageFns<ListConnectionsRequest> = {
  encode(message: ListConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListConnectionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConnectionsRequest>, I>>(base?: I): ListConnectionsRequest {
    return ListConnectionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConnectionsRequest>, I>>(object: I): ListConnectionsRequest {
    const message = createBaseListConnectionsRequest();
    message.userId = object.userId ?? "";
    message.type = object.type ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListConnectionsResponse(): ListConnectionsResponse {
  return { users: [] };
}

export const ListConnectionsResponse: MessageFns<ListConnectionsResponse> = {
  encode(message: ListConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsResponse {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [] };
  },

  toJSON(message: ListConnectionsResponse): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConnectionsResponse>, I>>(base?: I): ListConnectionsResponse {
    return ListConnectionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConnectionsResponse>, I>>(object: I): ListConnectionsResponse {
    const message = createBaseListConnectionsResponse();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBlockUserRequest(): BlockUserRequest {
  return { userId: "", targetUserId: "", metadata: undefined };
}

export const BlockUserRequest: MessageFns<BlockUserRequest> = {
  encode(message: BlockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.targetUserId !== "") {
      writer.uint32(18).string(message.targetUserId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetUserId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      targetUserId: isSet(object.targetUserId) ? globalThis.String(object.targetUserId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: BlockUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.targetUserId !== "") {
      obj.targetUserId = message.targetUserId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserRequest>, I>>(base?: I): BlockUserRequest {
    return BlockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserRequest>, I>>(object: I): BlockUserRequest {
    const message = createBaseBlockUserRequest();
    message.userId = object.userId ?? "";
    message.targetUserId = object.targetUserId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseBlockUserResponse(): BlockUserResponse {
  return { success: false };
}

export const BlockUserResponse: MessageFns<BlockUserResponse> = {
  encode(message: BlockUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: BlockUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserResponse>, I>>(base?: I): BlockUserResponse {
    return BlockUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserResponse>, I>>(object: I): BlockUserResponse {
    const message = createBaseBlockUserResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseUnblockUserRequest(): UnblockUserRequest {
  return { targetUserId: "" };
}

export const UnblockUserRequest: MessageFns<UnblockUserRequest> = {
  encode(message: UnblockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetUserId !== "") {
      writer.uint32(10).string(message.targetUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnblockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnblockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnblockUserRequest {
    return { targetUserId: isSet(object.targetUserId) ? globalThis.String(object.targetUserId) : "" };
  },

  toJSON(message: UnblockUserRequest): unknown {
    const obj: any = {};
    if (message.targetUserId !== "") {
      obj.targetUserId = message.targetUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnblockUserRequest>, I>>(base?: I): UnblockUserRequest {
    return UnblockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnblockUserRequest>, I>>(object: I): UnblockUserRequest {
    const message = createBaseUnblockUserRequest();
    message.targetUserId = object.targetUserId ?? "";
    return message;
  },
};

function createBaseUnblockUserResponse(): UnblockUserResponse {
  return { success: false };
}

export const UnblockUserResponse: MessageFns<UnblockUserResponse> = {
  encode(message: UnblockUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnblockUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnblockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnblockUserResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UnblockUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnblockUserResponse>, I>>(base?: I): UnblockUserResponse {
    return UnblockUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnblockUserResponse>, I>>(object: I): UnblockUserResponse {
    const message = createBaseUnblockUserResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseMuteUserRequest(): MuteUserRequest {
  return { userId: "", targetUserId: "", durationMinutes: 0, metadata: undefined };
}

export const MuteUserRequest: MessageFns<MuteUserRequest> = {
  encode(message: MuteUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.targetUserId !== "") {
      writer.uint32(18).string(message.targetUserId);
    }
    if (message.durationMinutes !== 0) {
      writer.uint32(24).int32(message.durationMinutes);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetUserId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.durationMinutes = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteUserRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      targetUserId: isSet(object.targetUserId) ? globalThis.String(object.targetUserId) : "",
      durationMinutes: isSet(object.durationMinutes) ? globalThis.Number(object.durationMinutes) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: MuteUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.targetUserId !== "") {
      obj.targetUserId = message.targetUserId;
    }
    if (message.durationMinutes !== 0) {
      obj.durationMinutes = Math.round(message.durationMinutes);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MuteUserRequest>, I>>(base?: I): MuteUserRequest {
    return MuteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MuteUserRequest>, I>>(object: I): MuteUserRequest {
    const message = createBaseMuteUserRequest();
    message.userId = object.userId ?? "";
    message.targetUserId = object.targetUserId ?? "";
    message.durationMinutes = object.durationMinutes ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseMuteUserResponse(): MuteUserResponse {
  return { success: false };
}

export const MuteUserResponse: MessageFns<MuteUserResponse> = {
  encode(message: MuteUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteUserResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: MuteUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MuteUserResponse>, I>>(base?: I): MuteUserResponse {
    return MuteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MuteUserResponse>, I>>(object: I): MuteUserResponse {
    const message = createBaseMuteUserResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseUnmuteUserRequest(): UnmuteUserRequest {
  return { targetUserId: "" };
}

export const UnmuteUserRequest: MessageFns<UnmuteUserRequest> = {
  encode(message: UnmuteUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetUserId !== "") {
      writer.uint32(10).string(message.targetUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnmuteUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnmuteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnmuteUserRequest {
    return { targetUserId: isSet(object.targetUserId) ? globalThis.String(object.targetUserId) : "" };
  },

  toJSON(message: UnmuteUserRequest): unknown {
    const obj: any = {};
    if (message.targetUserId !== "") {
      obj.targetUserId = message.targetUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnmuteUserRequest>, I>>(base?: I): UnmuteUserRequest {
    return UnmuteUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnmuteUserRequest>, I>>(object: I): UnmuteUserRequest {
    const message = createBaseUnmuteUserRequest();
    message.targetUserId = object.targetUserId ?? "";
    return message;
  },
};

function createBaseUnmuteUserResponse(): UnmuteUserResponse {
  return { success: false };
}

export const UnmuteUserResponse: MessageFns<UnmuteUserResponse> = {
  encode(message: UnmuteUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnmuteUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnmuteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnmuteUserResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UnmuteUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnmuteUserResponse>, I>>(base?: I): UnmuteUserResponse {
    return UnmuteUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnmuteUserResponse>, I>>(object: I): UnmuteUserResponse {
    const message = createBaseUnmuteUserResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseReportUserRequest(): ReportUserRequest {
  return { reporterUserId: "", reportedUserId: "", reason: "", details: "", metadata: undefined };
}

export const ReportUserRequest: MessageFns<ReportUserRequest> = {
  encode(message: ReportUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reporterUserId !== "") {
      writer.uint32(10).string(message.reporterUserId);
    }
    if (message.reportedUserId !== "") {
      writer.uint32(18).string(message.reportedUserId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.details !== "") {
      writer.uint32(34).string(message.details);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reporterUserId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reportedUserId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportUserRequest {
    return {
      reporterUserId: isSet(object.reporterUserId) ? globalThis.String(object.reporterUserId) : "",
      reportedUserId: isSet(object.reportedUserId) ? globalThis.String(object.reportedUserId) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ReportUserRequest): unknown {
    const obj: any = {};
    if (message.reporterUserId !== "") {
      obj.reporterUserId = message.reporterUserId;
    }
    if (message.reportedUserId !== "") {
      obj.reportedUserId = message.reportedUserId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReportUserRequest>, I>>(base?: I): ReportUserRequest {
    return ReportUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReportUserRequest>, I>>(object: I): ReportUserRequest {
    const message = createBaseReportUserRequest();
    message.reporterUserId = object.reporterUserId ?? "";
    message.reportedUserId = object.reportedUserId ?? "";
    message.reason = object.reason ?? "";
    message.details = object.details ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseReportUserResponse(): ReportUserResponse {
  return { success: false, reportId: "" };
}

export const ReportUserResponse: MessageFns<ReportUserResponse> = {
  encode(message: ReportUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.reportId !== "") {
      writer.uint32(18).string(message.reportId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reportId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportUserResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      reportId: isSet(object.reportId) ? globalThis.String(object.reportId) : "",
    };
  },

  toJSON(message: ReportUserResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.reportId !== "") {
      obj.reportId = message.reportId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReportUserResponse>, I>>(base?: I): ReportUserResponse {
    return ReportUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReportUserResponse>, I>>(object: I): ReportUserResponse {
    const message = createBaseReportUserResponse();
    message.success = object.success ?? false;
    message.reportId = object.reportId ?? "";
    return message;
  },
};

function createBaseBlockGroupContentRequest(): BlockGroupContentRequest {
  return { userId: "", groupId: "", contentId: "", metadata: undefined };
}

export const BlockGroupContentRequest: MessageFns<BlockGroupContentRequest> = {
  encode(message: BlockGroupContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    if (message.contentId !== "") {
      writer.uint32(26).string(message.contentId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockGroupContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockGroupContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockGroupContentRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: BlockGroupContentRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockGroupContentRequest>, I>>(base?: I): BlockGroupContentRequest {
    return BlockGroupContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockGroupContentRequest>, I>>(object: I): BlockGroupContentRequest {
    const message = createBaseBlockGroupContentRequest();
    message.userId = object.userId ?? "";
    message.groupId = object.groupId ?? "";
    message.contentId = object.contentId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseBlockGroupContentResponse(): BlockGroupContentResponse {
  return { success: false };
}

export const BlockGroupContentResponse: MessageFns<BlockGroupContentResponse> = {
  encode(message: BlockGroupContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockGroupContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockGroupContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockGroupContentResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: BlockGroupContentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockGroupContentResponse>, I>>(base?: I): BlockGroupContentResponse {
    return BlockGroupContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockGroupContentResponse>, I>>(object: I): BlockGroupContentResponse {
    const message = createBaseBlockGroupContentResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseReportGroupContentRequest(): ReportGroupContentRequest {
  return { reporterUserId: "", groupId: "", contentId: "", reason: "", details: "", metadata: undefined };
}

export const ReportGroupContentRequest: MessageFns<ReportGroupContentRequest> = {
  encode(message: ReportGroupContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reporterUserId !== "") {
      writer.uint32(10).string(message.reporterUserId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    if (message.contentId !== "") {
      writer.uint32(26).string(message.contentId);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    if (message.details !== "") {
      writer.uint32(42).string(message.details);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportGroupContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportGroupContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reporterUserId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportGroupContentRequest {
    return {
      reporterUserId: isSet(object.reporterUserId) ? globalThis.String(object.reporterUserId) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ReportGroupContentRequest): unknown {
    const obj: any = {};
    if (message.reporterUserId !== "") {
      obj.reporterUserId = message.reporterUserId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReportGroupContentRequest>, I>>(base?: I): ReportGroupContentRequest {
    return ReportGroupContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReportGroupContentRequest>, I>>(object: I): ReportGroupContentRequest {
    const message = createBaseReportGroupContentRequest();
    message.reporterUserId = object.reporterUserId ?? "";
    message.groupId = object.groupId ?? "";
    message.contentId = object.contentId ?? "";
    message.reason = object.reason ?? "";
    message.details = object.details ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseReportGroupContentResponse(): ReportGroupContentResponse {
  return { success: false, reportId: "" };
}

export const ReportGroupContentResponse: MessageFns<ReportGroupContentResponse> = {
  encode(message: ReportGroupContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.reportId !== "") {
      writer.uint32(18).string(message.reportId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportGroupContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportGroupContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reportId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportGroupContentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      reportId: isSet(object.reportId) ? globalThis.String(object.reportId) : "",
    };
  },

  toJSON(message: ReportGroupContentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.reportId !== "") {
      obj.reportId = message.reportId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReportGroupContentResponse>, I>>(base?: I): ReportGroupContentResponse {
    return ReportGroupContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReportGroupContentResponse>, I>>(object: I): ReportGroupContentResponse {
    const message = createBaseReportGroupContentResponse();
    message.success = object.success ?? false;
    message.reportId = object.reportId ?? "";
    return message;
  },
};

function createBaseMuteGroupContentRequest(): MuteGroupContentRequest {
  return { userId: "", groupId: "", contentId: "", durationMinutes: 0, metadata: undefined };
}

export const MuteGroupContentRequest: MessageFns<MuteGroupContentRequest> = {
  encode(message: MuteGroupContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    if (message.contentId !== "") {
      writer.uint32(26).string(message.contentId);
    }
    if (message.durationMinutes !== 0) {
      writer.uint32(32).int32(message.durationMinutes);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteGroupContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteGroupContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.durationMinutes = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteGroupContentRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      durationMinutes: isSet(object.durationMinutes) ? globalThis.Number(object.durationMinutes) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: MuteGroupContentRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.durationMinutes !== 0) {
      obj.durationMinutes = Math.round(message.durationMinutes);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MuteGroupContentRequest>, I>>(base?: I): MuteGroupContentRequest {
    return MuteGroupContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MuteGroupContentRequest>, I>>(object: I): MuteGroupContentRequest {
    const message = createBaseMuteGroupContentRequest();
    message.userId = object.userId ?? "";
    message.groupId = object.groupId ?? "";
    message.contentId = object.contentId ?? "";
    message.durationMinutes = object.durationMinutes ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseMuteGroupContentResponse(): MuteGroupContentResponse {
  return { success: false };
}

export const MuteGroupContentResponse: MessageFns<MuteGroupContentResponse> = {
  encode(message: MuteGroupContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteGroupContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteGroupContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteGroupContentResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: MuteGroupContentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MuteGroupContentResponse>, I>>(base?: I): MuteGroupContentResponse {
    return MuteGroupContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MuteGroupContentResponse>, I>>(object: I): MuteGroupContentResponse {
    const message = createBaseMuteGroupContentResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseMuteGroupIndividualsRequest(): MuteGroupIndividualsRequest {
  return { userId: "", groupId: "", durationMinutes: 0, metadata: undefined };
}

export const MuteGroupIndividualsRequest: MessageFns<MuteGroupIndividualsRequest> = {
  encode(message: MuteGroupIndividualsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    if (message.durationMinutes !== 0) {
      writer.uint32(24).int32(message.durationMinutes);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteGroupIndividualsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteGroupIndividualsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.durationMinutes = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteGroupIndividualsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      durationMinutes: isSet(object.durationMinutes) ? globalThis.Number(object.durationMinutes) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: MuteGroupIndividualsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.durationMinutes !== 0) {
      obj.durationMinutes = Math.round(message.durationMinutes);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MuteGroupIndividualsRequest>, I>>(base?: I): MuteGroupIndividualsRequest {
    return MuteGroupIndividualsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MuteGroupIndividualsRequest>, I>>(object: I): MuteGroupIndividualsRequest {
    const message = createBaseMuteGroupIndividualsRequest();
    message.userId = object.userId ?? "";
    message.groupId = object.groupId ?? "";
    message.durationMinutes = object.durationMinutes ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseMuteGroupIndividualsResponse(): MuteGroupIndividualsResponse {
  return { success: false, mutedUserIds: [] };
}

export const MuteGroupIndividualsResponse: MessageFns<MuteGroupIndividualsResponse> = {
  encode(message: MuteGroupIndividualsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.mutedUserIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteGroupIndividualsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteGroupIndividualsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mutedUserIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteGroupIndividualsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      mutedUserIds: globalThis.Array.isArray(object?.mutedUserIds)
        ? object.mutedUserIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MuteGroupIndividualsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.mutedUserIds?.length) {
      obj.mutedUserIds = message.mutedUserIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MuteGroupIndividualsResponse>, I>>(base?: I): MuteGroupIndividualsResponse {
    return MuteGroupIndividualsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MuteGroupIndividualsResponse>, I>>(object: I): MuteGroupIndividualsResponse {
    const message = createBaseMuteGroupIndividualsResponse();
    message.success = object.success ?? false;
    message.mutedUserIds = object.mutedUserIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseBlockGroupIndividualsRequest(): BlockGroupIndividualsRequest {
  return { userId: "", groupId: "", durationMinutes: 0, metadata: undefined };
}

export const BlockGroupIndividualsRequest: MessageFns<BlockGroupIndividualsRequest> = {
  encode(message: BlockGroupIndividualsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    if (message.durationMinutes !== 0) {
      writer.uint32(24).int32(message.durationMinutes);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockGroupIndividualsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockGroupIndividualsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.durationMinutes = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockGroupIndividualsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      durationMinutes: isSet(object.durationMinutes) ? globalThis.Number(object.durationMinutes) : 0,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: BlockGroupIndividualsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.durationMinutes !== 0) {
      obj.durationMinutes = Math.round(message.durationMinutes);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockGroupIndividualsRequest>, I>>(base?: I): BlockGroupIndividualsRequest {
    return BlockGroupIndividualsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockGroupIndividualsRequest>, I>>(object: I): BlockGroupIndividualsRequest {
    const message = createBaseBlockGroupIndividualsRequest();
    message.userId = object.userId ?? "";
    message.groupId = object.groupId ?? "";
    message.durationMinutes = object.durationMinutes ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseBlockGroupIndividualsResponse(): BlockGroupIndividualsResponse {
  return { success: false, blockedUserIds: [] };
}

export const BlockGroupIndividualsResponse: MessageFns<BlockGroupIndividualsResponse> = {
  encode(message: BlockGroupIndividualsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.blockedUserIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockGroupIndividualsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockGroupIndividualsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockedUserIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockGroupIndividualsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      blockedUserIds: globalThis.Array.isArray(object?.blockedUserIds)
        ? object.blockedUserIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BlockGroupIndividualsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.blockedUserIds?.length) {
      obj.blockedUserIds = message.blockedUserIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockGroupIndividualsResponse>, I>>(base?: I): BlockGroupIndividualsResponse {
    return BlockGroupIndividualsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockGroupIndividualsResponse>, I>>(
    object: I,
  ): BlockGroupIndividualsResponse {
    const message = createBaseBlockGroupIndividualsResponse();
    message.success = object.success ?? false;
    message.blockedUserIds = object.blockedUserIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUnmuteGroupRequest(): UnmuteGroupRequest {
  return { userId: "", groupId: "" };
}

export const UnmuteGroupRequest: MessageFns<UnmuteGroupRequest> = {
  encode(message: UnmuteGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnmuteGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnmuteGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnmuteGroupRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
    };
  },

  toJSON(message: UnmuteGroupRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnmuteGroupRequest>, I>>(base?: I): UnmuteGroupRequest {
    return UnmuteGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnmuteGroupRequest>, I>>(object: I): UnmuteGroupRequest {
    const message = createBaseUnmuteGroupRequest();
    message.userId = object.userId ?? "";
    message.groupId = object.groupId ?? "";
    return message;
  },
};

function createBaseUnmuteGroupResponse(): UnmuteGroupResponse {
  return { success: false };
}

export const UnmuteGroupResponse: MessageFns<UnmuteGroupResponse> = {
  encode(message: UnmuteGroupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnmuteGroupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnmuteGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnmuteGroupResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UnmuteGroupResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnmuteGroupResponse>, I>>(base?: I): UnmuteGroupResponse {
    return UnmuteGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnmuteGroupResponse>, I>>(object: I): UnmuteGroupResponse {
    const message = createBaseUnmuteGroupResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseUnmuteGroupIndividualsRequest(): UnmuteGroupIndividualsRequest {
  return { userId: "", groupId: "", targetUserIds: [] };
}

export const UnmuteGroupIndividualsRequest: MessageFns<UnmuteGroupIndividualsRequest> = {
  encode(message: UnmuteGroupIndividualsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    for (const v of message.targetUserIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnmuteGroupIndividualsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnmuteGroupIndividualsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetUserIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnmuteGroupIndividualsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      targetUserIds: globalThis.Array.isArray(object?.targetUserIds)
        ? object.targetUserIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UnmuteGroupIndividualsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.targetUserIds?.length) {
      obj.targetUserIds = message.targetUserIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnmuteGroupIndividualsRequest>, I>>(base?: I): UnmuteGroupIndividualsRequest {
    return UnmuteGroupIndividualsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnmuteGroupIndividualsRequest>, I>>(
    object: I,
  ): UnmuteGroupIndividualsRequest {
    const message = createBaseUnmuteGroupIndividualsRequest();
    message.userId = object.userId ?? "";
    message.groupId = object.groupId ?? "";
    message.targetUserIds = object.targetUserIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUnmuteGroupIndividualsResponse(): UnmuteGroupIndividualsResponse {
  return { success: false, unmutedUserIds: [] };
}

export const UnmuteGroupIndividualsResponse: MessageFns<UnmuteGroupIndividualsResponse> = {
  encode(message: UnmuteGroupIndividualsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.unmutedUserIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnmuteGroupIndividualsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnmuteGroupIndividualsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unmutedUserIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnmuteGroupIndividualsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      unmutedUserIds: globalThis.Array.isArray(object?.unmutedUserIds)
        ? object.unmutedUserIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UnmuteGroupIndividualsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.unmutedUserIds?.length) {
      obj.unmutedUserIds = message.unmutedUserIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnmuteGroupIndividualsResponse>, I>>(base?: I): UnmuteGroupIndividualsResponse {
    return UnmuteGroupIndividualsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnmuteGroupIndividualsResponse>, I>>(
    object: I,
  ): UnmuteGroupIndividualsResponse {
    const message = createBaseUnmuteGroupIndividualsResponse();
    message.success = object.success ?? false;
    message.unmutedUserIds = object.unmutedUserIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUnblockGroupIndividualsRequest(): UnblockGroupIndividualsRequest {
  return { userId: "", groupId: "", targetUserIds: [] };
}

export const UnblockGroupIndividualsRequest: MessageFns<UnblockGroupIndividualsRequest> = {
  encode(message: UnblockGroupIndividualsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    for (const v of message.targetUserIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnblockGroupIndividualsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnblockGroupIndividualsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetUserIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnblockGroupIndividualsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      targetUserIds: globalThis.Array.isArray(object?.targetUserIds)
        ? object.targetUserIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UnblockGroupIndividualsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.targetUserIds?.length) {
      obj.targetUserIds = message.targetUserIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnblockGroupIndividualsRequest>, I>>(base?: I): UnblockGroupIndividualsRequest {
    return UnblockGroupIndividualsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnblockGroupIndividualsRequest>, I>>(
    object: I,
  ): UnblockGroupIndividualsRequest {
    const message = createBaseUnblockGroupIndividualsRequest();
    message.userId = object.userId ?? "";
    message.groupId = object.groupId ?? "";
    message.targetUserIds = object.targetUserIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseUnblockGroupIndividualsResponse(): UnblockGroupIndividualsResponse {
  return { success: false, unblockedUserIds: [] };
}

export const UnblockGroupIndividualsResponse: MessageFns<UnblockGroupIndividualsResponse> = {
  encode(message: UnblockGroupIndividualsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.unblockedUserIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnblockGroupIndividualsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnblockGroupIndividualsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unblockedUserIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnblockGroupIndividualsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      unblockedUserIds: globalThis.Array.isArray(object?.unblockedUserIds)
        ? object.unblockedUserIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UnblockGroupIndividualsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.unblockedUserIds?.length) {
      obj.unblockedUserIds = message.unblockedUserIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnblockGroupIndividualsResponse>, I>>(base?: I): UnblockGroupIndividualsResponse {
    return UnblockGroupIndividualsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnblockGroupIndividualsResponse>, I>>(
    object: I,
  ): UnblockGroupIndividualsResponse {
    const message = createBaseUnblockGroupIndividualsResponse();
    message.success = object.success ?? false;
    message.unblockedUserIds = object.unblockedUserIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseRegisterInterestRequest(): RegisterInterestRequest {
  return { email: "" };
}

export const RegisterInterestRequest: MessageFns<RegisterInterestRequest> = {
  encode(message: RegisterInterestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterInterestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterInterestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterInterestRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: RegisterInterestRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterInterestRequest>, I>>(base?: I): RegisterInterestRequest {
    return RegisterInterestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterInterestRequest>, I>>(object: I): RegisterInterestRequest {
    const message = createBaseRegisterInterestRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseRegisterInterestResponse(): RegisterInterestResponse {
  return { user: undefined };
}

export const RegisterInterestResponse: MessageFns<RegisterInterestResponse> = {
  encode(message: RegisterInterestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterInterestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterInterestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterInterestResponse {
    return { user: isSet(object.user) ? User.fromJSON(object.user) : undefined };
  },

  toJSON(message: RegisterInterestResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterInterestResponse>, I>>(base?: I): RegisterInterestResponse {
    return RegisterInterestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterInterestResponse>, I>>(object: I): RegisterInterestResponse {
    const message = createBaseRegisterInterestResponse();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseCreateReferralRequest(): CreateReferralRequest {
  return { userId: "", campaignSlug: "" };
}

export const CreateReferralRequest: MessageFns<CreateReferralRequest> = {
  encode(message: CreateReferralRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.campaignSlug !== "") {
      writer.uint32(18).string(message.campaignSlug);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReferralRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReferralRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.campaignSlug = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReferralRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      campaignSlug: isSet(object.campaignSlug) ? globalThis.String(object.campaignSlug) : "",
    };
  },

  toJSON(message: CreateReferralRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.campaignSlug !== "") {
      obj.campaignSlug = message.campaignSlug;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateReferralRequest>, I>>(base?: I): CreateReferralRequest {
    return CreateReferralRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateReferralRequest>, I>>(object: I): CreateReferralRequest {
    const message = createBaseCreateReferralRequest();
    message.userId = object.userId ?? "";
    message.campaignSlug = object.campaignSlug ?? "";
    return message;
  },
};

function createBaseCreateReferralResponse(): CreateReferralResponse {
  return { referralCode: "", success: false };
}

export const CreateReferralResponse: MessageFns<CreateReferralResponse> = {
  encode(message: CreateReferralResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referralCode !== "") {
      writer.uint32(10).string(message.referralCode);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReferralResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReferralResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referralCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReferralResponse {
    return {
      referralCode: isSet(object.referralCode) ? globalThis.String(object.referralCode) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
    };
  },

  toJSON(message: CreateReferralResponse): unknown {
    const obj: any = {};
    if (message.referralCode !== "") {
      obj.referralCode = message.referralCode;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateReferralResponse>, I>>(base?: I): CreateReferralResponse {
    return CreateReferralResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateReferralResponse>, I>>(object: I): CreateReferralResponse {
    const message = createBaseCreateReferralResponse();
    message.referralCode = object.referralCode ?? "";
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseRefreshSessionRequest(): RefreshSessionRequest {
  return { refreshToken: "" };
}

export const RefreshSessionRequest: MessageFns<RefreshSessionRequest> = {
  encode(message: RefreshSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshSessionRequest {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: RefreshSessionRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshSessionRequest>, I>>(base?: I): RefreshSessionRequest {
    return RefreshSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshSessionRequest>, I>>(object: I): RefreshSessionRequest {
    const message = createBaseRefreshSessionRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseRefreshSessionResponse(): RefreshSessionResponse {
  return { refreshToken: "", accessToken: "" };
}

export const RefreshSessionResponse: MessageFns<RefreshSessionResponse> = {
  encode(message: RefreshSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshSessionResponse {
    return {
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
    };
  },

  toJSON(message: RefreshSessionResponse): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshSessionResponse>, I>>(base?: I): RefreshSessionResponse {
    return RefreshSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshSessionResponse>, I>>(object: I): RefreshSessionResponse {
    const message = createBaseRefreshSessionResponse();
    message.refreshToken = object.refreshToken ?? "";
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

/** --- User Service: Full Social, Account, and Metadata API --- */
export interface UserService {
  /** --- User Management --- */
  CreateUser(request: CreateUserRequest): Promise<CreateUserResponse>;
  GetUser(request: GetUserRequest): Promise<GetUserResponse>;
  GetUserByUsername(request: GetUserByUsernameRequest): Promise<GetUserByUsernameResponse>;
  GetUserByEmail(request: GetUserByEmailRequest): Promise<GetUserByEmailResponse>;
  UpdateUser(request: UpdateUserRequest): Promise<UpdateUserResponse>;
  DeleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse>;
  ListUsers(request: ListUsersRequest): Promise<ListUsersResponse>;
  UpdatePassword(request: UpdatePasswordRequest): Promise<UpdatePasswordResponse>;
  UpdateProfile(request: UpdateProfileRequest): Promise<UpdateProfileResponse>;
  RegisterInterest(request: RegisterInterestRequest): Promise<RegisterInterestResponse>;
  CreateReferral(request: CreateReferralRequest): Promise<CreateReferralResponse>;
  /** --- Session Management --- */
  CreateSession(request: CreateSessionRequest): Promise<CreateSessionResponse>;
  GetSession(request: GetSessionRequest): Promise<GetSessionResponse>;
  RevokeSession(request: RevokeSessionRequest): Promise<RevokeSessionResponse>;
  ListSessions(request: ListSessionsRequest): Promise<ListSessionsResponse>;
  /** --- RBAC & Permissions --- */
  AssignRole(request: AssignRoleRequest): Promise<AssignRoleResponse>;
  RemoveRole(request: RemoveRoleRequest): Promise<RemoveRoleResponse>;
  ListRoles(request: ListRolesRequest): Promise<ListRolesResponse>;
  ListPermissions(request: ListPermissionsRequest): Promise<ListPermissionsResponse>;
  /** --- Audit/Event Log --- */
  ListUserEvents(request: ListUserEventsRequest): Promise<ListUserEventsResponse>;
  ListAuditLogs(request: ListAuditLogsRequest): Promise<ListAuditLogsResponse>;
  /** --- SSO, MFA, SCIM Extensibility --- */
  InitiateSSO(request: InitiateSSORequest): Promise<InitiateSSOResponse>;
  InitiateMFA(request: InitiateMFARequest): Promise<InitiateMFAResponse>;
  SyncSCIM(request: SyncSCIMRequest): Promise<SyncSCIMResponse>;
  /** --- Social Graph APIs --- */
  AddFriend(request: AddFriendRequest): Promise<AddFriendResponse>;
  RemoveFriend(request: RemoveFriendRequest): Promise<RemoveFriendResponse>;
  ListFriends(request: ListFriendsRequest): Promise<ListFriendsResponse>;
  FollowUser(request: FollowUserRequest): Promise<FollowUserResponse>;
  UnfollowUser(request: UnfollowUserRequest): Promise<UnfollowUserResponse>;
  ListFollowers(request: ListFollowersRequest): Promise<ListFollowersResponse>;
  ListFollowing(request: ListFollowingRequest): Promise<ListFollowingResponse>;
  /** --- Group APIs --- */
  CreateUserGroup(request: CreateUserGroupRequest): Promise<CreateUserGroupResponse>;
  UpdateUserGroup(request: UpdateUserGroupRequest): Promise<UpdateUserGroupResponse>;
  DeleteUserGroup(request: DeleteUserGroupRequest): Promise<DeleteUserGroupResponse>;
  ListUserGroups(request: ListUserGroupsRequest): Promise<ListUserGroupsResponse>;
  ListUserGroupMembers(request: ListUserGroupMembersRequest): Promise<ListUserGroupMembersResponse>;
  /** --- Social Graph Discovery --- */
  SuggestConnections(request: SuggestConnectionsRequest): Promise<SuggestConnectionsResponse>;
  ListConnections(request: ListConnectionsRequest): Promise<ListConnectionsResponse>;
  /** --- Moderation/Interaction APIs --- */
  BlockUser(request: BlockUserRequest): Promise<BlockUserResponse>;
  UnblockUser(request: UnblockUserRequest): Promise<UnblockUserResponse>;
  MuteUser(request: MuteUserRequest): Promise<MuteUserResponse>;
  UnmuteUser(request: UnmuteUserRequest): Promise<UnmuteUserResponse>;
  ReportUser(request: ReportUserRequest): Promise<ReportUserResponse>;
  /** For group/content moderation: */
  BlockGroupContent(request: BlockGroupContentRequest): Promise<BlockGroupContentResponse>;
  ReportGroupContent(request: ReportGroupContentRequest): Promise<ReportGroupContentResponse>;
  MuteGroupContent(request: MuteGroupContentRequest): Promise<MuteGroupContentResponse>;
  /** Mute all members of a group (optionally, with a duration) */
  MuteGroupIndividuals(request: MuteGroupIndividualsRequest): Promise<MuteGroupIndividualsResponse>;
  /** Block all members of a group (optionally, with a duration) */
  BlockGroupIndividuals(request: BlockGroupIndividualsRequest): Promise<BlockGroupIndividualsResponse>;
  UnmuteGroup(request: UnmuteGroupRequest): Promise<UnmuteGroupResponse>;
  UnmuteGroupIndividuals(request: UnmuteGroupIndividualsRequest): Promise<UnmuteGroupIndividualsResponse>;
  UnblockGroupIndividuals(request: UnblockGroupIndividualsRequest): Promise<UnblockGroupIndividualsResponse>;
  RefreshSession(request: RefreshSessionRequest): Promise<RefreshSessionResponse>;
}

export const UserServiceServiceName = "user.v1.UserService";
export class UserServiceClientImpl implements UserService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || UserServiceServiceName;
    this.rpc = rpc;
    this.CreateUser = this.CreateUser.bind(this);
    this.GetUser = this.GetUser.bind(this);
    this.GetUserByUsername = this.GetUserByUsername.bind(this);
    this.GetUserByEmail = this.GetUserByEmail.bind(this);
    this.UpdateUser = this.UpdateUser.bind(this);
    this.DeleteUser = this.DeleteUser.bind(this);
    this.ListUsers = this.ListUsers.bind(this);
    this.UpdatePassword = this.UpdatePassword.bind(this);
    this.UpdateProfile = this.UpdateProfile.bind(this);
    this.RegisterInterest = this.RegisterInterest.bind(this);
    this.CreateReferral = this.CreateReferral.bind(this);
    this.CreateSession = this.CreateSession.bind(this);
    this.GetSession = this.GetSession.bind(this);
    this.RevokeSession = this.RevokeSession.bind(this);
    this.ListSessions = this.ListSessions.bind(this);
    this.AssignRole = this.AssignRole.bind(this);
    this.RemoveRole = this.RemoveRole.bind(this);
    this.ListRoles = this.ListRoles.bind(this);
    this.ListPermissions = this.ListPermissions.bind(this);
    this.ListUserEvents = this.ListUserEvents.bind(this);
    this.ListAuditLogs = this.ListAuditLogs.bind(this);
    this.InitiateSSO = this.InitiateSSO.bind(this);
    this.InitiateMFA = this.InitiateMFA.bind(this);
    this.SyncSCIM = this.SyncSCIM.bind(this);
    this.AddFriend = this.AddFriend.bind(this);
    this.RemoveFriend = this.RemoveFriend.bind(this);
    this.ListFriends = this.ListFriends.bind(this);
    this.FollowUser = this.FollowUser.bind(this);
    this.UnfollowUser = this.UnfollowUser.bind(this);
    this.ListFollowers = this.ListFollowers.bind(this);
    this.ListFollowing = this.ListFollowing.bind(this);
    this.CreateUserGroup = this.CreateUserGroup.bind(this);
    this.UpdateUserGroup = this.UpdateUserGroup.bind(this);
    this.DeleteUserGroup = this.DeleteUserGroup.bind(this);
    this.ListUserGroups = this.ListUserGroups.bind(this);
    this.ListUserGroupMembers = this.ListUserGroupMembers.bind(this);
    this.SuggestConnections = this.SuggestConnections.bind(this);
    this.ListConnections = this.ListConnections.bind(this);
    this.BlockUser = this.BlockUser.bind(this);
    this.UnblockUser = this.UnblockUser.bind(this);
    this.MuteUser = this.MuteUser.bind(this);
    this.UnmuteUser = this.UnmuteUser.bind(this);
    this.ReportUser = this.ReportUser.bind(this);
    this.BlockGroupContent = this.BlockGroupContent.bind(this);
    this.ReportGroupContent = this.ReportGroupContent.bind(this);
    this.MuteGroupContent = this.MuteGroupContent.bind(this);
    this.MuteGroupIndividuals = this.MuteGroupIndividuals.bind(this);
    this.BlockGroupIndividuals = this.BlockGroupIndividuals.bind(this);
    this.UnmuteGroup = this.UnmuteGroup.bind(this);
    this.UnmuteGroupIndividuals = this.UnmuteGroupIndividuals.bind(this);
    this.UnblockGroupIndividuals = this.UnblockGroupIndividuals.bind(this);
    this.RefreshSession = this.RefreshSession.bind(this);
  }
  CreateUser(request: CreateUserRequest): Promise<CreateUserResponse> {
    const data = CreateUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateUser", data);
    return promise.then((data) => CreateUserResponse.decode(new BinaryReader(data)));
  }

  GetUser(request: GetUserRequest): Promise<GetUserResponse> {
    const data = GetUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUser", data);
    return promise.then((data) => GetUserResponse.decode(new BinaryReader(data)));
  }

  GetUserByUsername(request: GetUserByUsernameRequest): Promise<GetUserByUsernameResponse> {
    const data = GetUserByUsernameRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserByUsername", data);
    return promise.then((data) => GetUserByUsernameResponse.decode(new BinaryReader(data)));
  }

  GetUserByEmail(request: GetUserByEmailRequest): Promise<GetUserByEmailResponse> {
    const data = GetUserByEmailRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserByEmail", data);
    return promise.then((data) => GetUserByEmailResponse.decode(new BinaryReader(data)));
  }

  UpdateUser(request: UpdateUserRequest): Promise<UpdateUserResponse> {
    const data = UpdateUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUser", data);
    return promise.then((data) => UpdateUserResponse.decode(new BinaryReader(data)));
  }

  DeleteUser(request: DeleteUserRequest): Promise<DeleteUserResponse> {
    const data = DeleteUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteUser", data);
    return promise.then((data) => DeleteUserResponse.decode(new BinaryReader(data)));
  }

  ListUsers(request: ListUsersRequest): Promise<ListUsersResponse> {
    const data = ListUsersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListUsers", data);
    return promise.then((data) => ListUsersResponse.decode(new BinaryReader(data)));
  }

  UpdatePassword(request: UpdatePasswordRequest): Promise<UpdatePasswordResponse> {
    const data = UpdatePasswordRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdatePassword", data);
    return promise.then((data) => UpdatePasswordResponse.decode(new BinaryReader(data)));
  }

  UpdateProfile(request: UpdateProfileRequest): Promise<UpdateProfileResponse> {
    const data = UpdateProfileRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateProfile", data);
    return promise.then((data) => UpdateProfileResponse.decode(new BinaryReader(data)));
  }

  RegisterInterest(request: RegisterInterestRequest): Promise<RegisterInterestResponse> {
    const data = RegisterInterestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterInterest", data);
    return promise.then((data) => RegisterInterestResponse.decode(new BinaryReader(data)));
  }

  CreateReferral(request: CreateReferralRequest): Promise<CreateReferralResponse> {
    const data = CreateReferralRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateReferral", data);
    return promise.then((data) => CreateReferralResponse.decode(new BinaryReader(data)));
  }

  CreateSession(request: CreateSessionRequest): Promise<CreateSessionResponse> {
    const data = CreateSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateSession", data);
    return promise.then((data) => CreateSessionResponse.decode(new BinaryReader(data)));
  }

  GetSession(request: GetSessionRequest): Promise<GetSessionResponse> {
    const data = GetSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSession", data);
    return promise.then((data) => GetSessionResponse.decode(new BinaryReader(data)));
  }

  RevokeSession(request: RevokeSessionRequest): Promise<RevokeSessionResponse> {
    const data = RevokeSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RevokeSession", data);
    return promise.then((data) => RevokeSessionResponse.decode(new BinaryReader(data)));
  }

  ListSessions(request: ListSessionsRequest): Promise<ListSessionsResponse> {
    const data = ListSessionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListSessions", data);
    return promise.then((data) => ListSessionsResponse.decode(new BinaryReader(data)));
  }

  AssignRole(request: AssignRoleRequest): Promise<AssignRoleResponse> {
    const data = AssignRoleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AssignRole", data);
    return promise.then((data) => AssignRoleResponse.decode(new BinaryReader(data)));
  }

  RemoveRole(request: RemoveRoleRequest): Promise<RemoveRoleResponse> {
    const data = RemoveRoleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveRole", data);
    return promise.then((data) => RemoveRoleResponse.decode(new BinaryReader(data)));
  }

  ListRoles(request: ListRolesRequest): Promise<ListRolesResponse> {
    const data = ListRolesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListRoles", data);
    return promise.then((data) => ListRolesResponse.decode(new BinaryReader(data)));
  }

  ListPermissions(request: ListPermissionsRequest): Promise<ListPermissionsResponse> {
    const data = ListPermissionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListPermissions", data);
    return promise.then((data) => ListPermissionsResponse.decode(new BinaryReader(data)));
  }

  ListUserEvents(request: ListUserEventsRequest): Promise<ListUserEventsResponse> {
    const data = ListUserEventsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListUserEvents", data);
    return promise.then((data) => ListUserEventsResponse.decode(new BinaryReader(data)));
  }

  ListAuditLogs(request: ListAuditLogsRequest): Promise<ListAuditLogsResponse> {
    const data = ListAuditLogsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListAuditLogs", data);
    return promise.then((data) => ListAuditLogsResponse.decode(new BinaryReader(data)));
  }

  InitiateSSO(request: InitiateSSORequest): Promise<InitiateSSOResponse> {
    const data = InitiateSSORequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InitiateSSO", data);
    return promise.then((data) => InitiateSSOResponse.decode(new BinaryReader(data)));
  }

  InitiateMFA(request: InitiateMFARequest): Promise<InitiateMFAResponse> {
    const data = InitiateMFARequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InitiateMFA", data);
    return promise.then((data) => InitiateMFAResponse.decode(new BinaryReader(data)));
  }

  SyncSCIM(request: SyncSCIMRequest): Promise<SyncSCIMResponse> {
    const data = SyncSCIMRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SyncSCIM", data);
    return promise.then((data) => SyncSCIMResponse.decode(new BinaryReader(data)));
  }

  AddFriend(request: AddFriendRequest): Promise<AddFriendResponse> {
    const data = AddFriendRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddFriend", data);
    return promise.then((data) => AddFriendResponse.decode(new BinaryReader(data)));
  }

  RemoveFriend(request: RemoveFriendRequest): Promise<RemoveFriendResponse> {
    const data = RemoveFriendRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveFriend", data);
    return promise.then((data) => RemoveFriendResponse.decode(new BinaryReader(data)));
  }

  ListFriends(request: ListFriendsRequest): Promise<ListFriendsResponse> {
    const data = ListFriendsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListFriends", data);
    return promise.then((data) => ListFriendsResponse.decode(new BinaryReader(data)));
  }

  FollowUser(request: FollowUserRequest): Promise<FollowUserResponse> {
    const data = FollowUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FollowUser", data);
    return promise.then((data) => FollowUserResponse.decode(new BinaryReader(data)));
  }

  UnfollowUser(request: UnfollowUserRequest): Promise<UnfollowUserResponse> {
    const data = UnfollowUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnfollowUser", data);
    return promise.then((data) => UnfollowUserResponse.decode(new BinaryReader(data)));
  }

  ListFollowers(request: ListFollowersRequest): Promise<ListFollowersResponse> {
    const data = ListFollowersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListFollowers", data);
    return promise.then((data) => ListFollowersResponse.decode(new BinaryReader(data)));
  }

  ListFollowing(request: ListFollowingRequest): Promise<ListFollowingResponse> {
    const data = ListFollowingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListFollowing", data);
    return promise.then((data) => ListFollowingResponse.decode(new BinaryReader(data)));
  }

  CreateUserGroup(request: CreateUserGroupRequest): Promise<CreateUserGroupResponse> {
    const data = CreateUserGroupRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateUserGroup", data);
    return promise.then((data) => CreateUserGroupResponse.decode(new BinaryReader(data)));
  }

  UpdateUserGroup(request: UpdateUserGroupRequest): Promise<UpdateUserGroupResponse> {
    const data = UpdateUserGroupRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUserGroup", data);
    return promise.then((data) => UpdateUserGroupResponse.decode(new BinaryReader(data)));
  }

  DeleteUserGroup(request: DeleteUserGroupRequest): Promise<DeleteUserGroupResponse> {
    const data = DeleteUserGroupRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteUserGroup", data);
    return promise.then((data) => DeleteUserGroupResponse.decode(new BinaryReader(data)));
  }

  ListUserGroups(request: ListUserGroupsRequest): Promise<ListUserGroupsResponse> {
    const data = ListUserGroupsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListUserGroups", data);
    return promise.then((data) => ListUserGroupsResponse.decode(new BinaryReader(data)));
  }

  ListUserGroupMembers(request: ListUserGroupMembersRequest): Promise<ListUserGroupMembersResponse> {
    const data = ListUserGroupMembersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListUserGroupMembers", data);
    return promise.then((data) => ListUserGroupMembersResponse.decode(new BinaryReader(data)));
  }

  SuggestConnections(request: SuggestConnectionsRequest): Promise<SuggestConnectionsResponse> {
    const data = SuggestConnectionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SuggestConnections", data);
    return promise.then((data) => SuggestConnectionsResponse.decode(new BinaryReader(data)));
  }

  ListConnections(request: ListConnectionsRequest): Promise<ListConnectionsResponse> {
    const data = ListConnectionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListConnections", data);
    return promise.then((data) => ListConnectionsResponse.decode(new BinaryReader(data)));
  }

  BlockUser(request: BlockUserRequest): Promise<BlockUserResponse> {
    const data = BlockUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BlockUser", data);
    return promise.then((data) => BlockUserResponse.decode(new BinaryReader(data)));
  }

  UnblockUser(request: UnblockUserRequest): Promise<UnblockUserResponse> {
    const data = UnblockUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnblockUser", data);
    return promise.then((data) => UnblockUserResponse.decode(new BinaryReader(data)));
  }

  MuteUser(request: MuteUserRequest): Promise<MuteUserResponse> {
    const data = MuteUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MuteUser", data);
    return promise.then((data) => MuteUserResponse.decode(new BinaryReader(data)));
  }

  UnmuteUser(request: UnmuteUserRequest): Promise<UnmuteUserResponse> {
    const data = UnmuteUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnmuteUser", data);
    return promise.then((data) => UnmuteUserResponse.decode(new BinaryReader(data)));
  }

  ReportUser(request: ReportUserRequest): Promise<ReportUserResponse> {
    const data = ReportUserRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ReportUser", data);
    return promise.then((data) => ReportUserResponse.decode(new BinaryReader(data)));
  }

  BlockGroupContent(request: BlockGroupContentRequest): Promise<BlockGroupContentResponse> {
    const data = BlockGroupContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BlockGroupContent", data);
    return promise.then((data) => BlockGroupContentResponse.decode(new BinaryReader(data)));
  }

  ReportGroupContent(request: ReportGroupContentRequest): Promise<ReportGroupContentResponse> {
    const data = ReportGroupContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ReportGroupContent", data);
    return promise.then((data) => ReportGroupContentResponse.decode(new BinaryReader(data)));
  }

  MuteGroupContent(request: MuteGroupContentRequest): Promise<MuteGroupContentResponse> {
    const data = MuteGroupContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MuteGroupContent", data);
    return promise.then((data) => MuteGroupContentResponse.decode(new BinaryReader(data)));
  }

  MuteGroupIndividuals(request: MuteGroupIndividualsRequest): Promise<MuteGroupIndividualsResponse> {
    const data = MuteGroupIndividualsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MuteGroupIndividuals", data);
    return promise.then((data) => MuteGroupIndividualsResponse.decode(new BinaryReader(data)));
  }

  BlockGroupIndividuals(request: BlockGroupIndividualsRequest): Promise<BlockGroupIndividualsResponse> {
    const data = BlockGroupIndividualsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BlockGroupIndividuals", data);
    return promise.then((data) => BlockGroupIndividualsResponse.decode(new BinaryReader(data)));
  }

  UnmuteGroup(request: UnmuteGroupRequest): Promise<UnmuteGroupResponse> {
    const data = UnmuteGroupRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnmuteGroup", data);
    return promise.then((data) => UnmuteGroupResponse.decode(new BinaryReader(data)));
  }

  UnmuteGroupIndividuals(request: UnmuteGroupIndividualsRequest): Promise<UnmuteGroupIndividualsResponse> {
    const data = UnmuteGroupIndividualsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnmuteGroupIndividuals", data);
    return promise.then((data) => UnmuteGroupIndividualsResponse.decode(new BinaryReader(data)));
  }

  UnblockGroupIndividuals(request: UnblockGroupIndividualsRequest): Promise<UnblockGroupIndividualsResponse> {
    const data = UnblockGroupIndividualsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnblockGroupIndividuals", data);
    return promise.then((data) => UnblockGroupIndividualsResponse.decode(new BinaryReader(data)));
  }

  RefreshSession(request: RefreshSessionRequest): Promise<RefreshSessionResponse> {
    const data = RefreshSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RefreshSession", data);
    return promise.then((data) => RefreshSessionResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
