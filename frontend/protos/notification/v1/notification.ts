// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: notification/v1/notification.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Metadata } from "../../common/v1/metadata";
import { Struct } from "../../google/protobuf/struct";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "notification.v1";

export enum NotificationStatus {
  NOTIFICATION_STATUS_UNSPECIFIED = 0,
  NOTIFICATION_STATUS_PENDING = 1,
  NOTIFICATION_STATUS_SENT = 2,
  NOTIFICATION_STATUS_DELIVERED = 3,
  NOTIFICATION_STATUS_FAILED = 4,
  NOTIFICATION_STATUS_READ = 5,
  UNRECOGNIZED = -1,
}

export function notificationStatusFromJSON(object: any): NotificationStatus {
  switch (object) {
    case 0:
    case "NOTIFICATION_STATUS_UNSPECIFIED":
      return NotificationStatus.NOTIFICATION_STATUS_UNSPECIFIED;
    case 1:
    case "NOTIFICATION_STATUS_PENDING":
      return NotificationStatus.NOTIFICATION_STATUS_PENDING;
    case 2:
    case "NOTIFICATION_STATUS_SENT":
      return NotificationStatus.NOTIFICATION_STATUS_SENT;
    case 3:
    case "NOTIFICATION_STATUS_DELIVERED":
      return NotificationStatus.NOTIFICATION_STATUS_DELIVERED;
    case 4:
    case "NOTIFICATION_STATUS_FAILED":
      return NotificationStatus.NOTIFICATION_STATUS_FAILED;
    case 5:
    case "NOTIFICATION_STATUS_READ":
      return NotificationStatus.NOTIFICATION_STATUS_READ;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationStatus.UNRECOGNIZED;
  }
}

export function notificationStatusToJSON(object: NotificationStatus): string {
  switch (object) {
    case NotificationStatus.NOTIFICATION_STATUS_UNSPECIFIED:
      return "NOTIFICATION_STATUS_UNSPECIFIED";
    case NotificationStatus.NOTIFICATION_STATUS_PENDING:
      return "NOTIFICATION_STATUS_PENDING";
    case NotificationStatus.NOTIFICATION_STATUS_SENT:
      return "NOTIFICATION_STATUS_SENT";
    case NotificationStatus.NOTIFICATION_STATUS_DELIVERED:
      return "NOTIFICATION_STATUS_DELIVERED";
    case NotificationStatus.NOTIFICATION_STATUS_FAILED:
      return "NOTIFICATION_STATUS_FAILED";
    case NotificationStatus.NOTIFICATION_STATUS_READ:
      return "NOTIFICATION_STATUS_READ";
    case NotificationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** --- Notification Core --- */
export interface Notification {
  id: string;
  /** Internal integer ID reference to master table */
  masterId: string;
  /** Global UUID reference */
  masterUuid: string;
  /** to master table */
  userId: string;
  /** campaign/tenant context */
  campaignId: string;
  /** email, sms, push, in_app, broadcast, etc. */
  channel: string;
  title: string;
  body: string;
  payload: { [key: string]: string };
  status: NotificationStatus;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  read: boolean;
  metadata?: Metadata | undefined;
}

export interface Notification_PayloadEntry {
  key: string;
  value: string;
}

export interface SendNotificationRequest {
  userId: string;
  channel: string;
  title: string;
  body: string;
  payload: { [key: string]: string };
  metadata?:
    | Metadata
    | undefined;
  /** campaign/tenant context */
  campaignId: string;
}

export interface SendNotificationRequest_PayloadEntry {
  key: string;
  value: string;
}

export interface SendNotificationResponse {
  notification?: Notification | undefined;
  status: string;
}

/** --- Channel-specific (compatibility) --- */
export interface SendEmailRequest {
  to: string;
  subject: string;
  body: string;
  metadata?: Metadata | undefined;
  html: boolean;
  /** campaign/tenant context */
  campaignId: string;
}

export interface SendEmailResponse {
  messageId: string;
  status: string;
  sentAt: string;
}

export interface SendSMSRequest {
  to: string;
  message: string;
  metadata?:
    | Metadata
    | undefined;
  /** campaign/tenant context */
  campaignId: string;
}

export interface SendSMSResponse {
  messageId: string;
  status: string;
  sentAt: string;
}

export interface SendPushNotificationRequest {
  userId: string;
  title: string;
  message: string;
  metadata?: Metadata | undefined;
  deepLink: string;
  /** campaign/tenant context */
  campaignId: string;
}

export interface SendPushNotificationResponse {
  notificationId: string;
  status: string;
  sentAt: string;
}

/** --- Broadcast/Event --- */
export interface BroadcastEventRequest {
  channel: string;
  subject: string;
  message: string;
  payload?: Metadata | undefined;
  scheduledAt?:
    | Date
    | undefined;
  /** campaign/tenant context */
  campaignId: string;
}

export interface BroadcastEventResponse {
  broadcastId: string;
  status: string;
  /** campaign/tenant context */
  campaignId: string;
}

/** --- Real-time Pub/Sub --- */
export interface SubscribeToEventsRequest {
  userId: string;
  channels: string[];
  filters?: Metadata | undefined;
}

export interface NotificationEvent {
  eventId: string;
  notificationId: string;
  userId: string;
  /** delivered, read, failed, etc. */
  eventType: string;
  payload?: { [key: string]: any } | undefined;
  createdAt?: Date | undefined;
}

/** --- Asset Streaming --- */
export interface StreamAssetChunksRequest {
  assetId: string;
}

export interface AssetChunk {
  uploadId: string;
  data: Uint8Array;
  sequence: number;
}

export interface PublishAssetChunkRequest {
  assetId: string;
  chunk?: AssetChunk | undefined;
}

export interface PublishAssetChunkResponse {
  status: string;
}

/** --- Notification Management --- */
export interface GetNotificationRequest {
  notificationId: string;
}

export interface GetNotificationResponse {
  notification?: Notification | undefined;
}

export interface ListNotificationsRequest {
  userId: string;
  channel: string;
  page: number;
  pageSize: number;
  status: string;
  /** campaign/tenant context */
  campaignId: string;
}

export interface ListNotificationsResponse {
  notifications: Notification[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface AcknowledgeNotificationRequest {
  notificationId: string;
  userId: string;
}

export interface AcknowledgeNotificationResponse {
  status: string;
}

/** --- Preferences --- */
export interface NotificationPreferences {
  emailEnabled: boolean;
  smsEnabled: boolean;
  pushEnabled: boolean;
  notificationTypes: { [key: string]: boolean };
  quietHours: string[];
  timezone: string;
}

export interface NotificationPreferences_NotificationTypesEntry {
  key: string;
  value: boolean;
}

export interface UpdateNotificationPreferencesRequest {
  userId: string;
  preferences?: NotificationPreferences | undefined;
}

export interface UpdateNotificationPreferencesResponse {
  preferences?: NotificationPreferences | undefined;
  updatedAt: string;
}

/** --- Analytics/Events --- */
export interface ListNotificationEventsRequest {
  userId: string;
  notificationId: string;
  page: number;
  pageSize: number;
  /** campaign/tenant context */
  campaignId: string;
}

export interface ListNotificationEventsResponse {
  events: NotificationEvent[];
  total: number;
}

function createBaseNotification(): Notification {
  return {
    id: "",
    masterId: "0",
    masterUuid: "",
    userId: "",
    campaignId: "0",
    channel: "",
    title: "",
    body: "",
    payload: {},
    status: 0,
    createdAt: undefined,
    updatedAt: undefined,
    read: false,
    metadata: undefined,
  };
}

export const Notification: MessageFns<Notification> = {
  encode(message: Notification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.masterId !== "0") {
      writer.uint32(104).int64(message.masterId);
    }
    if (message.masterUuid !== "") {
      writer.uint32(114).string(message.masterUuid);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(120).int64(message.campaignId);
    }
    if (message.channel !== "") {
      writer.uint32(34).string(message.channel);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.body !== "") {
      writer.uint32(50).string(message.body);
    }
    Object.entries(message.payload).forEach(([key, value]) => {
      Notification_PayloadEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(82).fork()).join();
    }
    if (message.read !== false) {
      writer.uint32(88).bool(message.read);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.masterId = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = Notification_PayloadEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.payload[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.read = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notification {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      masterId: isSet(object.masterId) ? globalThis.String(object.masterId) : "0",
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      payload: isObject(object.payload)
        ? Object.entries(object.payload).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      status: isSet(object.status) ? notificationStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      read: isSet(object.read) ? globalThis.Boolean(object.read) : false,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Notification): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.masterId !== "0") {
      obj.masterId = message.masterId;
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.payload) {
      const entries = Object.entries(message.payload);
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    if (message.status !== 0) {
      obj.status = notificationStatusToJSON(message.status);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.read !== false) {
      obj.read = message.read;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Notification>, I>>(base?: I): Notification {
    return Notification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Notification>, I>>(object: I): Notification {
    const message = createBaseNotification();
    message.id = object.id ?? "";
    message.masterId = object.masterId ?? "0";
    message.masterUuid = object.masterUuid ?? "";
    message.userId = object.userId ?? "";
    message.campaignId = object.campaignId ?? "0";
    message.channel = object.channel ?? "";
    message.title = object.title ?? "";
    message.body = object.body ?? "";
    message.payload = Object.entries(object.payload ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.read = object.read ?? false;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseNotification_PayloadEntry(): Notification_PayloadEntry {
  return { key: "", value: "" };
}

export const Notification_PayloadEntry: MessageFns<Notification_PayloadEntry> = {
  encode(message: Notification_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notification_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Notification_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Notification_PayloadEntry>, I>>(base?: I): Notification_PayloadEntry {
    return Notification_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Notification_PayloadEntry>, I>>(object: I): Notification_PayloadEntry {
    const message = createBaseNotification_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSendNotificationRequest(): SendNotificationRequest {
  return { userId: "", channel: "", title: "", body: "", payload: {}, metadata: undefined, campaignId: "0" };
}

export const SendNotificationRequest: MessageFns<SendNotificationRequest> = {
  encode(message: SendNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.channel !== "") {
      writer.uint32(18).string(message.channel);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.body !== "") {
      writer.uint32(34).string(message.body);
    }
    Object.entries(message.payload).forEach(([key, value]) => {
      SendNotificationRequest_PayloadEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(56).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = SendNotificationRequest_PayloadEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.payload[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendNotificationRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      payload: isObject(object.payload)
        ? Object.entries(object.payload).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: SendNotificationRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.payload) {
      const entries = Object.entries(message.payload);
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendNotificationRequest>, I>>(base?: I): SendNotificationRequest {
    return SendNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendNotificationRequest>, I>>(object: I): SendNotificationRequest {
    const message = createBaseSendNotificationRequest();
    message.userId = object.userId ?? "";
    message.channel = object.channel ?? "";
    message.title = object.title ?? "";
    message.body = object.body ?? "";
    message.payload = Object.entries(object.payload ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseSendNotificationRequest_PayloadEntry(): SendNotificationRequest_PayloadEntry {
  return { key: "", value: "" };
}

export const SendNotificationRequest_PayloadEntry: MessageFns<SendNotificationRequest_PayloadEntry> = {
  encode(message: SendNotificationRequest_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendNotificationRequest_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendNotificationRequest_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendNotificationRequest_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SendNotificationRequest_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendNotificationRequest_PayloadEntry>, I>>(
    base?: I,
  ): SendNotificationRequest_PayloadEntry {
    return SendNotificationRequest_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendNotificationRequest_PayloadEntry>, I>>(
    object: I,
  ): SendNotificationRequest_PayloadEntry {
    const message = createBaseSendNotificationRequest_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSendNotificationResponse(): SendNotificationResponse {
  return { notification: undefined, status: "" };
}

export const SendNotificationResponse: MessageFns<SendNotificationResponse> = {
  encode(message: SendNotificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notification !== undefined) {
      Notification.encode(message.notification, writer.uint32(10).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendNotificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notification = Notification.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendNotificationResponse {
    return {
      notification: isSet(object.notification) ? Notification.fromJSON(object.notification) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: SendNotificationResponse): unknown {
    const obj: any = {};
    if (message.notification !== undefined) {
      obj.notification = Notification.toJSON(message.notification);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendNotificationResponse>, I>>(base?: I): SendNotificationResponse {
    return SendNotificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendNotificationResponse>, I>>(object: I): SendNotificationResponse {
    const message = createBaseSendNotificationResponse();
    message.notification = (object.notification !== undefined && object.notification !== null)
      ? Notification.fromPartial(object.notification)
      : undefined;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseSendEmailRequest(): SendEmailRequest {
  return { to: "", subject: "", body: "", metadata: undefined, html: false, campaignId: "0" };
}

export const SendEmailRequest: MessageFns<SendEmailRequest> = {
  encode(message: SendEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.to !== "") {
      writer.uint32(10).string(message.to);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.html !== false) {
      writer.uint32(40).bool(message.html);
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.html = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendEmailRequest {
    return {
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      html: isSet(object.html) ? globalThis.Boolean(object.html) : false,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: SendEmailRequest): unknown {
    const obj: any = {};
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.html !== false) {
      obj.html = message.html;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendEmailRequest>, I>>(base?: I): SendEmailRequest {
    return SendEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendEmailRequest>, I>>(object: I): SendEmailRequest {
    const message = createBaseSendEmailRequest();
    message.to = object.to ?? "";
    message.subject = object.subject ?? "";
    message.body = object.body ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.html = object.html ?? false;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseSendEmailResponse(): SendEmailResponse {
  return { messageId: "", status: "", sentAt: "0" };
}

export const SendEmailResponse: MessageFns<SendEmailResponse> = {
  encode(message: SendEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.sentAt !== "0") {
      writer.uint32(24).int64(message.sentAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sentAt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendEmailResponse {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      sentAt: isSet(object.sentAt) ? globalThis.String(object.sentAt) : "0",
    };
  },

  toJSON(message: SendEmailResponse): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.sentAt !== "0") {
      obj.sentAt = message.sentAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendEmailResponse>, I>>(base?: I): SendEmailResponse {
    return SendEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendEmailResponse>, I>>(object: I): SendEmailResponse {
    const message = createBaseSendEmailResponse();
    message.messageId = object.messageId ?? "";
    message.status = object.status ?? "";
    message.sentAt = object.sentAt ?? "0";
    return message;
  },
};

function createBaseSendSMSRequest(): SendSMSRequest {
  return { to: "", message: "", metadata: undefined, campaignId: "0" };
}

export const SendSMSRequest: MessageFns<SendSMSRequest> = {
  encode(message: SendSMSRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.to !== "") {
      writer.uint32(10).string(message.to);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendSMSRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendSMSRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendSMSRequest {
    return {
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: SendSMSRequest): unknown {
    const obj: any = {};
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendSMSRequest>, I>>(base?: I): SendSMSRequest {
    return SendSMSRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendSMSRequest>, I>>(object: I): SendSMSRequest {
    const message = createBaseSendSMSRequest();
    message.to = object.to ?? "";
    message.message = object.message ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseSendSMSResponse(): SendSMSResponse {
  return { messageId: "", status: "", sentAt: "0" };
}

export const SendSMSResponse: MessageFns<SendSMSResponse> = {
  encode(message: SendSMSResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.sentAt !== "0") {
      writer.uint32(24).int64(message.sentAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendSMSResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendSMSResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sentAt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendSMSResponse {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      sentAt: isSet(object.sentAt) ? globalThis.String(object.sentAt) : "0",
    };
  },

  toJSON(message: SendSMSResponse): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.sentAt !== "0") {
      obj.sentAt = message.sentAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendSMSResponse>, I>>(base?: I): SendSMSResponse {
    return SendSMSResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendSMSResponse>, I>>(object: I): SendSMSResponse {
    const message = createBaseSendSMSResponse();
    message.messageId = object.messageId ?? "";
    message.status = object.status ?? "";
    message.sentAt = object.sentAt ?? "0";
    return message;
  },
};

function createBaseSendPushNotificationRequest(): SendPushNotificationRequest {
  return { userId: "", title: "", message: "", metadata: undefined, deepLink: "", campaignId: "0" };
}

export const SendPushNotificationRequest: MessageFns<SendPushNotificationRequest> = {
  encode(message: SendPushNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.deepLink !== "") {
      writer.uint32(42).string(message.deepLink);
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendPushNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendPushNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deepLink = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendPushNotificationRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      deepLink: isSet(object.deepLink) ? globalThis.String(object.deepLink) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: SendPushNotificationRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.deepLink !== "") {
      obj.deepLink = message.deepLink;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendPushNotificationRequest>, I>>(base?: I): SendPushNotificationRequest {
    return SendPushNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendPushNotificationRequest>, I>>(object: I): SendPushNotificationRequest {
    const message = createBaseSendPushNotificationRequest();
    message.userId = object.userId ?? "";
    message.title = object.title ?? "";
    message.message = object.message ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.deepLink = object.deepLink ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseSendPushNotificationResponse(): SendPushNotificationResponse {
  return { notificationId: "", status: "", sentAt: "0" };
}

export const SendPushNotificationResponse: MessageFns<SendPushNotificationResponse> = {
  encode(message: SendPushNotificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notificationId !== "") {
      writer.uint32(10).string(message.notificationId);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.sentAt !== "0") {
      writer.uint32(24).int64(message.sentAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendPushNotificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendPushNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sentAt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendPushNotificationResponse {
    return {
      notificationId: isSet(object.notificationId) ? globalThis.String(object.notificationId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      sentAt: isSet(object.sentAt) ? globalThis.String(object.sentAt) : "0",
    };
  },

  toJSON(message: SendPushNotificationResponse): unknown {
    const obj: any = {};
    if (message.notificationId !== "") {
      obj.notificationId = message.notificationId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.sentAt !== "0") {
      obj.sentAt = message.sentAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendPushNotificationResponse>, I>>(base?: I): SendPushNotificationResponse {
    return SendPushNotificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendPushNotificationResponse>, I>>(object: I): SendPushNotificationResponse {
    const message = createBaseSendPushNotificationResponse();
    message.notificationId = object.notificationId ?? "";
    message.status = object.status ?? "";
    message.sentAt = object.sentAt ?? "0";
    return message;
  },
};

function createBaseBroadcastEventRequest(): BroadcastEventRequest {
  return { channel: "", subject: "", message: "", payload: undefined, scheduledAt: undefined, campaignId: "0" };
}

export const BroadcastEventRequest: MessageFns<BroadcastEventRequest> = {
  encode(message: BroadcastEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== "") {
      writer.uint32(10).string(message.channel);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.payload !== undefined) {
      Metadata.encode(message.payload, writer.uint32(34).fork()).join();
    }
    if (message.scheduledAt !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduledAt), writer.uint32(42).fork()).join();
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BroadcastEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scheduledAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BroadcastEventRequest {
    return {
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      payload: isSet(object.payload) ? Metadata.fromJSON(object.payload) : undefined,
      scheduledAt: isSet(object.scheduledAt) ? fromJsonTimestamp(object.scheduledAt) : undefined,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: BroadcastEventRequest): unknown {
    const obj: any = {};
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.payload !== undefined) {
      obj.payload = Metadata.toJSON(message.payload);
    }
    if (message.scheduledAt !== undefined) {
      obj.scheduledAt = message.scheduledAt.toISOString();
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BroadcastEventRequest>, I>>(base?: I): BroadcastEventRequest {
    return BroadcastEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BroadcastEventRequest>, I>>(object: I): BroadcastEventRequest {
    const message = createBaseBroadcastEventRequest();
    message.channel = object.channel ?? "";
    message.subject = object.subject ?? "";
    message.message = object.message ?? "";
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? Metadata.fromPartial(object.payload)
      : undefined;
    message.scheduledAt = object.scheduledAt ?? undefined;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseBroadcastEventResponse(): BroadcastEventResponse {
  return { broadcastId: "", status: "", campaignId: "0" };
}

export const BroadcastEventResponse: MessageFns<BroadcastEventResponse> = {
  encode(message: BroadcastEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.broadcastId !== "") {
      writer.uint32(10).string(message.broadcastId);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.campaignId !== "0") {
      writer.uint32(24).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BroadcastEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBroadcastEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.broadcastId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BroadcastEventResponse {
    return {
      broadcastId: isSet(object.broadcastId) ? globalThis.String(object.broadcastId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: BroadcastEventResponse): unknown {
    const obj: any = {};
    if (message.broadcastId !== "") {
      obj.broadcastId = message.broadcastId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BroadcastEventResponse>, I>>(base?: I): BroadcastEventResponse {
    return BroadcastEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BroadcastEventResponse>, I>>(object: I): BroadcastEventResponse {
    const message = createBaseBroadcastEventResponse();
    message.broadcastId = object.broadcastId ?? "";
    message.status = object.status ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseSubscribeToEventsRequest(): SubscribeToEventsRequest {
  return { userId: "", channels: [], filters: undefined };
}

export const SubscribeToEventsRequest: MessageFns<SubscribeToEventsRequest> = {
  encode(message: SubscribeToEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.channels) {
      writer.uint32(18).string(v!);
    }
    if (message.filters !== undefined) {
      Metadata.encode(message.filters, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeToEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeToEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channels.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filters = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeToEventsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      channels: globalThis.Array.isArray(object?.channels) ? object.channels.map((e: any) => globalThis.String(e)) : [],
      filters: isSet(object.filters) ? Metadata.fromJSON(object.filters) : undefined,
    };
  },

  toJSON(message: SubscribeToEventsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.channels?.length) {
      obj.channels = message.channels;
    }
    if (message.filters !== undefined) {
      obj.filters = Metadata.toJSON(message.filters);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeToEventsRequest>, I>>(base?: I): SubscribeToEventsRequest {
    return SubscribeToEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeToEventsRequest>, I>>(object: I): SubscribeToEventsRequest {
    const message = createBaseSubscribeToEventsRequest();
    message.userId = object.userId ?? "";
    message.channels = object.channels?.map((e) => e) || [];
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? Metadata.fromPartial(object.filters)
      : undefined;
    return message;
  },
};

function createBaseNotificationEvent(): NotificationEvent {
  return { eventId: "", notificationId: "", userId: "", eventType: "", payload: undefined, createdAt: undefined };
}

export const NotificationEvent: MessageFns<NotificationEvent> = {
  encode(message: NotificationEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.notificationId !== "") {
      writer.uint32(18).string(message.notificationId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.eventType !== "") {
      writer.uint32(34).string(message.eventType);
    }
    if (message.payload !== undefined) {
      Struct.encode(Struct.wrap(message.payload), writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      notificationId: isSet(object.notificationId) ? globalThis.String(object.notificationId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      payload: isObject(object.payload) ? object.payload : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: NotificationEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.notificationId !== "") {
      obj.notificationId = message.notificationId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationEvent>, I>>(base?: I): NotificationEvent {
    return NotificationEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationEvent>, I>>(object: I): NotificationEvent {
    const message = createBaseNotificationEvent();
    message.eventId = object.eventId ?? "";
    message.notificationId = object.notificationId ?? "";
    message.userId = object.userId ?? "";
    message.eventType = object.eventType ?? "";
    message.payload = object.payload ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseStreamAssetChunksRequest(): StreamAssetChunksRequest {
  return { assetId: "" };
}

export const StreamAssetChunksRequest: MessageFns<StreamAssetChunksRequest> = {
  encode(message: StreamAssetChunksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamAssetChunksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamAssetChunksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamAssetChunksRequest {
    return { assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "" };
  },

  toJSON(message: StreamAssetChunksRequest): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StreamAssetChunksRequest>, I>>(base?: I): StreamAssetChunksRequest {
    return StreamAssetChunksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StreamAssetChunksRequest>, I>>(object: I): StreamAssetChunksRequest {
    const message = createBaseStreamAssetChunksRequest();
    message.assetId = object.assetId ?? "";
    return message;
  },
};

function createBaseAssetChunk(): AssetChunk {
  return { uploadId: "", data: new Uint8Array(0), sequence: 0 };
}

export const AssetChunk: MessageFns<AssetChunk> = {
  encode(message: AssetChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uploadId !== "") {
      writer.uint32(10).string(message.uploadId);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.sequence !== 0) {
      writer.uint32(24).uint32(message.sequence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uploadId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sequence = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetChunk {
    return {
      uploadId: isSet(object.uploadId) ? globalThis.String(object.uploadId) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
    };
  },

  toJSON(message: AssetChunk): unknown {
    const obj: any = {};
    if (message.uploadId !== "") {
      obj.uploadId = message.uploadId;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetChunk>, I>>(base?: I): AssetChunk {
    return AssetChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetChunk>, I>>(object: I): AssetChunk {
    const message = createBaseAssetChunk();
    message.uploadId = object.uploadId ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.sequence = object.sequence ?? 0;
    return message;
  },
};

function createBasePublishAssetChunkRequest(): PublishAssetChunkRequest {
  return { assetId: "", chunk: undefined };
}

export const PublishAssetChunkRequest: MessageFns<PublishAssetChunkRequest> = {
  encode(message: PublishAssetChunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetId !== "") {
      writer.uint32(10).string(message.assetId);
    }
    if (message.chunk !== undefined) {
      AssetChunk.encode(message.chunk, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishAssetChunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishAssetChunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chunk = AssetChunk.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishAssetChunkRequest {
    return {
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      chunk: isSet(object.chunk) ? AssetChunk.fromJSON(object.chunk) : undefined,
    };
  },

  toJSON(message: PublishAssetChunkRequest): unknown {
    const obj: any = {};
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.chunk !== undefined) {
      obj.chunk = AssetChunk.toJSON(message.chunk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishAssetChunkRequest>, I>>(base?: I): PublishAssetChunkRequest {
    return PublishAssetChunkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishAssetChunkRequest>, I>>(object: I): PublishAssetChunkRequest {
    const message = createBasePublishAssetChunkRequest();
    message.assetId = object.assetId ?? "";
    message.chunk = (object.chunk !== undefined && object.chunk !== null)
      ? AssetChunk.fromPartial(object.chunk)
      : undefined;
    return message;
  },
};

function createBasePublishAssetChunkResponse(): PublishAssetChunkResponse {
  return { status: "" };
}

export const PublishAssetChunkResponse: MessageFns<PublishAssetChunkResponse> = {
  encode(message: PublishAssetChunkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishAssetChunkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishAssetChunkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishAssetChunkResponse {
    return { status: isSet(object.status) ? globalThis.String(object.status) : "" };
  },

  toJSON(message: PublishAssetChunkResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PublishAssetChunkResponse>, I>>(base?: I): PublishAssetChunkResponse {
    return PublishAssetChunkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PublishAssetChunkResponse>, I>>(object: I): PublishAssetChunkResponse {
    const message = createBasePublishAssetChunkResponse();
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseGetNotificationRequest(): GetNotificationRequest {
  return { notificationId: "" };
}

export const GetNotificationRequest: MessageFns<GetNotificationRequest> = {
  encode(message: GetNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notificationId !== "") {
      writer.uint32(10).string(message.notificationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationRequest {
    return { notificationId: isSet(object.notificationId) ? globalThis.String(object.notificationId) : "" };
  },

  toJSON(message: GetNotificationRequest): unknown {
    const obj: any = {};
    if (message.notificationId !== "") {
      obj.notificationId = message.notificationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNotificationRequest>, I>>(base?: I): GetNotificationRequest {
    return GetNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNotificationRequest>, I>>(object: I): GetNotificationRequest {
    const message = createBaseGetNotificationRequest();
    message.notificationId = object.notificationId ?? "";
    return message;
  },
};

function createBaseGetNotificationResponse(): GetNotificationResponse {
  return { notification: undefined };
}

export const GetNotificationResponse: MessageFns<GetNotificationResponse> = {
  encode(message: GetNotificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notification !== undefined) {
      Notification.encode(message.notification, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notification = Notification.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationResponse {
    return { notification: isSet(object.notification) ? Notification.fromJSON(object.notification) : undefined };
  },

  toJSON(message: GetNotificationResponse): unknown {
    const obj: any = {};
    if (message.notification !== undefined) {
      obj.notification = Notification.toJSON(message.notification);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNotificationResponse>, I>>(base?: I): GetNotificationResponse {
    return GetNotificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNotificationResponse>, I>>(object: I): GetNotificationResponse {
    const message = createBaseGetNotificationResponse();
    message.notification = (object.notification !== undefined && object.notification !== null)
      ? Notification.fromPartial(object.notification)
      : undefined;
    return message;
  },
};

function createBaseListNotificationsRequest(): ListNotificationsRequest {
  return { userId: "", channel: "", page: 0, pageSize: 0, status: "", campaignId: "0" };
}

export const ListNotificationsRequest: MessageFns<ListNotificationsRequest> = {
  encode(message: ListNotificationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.channel !== "") {
      writer.uint32(18).string(message.channel);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.campaignId !== "0") {
      writer.uint32(48).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListNotificationsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNotificationsRequest>, I>>(base?: I): ListNotificationsRequest {
    return ListNotificationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNotificationsRequest>, I>>(object: I): ListNotificationsRequest {
    const message = createBaseListNotificationsRequest();
    message.userId = object.userId ?? "";
    message.channel = object.channel ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.status = object.status ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListNotificationsResponse(): ListNotificationsResponse {
  return { notifications: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListNotificationsResponse: MessageFns<ListNotificationsResponse> = {
  encode(message: ListNotificationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notifications) {
      Notification.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notifications.push(Notification.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationsResponse {
    return {
      notifications: globalThis.Array.isArray(object?.notifications)
        ? object.notifications.map((e: any) => Notification.fromJSON(e))
        : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListNotificationsResponse): unknown {
    const obj: any = {};
    if (message.notifications?.length) {
      obj.notifications = message.notifications.map((e) => Notification.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNotificationsResponse>, I>>(base?: I): ListNotificationsResponse {
    return ListNotificationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNotificationsResponse>, I>>(object: I): ListNotificationsResponse {
    const message = createBaseListNotificationsResponse();
    message.notifications = object.notifications?.map((e) => Notification.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseAcknowledgeNotificationRequest(): AcknowledgeNotificationRequest {
  return { notificationId: "", userId: "" };
}

export const AcknowledgeNotificationRequest: MessageFns<AcknowledgeNotificationRequest> = {
  encode(message: AcknowledgeNotificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notificationId !== "") {
      writer.uint32(10).string(message.notificationId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcknowledgeNotificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeNotificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeNotificationRequest {
    return {
      notificationId: isSet(object.notificationId) ? globalThis.String(object.notificationId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: AcknowledgeNotificationRequest): unknown {
    const obj: any = {};
    if (message.notificationId !== "") {
      obj.notificationId = message.notificationId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AcknowledgeNotificationRequest>, I>>(base?: I): AcknowledgeNotificationRequest {
    return AcknowledgeNotificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AcknowledgeNotificationRequest>, I>>(
    object: I,
  ): AcknowledgeNotificationRequest {
    const message = createBaseAcknowledgeNotificationRequest();
    message.notificationId = object.notificationId ?? "";
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseAcknowledgeNotificationResponse(): AcknowledgeNotificationResponse {
  return { status: "" };
}

export const AcknowledgeNotificationResponse: MessageFns<AcknowledgeNotificationResponse> = {
  encode(message: AcknowledgeNotificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcknowledgeNotificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeNotificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeNotificationResponse {
    return { status: isSet(object.status) ? globalThis.String(object.status) : "" };
  },

  toJSON(message: AcknowledgeNotificationResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AcknowledgeNotificationResponse>, I>>(base?: I): AcknowledgeNotificationResponse {
    return AcknowledgeNotificationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AcknowledgeNotificationResponse>, I>>(
    object: I,
  ): AcknowledgeNotificationResponse {
    const message = createBaseAcknowledgeNotificationResponse();
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseNotificationPreferences(): NotificationPreferences {
  return {
    emailEnabled: false,
    smsEnabled: false,
    pushEnabled: false,
    notificationTypes: {},
    quietHours: [],
    timezone: "",
  };
}

export const NotificationPreferences: MessageFns<NotificationPreferences> = {
  encode(message: NotificationPreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailEnabled !== false) {
      writer.uint32(8).bool(message.emailEnabled);
    }
    if (message.smsEnabled !== false) {
      writer.uint32(16).bool(message.smsEnabled);
    }
    if (message.pushEnabled !== false) {
      writer.uint32(24).bool(message.pushEnabled);
    }
    Object.entries(message.notificationTypes).forEach(([key, value]) => {
      NotificationPreferences_NotificationTypesEntry.encode({ key: key as any, value }, writer.uint32(34).fork())
        .join();
    });
    for (const v of message.quietHours) {
      writer.uint32(42).string(v!);
    }
    if (message.timezone !== "") {
      writer.uint32(50).string(message.timezone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationPreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationPreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.emailEnabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.smsEnabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pushEnabled = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = NotificationPreferences_NotificationTypesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.notificationTypes[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.quietHours.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationPreferences {
    return {
      emailEnabled: isSet(object.emailEnabled) ? globalThis.Boolean(object.emailEnabled) : false,
      smsEnabled: isSet(object.smsEnabled) ? globalThis.Boolean(object.smsEnabled) : false,
      pushEnabled: isSet(object.pushEnabled) ? globalThis.Boolean(object.pushEnabled) : false,
      notificationTypes: isObject(object.notificationTypes)
        ? Object.entries(object.notificationTypes).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
          acc[key] = Boolean(value);
          return acc;
        }, {})
        : {},
      quietHours: globalThis.Array.isArray(object?.quietHours)
        ? object.quietHours.map((e: any) => globalThis.String(e))
        : [],
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
    };
  },

  toJSON(message: NotificationPreferences): unknown {
    const obj: any = {};
    if (message.emailEnabled !== false) {
      obj.emailEnabled = message.emailEnabled;
    }
    if (message.smsEnabled !== false) {
      obj.smsEnabled = message.smsEnabled;
    }
    if (message.pushEnabled !== false) {
      obj.pushEnabled = message.pushEnabled;
    }
    if (message.notificationTypes) {
      const entries = Object.entries(message.notificationTypes);
      if (entries.length > 0) {
        obj.notificationTypes = {};
        entries.forEach(([k, v]) => {
          obj.notificationTypes[k] = v;
        });
      }
    }
    if (message.quietHours?.length) {
      obj.quietHours = message.quietHours;
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationPreferences>, I>>(base?: I): NotificationPreferences {
    return NotificationPreferences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationPreferences>, I>>(object: I): NotificationPreferences {
    const message = createBaseNotificationPreferences();
    message.emailEnabled = object.emailEnabled ?? false;
    message.smsEnabled = object.smsEnabled ?? false;
    message.pushEnabled = object.pushEnabled ?? false;
    message.notificationTypes = Object.entries(object.notificationTypes ?? {}).reduce<{ [key: string]: boolean }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Boolean(value);
        }
        return acc;
      },
      {},
    );
    message.quietHours = object.quietHours?.map((e) => e) || [];
    message.timezone = object.timezone ?? "";
    return message;
  },
};

function createBaseNotificationPreferences_NotificationTypesEntry(): NotificationPreferences_NotificationTypesEntry {
  return { key: "", value: false };
}

export const NotificationPreferences_NotificationTypesEntry: MessageFns<
  NotificationPreferences_NotificationTypesEntry
> = {
  encode(
    message: NotificationPreferences_NotificationTypesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationPreferences_NotificationTypesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationPreferences_NotificationTypesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationPreferences_NotificationTypesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: NotificationPreferences_NotificationTypesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationPreferences_NotificationTypesEntry>, I>>(
    base?: I,
  ): NotificationPreferences_NotificationTypesEntry {
    return NotificationPreferences_NotificationTypesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationPreferences_NotificationTypesEntry>, I>>(
    object: I,
  ): NotificationPreferences_NotificationTypesEntry {
    const message = createBaseNotificationPreferences_NotificationTypesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseUpdateNotificationPreferencesRequest(): UpdateNotificationPreferencesRequest {
  return { userId: "", preferences: undefined };
}

export const UpdateNotificationPreferencesRequest: MessageFns<UpdateNotificationPreferencesRequest> = {
  encode(message: UpdateNotificationPreferencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.preferences !== undefined) {
      NotificationPreferences.encode(message.preferences, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNotificationPreferencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNotificationPreferencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.preferences = NotificationPreferences.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNotificationPreferencesRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      preferences: isSet(object.preferences) ? NotificationPreferences.fromJSON(object.preferences) : undefined,
    };
  },

  toJSON(message: UpdateNotificationPreferencesRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.preferences !== undefined) {
      obj.preferences = NotificationPreferences.toJSON(message.preferences);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateNotificationPreferencesRequest>, I>>(
    base?: I,
  ): UpdateNotificationPreferencesRequest {
    return UpdateNotificationPreferencesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateNotificationPreferencesRequest>, I>>(
    object: I,
  ): UpdateNotificationPreferencesRequest {
    const message = createBaseUpdateNotificationPreferencesRequest();
    message.userId = object.userId ?? "";
    message.preferences = (object.preferences !== undefined && object.preferences !== null)
      ? NotificationPreferences.fromPartial(object.preferences)
      : undefined;
    return message;
  },
};

function createBaseUpdateNotificationPreferencesResponse(): UpdateNotificationPreferencesResponse {
  return { preferences: undefined, updatedAt: "0" };
}

export const UpdateNotificationPreferencesResponse: MessageFns<UpdateNotificationPreferencesResponse> = {
  encode(message: UpdateNotificationPreferencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preferences !== undefined) {
      NotificationPreferences.encode(message.preferences, writer.uint32(10).fork()).join();
    }
    if (message.updatedAt !== "0") {
      writer.uint32(16).int64(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNotificationPreferencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNotificationPreferencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.preferences = NotificationPreferences.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.updatedAt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNotificationPreferencesResponse {
    return {
      preferences: isSet(object.preferences) ? NotificationPreferences.fromJSON(object.preferences) : undefined,
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "0",
    };
  },

  toJSON(message: UpdateNotificationPreferencesResponse): unknown {
    const obj: any = {};
    if (message.preferences !== undefined) {
      obj.preferences = NotificationPreferences.toJSON(message.preferences);
    }
    if (message.updatedAt !== "0") {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateNotificationPreferencesResponse>, I>>(
    base?: I,
  ): UpdateNotificationPreferencesResponse {
    return UpdateNotificationPreferencesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateNotificationPreferencesResponse>, I>>(
    object: I,
  ): UpdateNotificationPreferencesResponse {
    const message = createBaseUpdateNotificationPreferencesResponse();
    message.preferences = (object.preferences !== undefined && object.preferences !== null)
      ? NotificationPreferences.fromPartial(object.preferences)
      : undefined;
    message.updatedAt = object.updatedAt ?? "0";
    return message;
  },
};

function createBaseListNotificationEventsRequest(): ListNotificationEventsRequest {
  return { userId: "", notificationId: "", page: 0, pageSize: 0, campaignId: "0" };
}

export const ListNotificationEventsRequest: MessageFns<ListNotificationEventsRequest> = {
  encode(message: ListNotificationEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.notificationId !== "") {
      writer.uint32(18).string(message.notificationId);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.notificationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationEventsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      notificationId: isSet(object.notificationId) ? globalThis.String(object.notificationId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListNotificationEventsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.notificationId !== "") {
      obj.notificationId = message.notificationId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNotificationEventsRequest>, I>>(base?: I): ListNotificationEventsRequest {
    return ListNotificationEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNotificationEventsRequest>, I>>(
    object: I,
  ): ListNotificationEventsRequest {
    const message = createBaseListNotificationEventsRequest();
    message.userId = object.userId ?? "";
    message.notificationId = object.notificationId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListNotificationEventsResponse(): ListNotificationEventsResponse {
  return { events: [], total: 0 };
}

export const ListNotificationEventsResponse: MessageFns<ListNotificationEventsResponse> = {
  encode(message: ListNotificationEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      NotificationEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(NotificationEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => NotificationEvent.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListNotificationEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => NotificationEvent.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNotificationEventsResponse>, I>>(base?: I): ListNotificationEventsResponse {
    return ListNotificationEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNotificationEventsResponse>, I>>(
    object: I,
  ): ListNotificationEventsResponse {
    const message = createBaseListNotificationEventsResponse();
    message.events = object.events?.map((e) => NotificationEvent.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

export interface NotificationService {
  /** Generic notification send (channel-agnostic) */
  SendNotification(request: SendNotificationRequest): Promise<SendNotificationResponse>;
  /** Channel-specific sends (for compatibility) */
  SendEmail(request: SendEmailRequest): Promise<SendEmailResponse>;
  SendSMS(request: SendSMSRequest): Promise<SendSMSResponse>;
  SendPushNotification(request: SendPushNotificationRequest): Promise<SendPushNotificationResponse>;
  /** Broadcasts */
  BroadcastEvent(request: BroadcastEventRequest): Promise<BroadcastEventResponse>;
  /** Real-time pub/sub */
  SubscribeToEvents(request: SubscribeToEventsRequest): Observable<NotificationEvent>;
  /** Asset streaming (for live events/media) */
  StreamAssetChunks(request: StreamAssetChunksRequest): Observable<AssetChunk>;
  PublishAssetChunk(request: PublishAssetChunkRequest): Promise<PublishAssetChunkResponse>;
  /** Notification management */
  GetNotification(request: GetNotificationRequest): Promise<GetNotificationResponse>;
  ListNotifications(request: ListNotificationsRequest): Promise<ListNotificationsResponse>;
  AcknowledgeNotification(request: AcknowledgeNotificationRequest): Promise<AcknowledgeNotificationResponse>;
  /** Preferences */
  UpdateNotificationPreferences(
    request: UpdateNotificationPreferencesRequest,
  ): Promise<UpdateNotificationPreferencesResponse>;
  /** Analytics/events */
  ListNotificationEvents(request: ListNotificationEventsRequest): Promise<ListNotificationEventsResponse>;
}

export const NotificationServiceServiceName = "notification.v1.NotificationService";
export class NotificationServiceClientImpl implements NotificationService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || NotificationServiceServiceName;
    this.rpc = rpc;
    this.SendNotification = this.SendNotification.bind(this);
    this.SendEmail = this.SendEmail.bind(this);
    this.SendSMS = this.SendSMS.bind(this);
    this.SendPushNotification = this.SendPushNotification.bind(this);
    this.BroadcastEvent = this.BroadcastEvent.bind(this);
    this.SubscribeToEvents = this.SubscribeToEvents.bind(this);
    this.StreamAssetChunks = this.StreamAssetChunks.bind(this);
    this.PublishAssetChunk = this.PublishAssetChunk.bind(this);
    this.GetNotification = this.GetNotification.bind(this);
    this.ListNotifications = this.ListNotifications.bind(this);
    this.AcknowledgeNotification = this.AcknowledgeNotification.bind(this);
    this.UpdateNotificationPreferences = this.UpdateNotificationPreferences.bind(this);
    this.ListNotificationEvents = this.ListNotificationEvents.bind(this);
  }
  SendNotification(request: SendNotificationRequest): Promise<SendNotificationResponse> {
    const data = SendNotificationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendNotification", data);
    return promise.then((data) => SendNotificationResponse.decode(new BinaryReader(data)));
  }

  SendEmail(request: SendEmailRequest): Promise<SendEmailResponse> {
    const data = SendEmailRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendEmail", data);
    return promise.then((data) => SendEmailResponse.decode(new BinaryReader(data)));
  }

  SendSMS(request: SendSMSRequest): Promise<SendSMSResponse> {
    const data = SendSMSRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendSMS", data);
    return promise.then((data) => SendSMSResponse.decode(new BinaryReader(data)));
  }

  SendPushNotification(request: SendPushNotificationRequest): Promise<SendPushNotificationResponse> {
    const data = SendPushNotificationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendPushNotification", data);
    return promise.then((data) => SendPushNotificationResponse.decode(new BinaryReader(data)));
  }

  BroadcastEvent(request: BroadcastEventRequest): Promise<BroadcastEventResponse> {
    const data = BroadcastEventRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BroadcastEvent", data);
    return promise.then((data) => BroadcastEventResponse.decode(new BinaryReader(data)));
  }

  SubscribeToEvents(request: SubscribeToEventsRequest): Observable<NotificationEvent> {
    const data = SubscribeToEventsRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "SubscribeToEvents", data);
    return result.pipe(map((data) => NotificationEvent.decode(new BinaryReader(data))));
  }

  StreamAssetChunks(request: StreamAssetChunksRequest): Observable<AssetChunk> {
    const data = StreamAssetChunksRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "StreamAssetChunks", data);
    return result.pipe(map((data) => AssetChunk.decode(new BinaryReader(data))));
  }

  PublishAssetChunk(request: PublishAssetChunkRequest): Promise<PublishAssetChunkResponse> {
    const data = PublishAssetChunkRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PublishAssetChunk", data);
    return promise.then((data) => PublishAssetChunkResponse.decode(new BinaryReader(data)));
  }

  GetNotification(request: GetNotificationRequest): Promise<GetNotificationResponse> {
    const data = GetNotificationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNotification", data);
    return promise.then((data) => GetNotificationResponse.decode(new BinaryReader(data)));
  }

  ListNotifications(request: ListNotificationsRequest): Promise<ListNotificationsResponse> {
    const data = ListNotificationsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListNotifications", data);
    return promise.then((data) => ListNotificationsResponse.decode(new BinaryReader(data)));
  }

  AcknowledgeNotification(request: AcknowledgeNotificationRequest): Promise<AcknowledgeNotificationResponse> {
    const data = AcknowledgeNotificationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AcknowledgeNotification", data);
    return promise.then((data) => AcknowledgeNotificationResponse.decode(new BinaryReader(data)));
  }

  UpdateNotificationPreferences(
    request: UpdateNotificationPreferencesRequest,
  ): Promise<UpdateNotificationPreferencesResponse> {
    const data = UpdateNotificationPreferencesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateNotificationPreferences", data);
    return promise.then((data) => UpdateNotificationPreferencesResponse.decode(new BinaryReader(data)));
  }

  ListNotificationEvents(request: ListNotificationEventsRequest): Promise<ListNotificationEventsResponse> {
    const data = ListNotificationEventsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListNotificationEvents", data);
    return promise.then((data) => ListNotificationEventsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
