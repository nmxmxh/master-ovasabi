// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: content/v1/content.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Metadata } from "../../common/v1/metadata";

export const protobufPackage = "content.v1";

export interface Content {
  id: string;
  /** Internal integer ID reference to master table */
  masterId: string;
  /** Global UUID reference to master table */
  masterUuid: string;
  /** NEW: campaign/tenant context */
  campaignId: string;
  authorId: string;
  /** "article", "micro", "video", "story", etc. */
  type: string;
  title: string;
  body: string;
  mediaUrls: string[];
  metadata?: Metadata | undefined;
  tags: string[];
  /** for comments/replies */
  parentId: string;
  /** "public", "private", etc. */
  visibility: string;
  createdAt: string;
  updatedAt: string;
  commentCount: number;
  reactionCounts: { [key: string]: number };
}

export interface Content_ReactionCountsEntry {
  key: string;
  value: number;
}

export interface Comment {
  id: string;
  contentId: string;
  /** Internal integer ID reference to master table */
  masterId: string;
  /** Global UUID reference to master table */
  masterUuid: string;
  authorId: string;
  body: string;
  createdAt: string;
  updatedAt: string;
  metadata?: Metadata | undefined;
}

export interface ContentEvent {
  id: string;
  contentId: string;
  /** Internal integer ID reference to master table */
  masterId: string;
  /** Global UUID reference to master table */
  masterUuid: string;
  /** NEW: campaign/tenant context */
  campaignId: string;
  eventType: string;
  userId: string;
  occurredAt: string;
  payload: { [key: string]: string };
}

export interface ContentEvent_PayloadEntry {
  key: string;
  value: string;
}

export interface CreateContentRequest {
  /** NEW: campaign/tenant context */
  campaignId: string;
  content?: Content | undefined;
}

export interface GetContentRequest {
  id: string;
}

export interface UpdateContentRequest {
  content?: Content | undefined;
}

export interface DeleteContentRequest {
  id: string;
}

export interface ListContentRequest {
  /** NEW: campaign/tenant context */
  campaignId: string;
  authorId: string;
  type: string;
  page: number;
  pageSize: number;
  tags: string[];
  metadata?: Metadata | undefined;
  searchQuery: string;
  parentId: string;
  visibility: string;
}

export interface SearchContentRequest {
  /** NEW: campaign/tenant context */
  campaignId: string;
  query: string;
  tags: string[];
  metadata?: Metadata | undefined;
  page: number;
  pageSize: number;
}

export interface ListContentResponse {
  contents: Content[];
  total: number;
}

export interface AddCommentRequest {
  contentId: string;
  authorId: string;
  body: string;
  metadata?: Metadata | undefined;
}

export interface CommentResponse {
  comment?: Comment | undefined;
}

export interface ListCommentsRequest {
  contentId: string;
  page: number;
  pageSize: number;
}

export interface ListCommentsResponse {
  comments: Comment[];
  total: number;
}

export interface DeleteCommentRequest {
  commentId: string;
}

export interface DeleteCommentResponse {
  success: boolean;
}

export interface AddReactionRequest {
  contentId: string;
  userId: string;
  reaction: string;
}

export interface ReactionResponse {
  contentId: string;
  reaction: string;
  count: number;
}

export interface ListReactionsRequest {
  contentId: string;
}

export interface ListReactionsResponse {
  reactions: ReactionResponse[];
}

export interface LogContentEventRequest {
  event?: ContentEvent | undefined;
}

export interface LogContentEventResponse {
  success: boolean;
}

/** Moderation hooks (stub) */
export interface ModerateContentRequest {
  contentId: string;
  action: string;
  moderatorId: string;
  reason: string;
}

export interface ModerateContentResponse {
  success: boolean;
  status: string;
}

export interface ContentResponse {
  content?: Content | undefined;
}

export interface DeleteContentResponse {
  success: boolean;
}

function createBaseContent(): Content {
  return {
    id: "",
    masterId: "0",
    masterUuid: "",
    campaignId: "0",
    authorId: "",
    type: "",
    title: "",
    body: "",
    mediaUrls: [],
    metadata: undefined,
    tags: [],
    parentId: "",
    visibility: "",
    createdAt: "0",
    updatedAt: "0",
    commentCount: 0,
    reactionCounts: {},
  };
}

export const Content: MessageFns<Content> = {
  encode(message: Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.masterId !== "0") {
      writer.uint32(16).int64(message.masterId);
    }
    if (message.masterUuid !== "") {
      writer.uint32(26).string(message.masterUuid);
    }
    if (message.campaignId !== "0") {
      writer.uint32(32).int64(message.campaignId);
    }
    if (message.authorId !== "") {
      writer.uint32(42).string(message.authorId);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.title !== "") {
      writer.uint32(58).string(message.title);
    }
    if (message.body !== "") {
      writer.uint32(66).string(message.body);
    }
    for (const v of message.mediaUrls) {
      writer.uint32(74).string(v!);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(82).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(90).string(v!);
    }
    if (message.parentId !== "") {
      writer.uint32(98).string(message.parentId);
    }
    if (message.visibility !== "") {
      writer.uint32(106).string(message.visibility);
    }
    if (message.createdAt !== "0") {
      writer.uint32(112).int64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(120).int64(message.updatedAt);
    }
    if (message.commentCount !== 0) {
      writer.uint32(128).int32(message.commentCount);
    }
    Object.entries(message.reactionCounts).forEach(([key, value]) => {
      Content_ReactionCountsEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.masterId = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authorId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.mediaUrls.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.parentId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.visibility = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.createdAt = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.updatedAt = reader.int64().toString();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.commentCount = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          const entry17 = Content_ReactionCountsEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.reactionCounts[entry17.key] = entry17.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Content {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      masterId: isSet(object.masterId) ? globalThis.String(object.masterId) : "0",
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
      authorId: isSet(object.authorId) ? globalThis.String(object.authorId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      mediaUrls: globalThis.Array.isArray(object?.mediaUrls)
        ? object.mediaUrls.map((e: any) => globalThis.String(e))
        : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
      visibility: isSet(object.visibility) ? globalThis.String(object.visibility) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "0",
      commentCount: isSet(object.commentCount) ? globalThis.Number(object.commentCount) : 0,
      reactionCounts: isObject(object.reactionCounts)
        ? Object.entries(object.reactionCounts).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Content): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.masterId !== "0") {
      obj.masterId = message.masterId;
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    if (message.authorId !== "") {
      obj.authorId = message.authorId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.mediaUrls?.length) {
      obj.mediaUrls = message.mediaUrls;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    if (message.visibility !== "") {
      obj.visibility = message.visibility;
    }
    if (message.createdAt !== "0") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "0") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.commentCount !== 0) {
      obj.commentCount = Math.round(message.commentCount);
    }
    if (message.reactionCounts) {
      const entries = Object.entries(message.reactionCounts);
      if (entries.length > 0) {
        obj.reactionCounts = {};
        entries.forEach(([k, v]) => {
          obj.reactionCounts[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Content>, I>>(base?: I): Content {
    return Content.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Content>, I>>(object: I): Content {
    const message = createBaseContent();
    message.id = object.id ?? "";
    message.masterId = object.masterId ?? "0";
    message.masterUuid = object.masterUuid ?? "";
    message.campaignId = object.campaignId ?? "0";
    message.authorId = object.authorId ?? "";
    message.type = object.type ?? "";
    message.title = object.title ?? "";
    message.body = object.body ?? "";
    message.mediaUrls = object.mediaUrls?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.parentId = object.parentId ?? "";
    message.visibility = object.visibility ?? "";
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    message.commentCount = object.commentCount ?? 0;
    message.reactionCounts = Object.entries(object.reactionCounts ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseContent_ReactionCountsEntry(): Content_ReactionCountsEntry {
  return { key: "", value: 0 };
}

export const Content_ReactionCountsEntry: MessageFns<Content_ReactionCountsEntry> = {
  encode(message: Content_ReactionCountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Content_ReactionCountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContent_ReactionCountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Content_ReactionCountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Content_ReactionCountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Content_ReactionCountsEntry>, I>>(base?: I): Content_ReactionCountsEntry {
    return Content_ReactionCountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Content_ReactionCountsEntry>, I>>(object: I): Content_ReactionCountsEntry {
    const message = createBaseContent_ReactionCountsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseComment(): Comment {
  return {
    id: "",
    contentId: "",
    masterId: "0",
    masterUuid: "",
    authorId: "",
    body: "",
    createdAt: "0",
    updatedAt: "0",
    metadata: undefined,
  };
}

export const Comment: MessageFns<Comment> = {
  encode(message: Comment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contentId !== "") {
      writer.uint32(18).string(message.contentId);
    }
    if (message.masterId !== "0") {
      writer.uint32(24).int64(message.masterId);
    }
    if (message.masterUuid !== "") {
      writer.uint32(34).string(message.masterUuid);
    }
    if (message.authorId !== "") {
      writer.uint32(42).string(message.authorId);
    }
    if (message.body !== "") {
      writer.uint32(50).string(message.body);
    }
    if (message.createdAt !== "0") {
      writer.uint32(56).int64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(64).int64(message.updatedAt);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Comment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.masterId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authorId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.createdAt = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.updatedAt = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Comment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      masterId: isSet(object.masterId) ? globalThis.String(object.masterId) : "0",
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      authorId: isSet(object.authorId) ? globalThis.String(object.authorId) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "0",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Comment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.masterId !== "0") {
      obj.masterId = message.masterId;
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.authorId !== "") {
      obj.authorId = message.authorId;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.createdAt !== "0") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "0") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Comment>, I>>(base?: I): Comment {
    return Comment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Comment>, I>>(object: I): Comment {
    const message = createBaseComment();
    message.id = object.id ?? "";
    message.contentId = object.contentId ?? "";
    message.masterId = object.masterId ?? "0";
    message.masterUuid = object.masterUuid ?? "";
    message.authorId = object.authorId ?? "";
    message.body = object.body ?? "";
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseContentEvent(): ContentEvent {
  return {
    id: "",
    contentId: "",
    masterId: "0",
    masterUuid: "",
    campaignId: "0",
    eventType: "",
    userId: "",
    occurredAt: "0",
    payload: {},
  };
}

export const ContentEvent: MessageFns<ContentEvent> = {
  encode(message: ContentEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.contentId !== "") {
      writer.uint32(18).string(message.contentId);
    }
    if (message.masterId !== "0") {
      writer.uint32(24).int64(message.masterId);
    }
    if (message.masterUuid !== "") {
      writer.uint32(34).string(message.masterUuid);
    }
    if (message.campaignId !== "0") {
      writer.uint32(40).int64(message.campaignId);
    }
    if (message.eventType !== "") {
      writer.uint32(50).string(message.eventType);
    }
    if (message.userId !== "") {
      writer.uint32(58).string(message.userId);
    }
    if (message.occurredAt !== "0") {
      writer.uint32(64).int64(message.occurredAt);
    }
    Object.entries(message.payload).forEach(([key, value]) => {
      ContentEvent_PayloadEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.masterId = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.eventType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.occurredAt = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = ContentEvent_PayloadEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.payload[entry9.key] = entry9.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      masterId: isSet(object.masterId) ? globalThis.String(object.masterId) : "0",
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      occurredAt: isSet(object.occurredAt) ? globalThis.String(object.occurredAt) : "0",
      payload: isObject(object.payload)
        ? Object.entries(object.payload).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ContentEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.masterId !== "0") {
      obj.masterId = message.masterId;
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.occurredAt !== "0") {
      obj.occurredAt = message.occurredAt;
    }
    if (message.payload) {
      const entries = Object.entries(message.payload);
      if (entries.length > 0) {
        obj.payload = {};
        entries.forEach(([k, v]) => {
          obj.payload[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentEvent>, I>>(base?: I): ContentEvent {
    return ContentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentEvent>, I>>(object: I): ContentEvent {
    const message = createBaseContentEvent();
    message.id = object.id ?? "";
    message.contentId = object.contentId ?? "";
    message.masterId = object.masterId ?? "0";
    message.masterUuid = object.masterUuid ?? "";
    message.campaignId = object.campaignId ?? "0";
    message.eventType = object.eventType ?? "";
    message.userId = object.userId ?? "";
    message.occurredAt = object.occurredAt ?? "0";
    message.payload = Object.entries(object.payload ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseContentEvent_PayloadEntry(): ContentEvent_PayloadEntry {
  return { key: "", value: "" };
}

export const ContentEvent_PayloadEntry: MessageFns<ContentEvent_PayloadEntry> = {
  encode(message: ContentEvent_PayloadEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentEvent_PayloadEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentEvent_PayloadEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentEvent_PayloadEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ContentEvent_PayloadEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentEvent_PayloadEntry>, I>>(base?: I): ContentEvent_PayloadEntry {
    return ContentEvent_PayloadEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentEvent_PayloadEntry>, I>>(object: I): ContentEvent_PayloadEntry {
    const message = createBaseContentEvent_PayloadEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateContentRequest(): CreateContentRequest {
  return { campaignId: "0", content: undefined };
}

export const CreateContentRequest: MessageFns<CreateContentRequest> = {
  encode(message: CreateContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.campaignId !== "0") {
      writer.uint32(8).int64(message.campaignId);
    }
    if (message.content !== undefined) {
      Content.encode(message.content, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = Content.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateContentRequest {
    return {
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
      content: isSet(object.content) ? Content.fromJSON(object.content) : undefined,
    };
  },

  toJSON(message: CreateContentRequest): unknown {
    const obj: any = {};
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    if (message.content !== undefined) {
      obj.content = Content.toJSON(message.content);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateContentRequest>, I>>(base?: I): CreateContentRequest {
    return CreateContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateContentRequest>, I>>(object: I): CreateContentRequest {
    const message = createBaseCreateContentRequest();
    message.campaignId = object.campaignId ?? "0";
    message.content = (object.content !== undefined && object.content !== null)
      ? Content.fromPartial(object.content)
      : undefined;
    return message;
  },
};

function createBaseGetContentRequest(): GetContentRequest {
  return { id: "" };
}

export const GetContentRequest: MessageFns<GetContentRequest> = {
  encode(message: GetContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContentRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetContentRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContentRequest>, I>>(base?: I): GetContentRequest {
    return GetContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContentRequest>, I>>(object: I): GetContentRequest {
    const message = createBaseGetContentRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdateContentRequest(): UpdateContentRequest {
  return { content: undefined };
}

export const UpdateContentRequest: MessageFns<UpdateContentRequest> = {
  encode(message: UpdateContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== undefined) {
      Content.encode(message.content, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = Content.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateContentRequest {
    return { content: isSet(object.content) ? Content.fromJSON(object.content) : undefined };
  },

  toJSON(message: UpdateContentRequest): unknown {
    const obj: any = {};
    if (message.content !== undefined) {
      obj.content = Content.toJSON(message.content);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateContentRequest>, I>>(base?: I): UpdateContentRequest {
    return UpdateContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateContentRequest>, I>>(object: I): UpdateContentRequest {
    const message = createBaseUpdateContentRequest();
    message.content = (object.content !== undefined && object.content !== null)
      ? Content.fromPartial(object.content)
      : undefined;
    return message;
  },
};

function createBaseDeleteContentRequest(): DeleteContentRequest {
  return { id: "" };
}

export const DeleteContentRequest: MessageFns<DeleteContentRequest> = {
  encode(message: DeleteContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteContentRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteContentRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteContentRequest>, I>>(base?: I): DeleteContentRequest {
    return DeleteContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteContentRequest>, I>>(object: I): DeleteContentRequest {
    const message = createBaseDeleteContentRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListContentRequest(): ListContentRequest {
  return {
    campaignId: "0",
    authorId: "",
    type: "",
    page: 0,
    pageSize: 0,
    tags: [],
    metadata: undefined,
    searchQuery: "",
    parentId: "",
    visibility: "",
  };
}

export const ListContentRequest: MessageFns<ListContentRequest> = {
  encode(message: ListContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.campaignId !== "0") {
      writer.uint32(8).int64(message.campaignId);
    }
    if (message.authorId !== "") {
      writer.uint32(18).string(message.authorId);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.page !== 0) {
      writer.uint32(32).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(40).int32(message.pageSize);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.searchQuery !== "") {
      writer.uint32(66).string(message.searchQuery);
    }
    if (message.parentId !== "") {
      writer.uint32(74).string(message.parentId);
    }
    if (message.visibility !== "") {
      writer.uint32(82).string(message.visibility);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.parentId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.visibility = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListContentRequest {
    return {
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
      authorId: isSet(object.authorId) ? globalThis.String(object.authorId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : "",
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
      visibility: isSet(object.visibility) ? globalThis.String(object.visibility) : "",
    };
  },

  toJSON(message: ListContentRequest): unknown {
    const obj: any = {};
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    if (message.authorId !== "") {
      obj.authorId = message.authorId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    if (message.visibility !== "") {
      obj.visibility = message.visibility;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListContentRequest>, I>>(base?: I): ListContentRequest {
    return ListContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListContentRequest>, I>>(object: I): ListContentRequest {
    const message = createBaseListContentRequest();
    message.campaignId = object.campaignId ?? "0";
    message.authorId = object.authorId ?? "";
    message.type = object.type ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.searchQuery = object.searchQuery ?? "";
    message.parentId = object.parentId ?? "";
    message.visibility = object.visibility ?? "";
    return message;
  },
};

function createBaseSearchContentRequest(): SearchContentRequest {
  return { campaignId: "0", query: "", tags: [], metadata: undefined, page: 0, pageSize: 0 };
}

export const SearchContentRequest: MessageFns<SearchContentRequest> = {
  encode(message: SearchContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.campaignId !== "0") {
      writer.uint32(8).int64(message.campaignId);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.page !== 0) {
      writer.uint32(40).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(48).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchContentRequest {
    return {
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: SearchContentRequest): unknown {
    const obj: any = {};
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchContentRequest>, I>>(base?: I): SearchContentRequest {
    return SearchContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchContentRequest>, I>>(object: I): SearchContentRequest {
    const message = createBaseSearchContentRequest();
    message.campaignId = object.campaignId ?? "0";
    message.query = object.query ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListContentResponse(): ListContentResponse {
  return { contents: [], total: 0 };
}

export const ListContentResponse: MessageFns<ListContentResponse> = {
  encode(message: ListContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.contents) {
      Content.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contents.push(Content.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListContentResponse {
    return {
      contents: globalThis.Array.isArray(object?.contents) ? object.contents.map((e: any) => Content.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListContentResponse): unknown {
    const obj: any = {};
    if (message.contents?.length) {
      obj.contents = message.contents.map((e) => Content.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListContentResponse>, I>>(base?: I): ListContentResponse {
    return ListContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListContentResponse>, I>>(object: I): ListContentResponse {
    const message = createBaseListContentResponse();
    message.contents = object.contents?.map((e) => Content.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseAddCommentRequest(): AddCommentRequest {
  return { contentId: "", authorId: "", body: "", metadata: undefined };
}

export const AddCommentRequest: MessageFns<AddCommentRequest> = {
  encode(message: AddCommentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentId !== "") {
      writer.uint32(10).string(message.contentId);
    }
    if (message.authorId !== "") {
      writer.uint32(18).string(message.authorId);
    }
    if (message.body !== "") {
      writer.uint32(26).string(message.body);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddCommentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.body = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddCommentRequest {
    return {
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      authorId: isSet(object.authorId) ? globalThis.String(object.authorId) : "",
      body: isSet(object.body) ? globalThis.String(object.body) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AddCommentRequest): unknown {
    const obj: any = {};
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.authorId !== "") {
      obj.authorId = message.authorId;
    }
    if (message.body !== "") {
      obj.body = message.body;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddCommentRequest>, I>>(base?: I): AddCommentRequest {
    return AddCommentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddCommentRequest>, I>>(object: I): AddCommentRequest {
    const message = createBaseAddCommentRequest();
    message.contentId = object.contentId ?? "";
    message.authorId = object.authorId ?? "";
    message.body = object.body ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseCommentResponse(): CommentResponse {
  return { comment: undefined };
}

export const CommentResponse: MessageFns<CommentResponse> = {
  encode(message: CommentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.comment !== undefined) {
      Comment.encode(message.comment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.comment = Comment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommentResponse {
    return { comment: isSet(object.comment) ? Comment.fromJSON(object.comment) : undefined };
  },

  toJSON(message: CommentResponse): unknown {
    const obj: any = {};
    if (message.comment !== undefined) {
      obj.comment = Comment.toJSON(message.comment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommentResponse>, I>>(base?: I): CommentResponse {
    return CommentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommentResponse>, I>>(object: I): CommentResponse {
    const message = createBaseCommentResponse();
    message.comment = (object.comment !== undefined && object.comment !== null)
      ? Comment.fromPartial(object.comment)
      : undefined;
    return message;
  },
};

function createBaseListCommentsRequest(): ListCommentsRequest {
  return { contentId: "", page: 0, pageSize: 0 };
}

export const ListCommentsRequest: MessageFns<ListCommentsRequest> = {
  encode(message: ListCommentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentId !== "") {
      writer.uint32(10).string(message.contentId);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCommentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCommentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCommentsRequest {
    return {
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: ListCommentsRequest): unknown {
    const obj: any = {};
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCommentsRequest>, I>>(base?: I): ListCommentsRequest {
    return ListCommentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCommentsRequest>, I>>(object: I): ListCommentsRequest {
    const message = createBaseListCommentsRequest();
    message.contentId = object.contentId ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseListCommentsResponse(): ListCommentsResponse {
  return { comments: [], total: 0 };
}

export const ListCommentsResponse: MessageFns<ListCommentsResponse> = {
  encode(message: ListCommentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.comments) {
      Comment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCommentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCommentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.comments.push(Comment.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCommentsResponse {
    return {
      comments: globalThis.Array.isArray(object?.comments) ? object.comments.map((e: any) => Comment.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListCommentsResponse): unknown {
    const obj: any = {};
    if (message.comments?.length) {
      obj.comments = message.comments.map((e) => Comment.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCommentsResponse>, I>>(base?: I): ListCommentsResponse {
    return ListCommentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCommentsResponse>, I>>(object: I): ListCommentsResponse {
    const message = createBaseListCommentsResponse();
    message.comments = object.comments?.map((e) => Comment.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseDeleteCommentRequest(): DeleteCommentRequest {
  return { commentId: "" };
}

export const DeleteCommentRequest: MessageFns<DeleteCommentRequest> = {
  encode(message: DeleteCommentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commentId !== "") {
      writer.uint32(10).string(message.commentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCommentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCommentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCommentRequest {
    return { commentId: isSet(object.commentId) ? globalThis.String(object.commentId) : "" };
  },

  toJSON(message: DeleteCommentRequest): unknown {
    const obj: any = {};
    if (message.commentId !== "") {
      obj.commentId = message.commentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCommentRequest>, I>>(base?: I): DeleteCommentRequest {
    return DeleteCommentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCommentRequest>, I>>(object: I): DeleteCommentRequest {
    const message = createBaseDeleteCommentRequest();
    message.commentId = object.commentId ?? "";
    return message;
  },
};

function createBaseDeleteCommentResponse(): DeleteCommentResponse {
  return { success: false };
}

export const DeleteCommentResponse: MessageFns<DeleteCommentResponse> = {
  encode(message: DeleteCommentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCommentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCommentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCommentResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteCommentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCommentResponse>, I>>(base?: I): DeleteCommentResponse {
    return DeleteCommentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCommentResponse>, I>>(object: I): DeleteCommentResponse {
    const message = createBaseDeleteCommentResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseAddReactionRequest(): AddReactionRequest {
  return { contentId: "", userId: "", reaction: "" };
}

export const AddReactionRequest: MessageFns<AddReactionRequest> = {
  encode(message: AddReactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentId !== "") {
      writer.uint32(10).string(message.contentId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.reaction !== "") {
      writer.uint32(26).string(message.reaction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddReactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddReactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reaction = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddReactionRequest {
    return {
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      reaction: isSet(object.reaction) ? globalThis.String(object.reaction) : "",
    };
  },

  toJSON(message: AddReactionRequest): unknown {
    const obj: any = {};
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.reaction !== "") {
      obj.reaction = message.reaction;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddReactionRequest>, I>>(base?: I): AddReactionRequest {
    return AddReactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddReactionRequest>, I>>(object: I): AddReactionRequest {
    const message = createBaseAddReactionRequest();
    message.contentId = object.contentId ?? "";
    message.userId = object.userId ?? "";
    message.reaction = object.reaction ?? "";
    return message;
  },
};

function createBaseReactionResponse(): ReactionResponse {
  return { contentId: "", reaction: "", count: 0 };
}

export const ReactionResponse: MessageFns<ReactionResponse> = {
  encode(message: ReactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentId !== "") {
      writer.uint32(10).string(message.contentId);
    }
    if (message.reaction !== "") {
      writer.uint32(18).string(message.reaction);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reaction = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReactionResponse {
    return {
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      reaction: isSet(object.reaction) ? globalThis.String(object.reaction) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: ReactionResponse): unknown {
    const obj: any = {};
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.reaction !== "") {
      obj.reaction = message.reaction;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReactionResponse>, I>>(base?: I): ReactionResponse {
    return ReactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReactionResponse>, I>>(object: I): ReactionResponse {
    const message = createBaseReactionResponse();
    message.contentId = object.contentId ?? "";
    message.reaction = object.reaction ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseListReactionsRequest(): ListReactionsRequest {
  return { contentId: "" };
}

export const ListReactionsRequest: MessageFns<ListReactionsRequest> = {
  encode(message: ListReactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentId !== "") {
      writer.uint32(10).string(message.contentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReactionsRequest {
    return { contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "" };
  },

  toJSON(message: ListReactionsRequest): unknown {
    const obj: any = {};
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListReactionsRequest>, I>>(base?: I): ListReactionsRequest {
    return ListReactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListReactionsRequest>, I>>(object: I): ListReactionsRequest {
    const message = createBaseListReactionsRequest();
    message.contentId = object.contentId ?? "";
    return message;
  },
};

function createBaseListReactionsResponse(): ListReactionsResponse {
  return { reactions: [] };
}

export const ListReactionsResponse: MessageFns<ListReactionsResponse> = {
  encode(message: ListReactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reactions) {
      ReactionResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reactions.push(ReactionResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReactionsResponse {
    return {
      reactions: globalThis.Array.isArray(object?.reactions)
        ? object.reactions.map((e: any) => ReactionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListReactionsResponse): unknown {
    const obj: any = {};
    if (message.reactions?.length) {
      obj.reactions = message.reactions.map((e) => ReactionResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListReactionsResponse>, I>>(base?: I): ListReactionsResponse {
    return ListReactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListReactionsResponse>, I>>(object: I): ListReactionsResponse {
    const message = createBaseListReactionsResponse();
    message.reactions = object.reactions?.map((e) => ReactionResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLogContentEventRequest(): LogContentEventRequest {
  return { event: undefined };
}

export const LogContentEventRequest: MessageFns<LogContentEventRequest> = {
  encode(message: LogContentEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      ContentEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogContentEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogContentEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = ContentEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogContentEventRequest {
    return { event: isSet(object.event) ? ContentEvent.fromJSON(object.event) : undefined };
  },

  toJSON(message: LogContentEventRequest): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = ContentEvent.toJSON(message.event);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogContentEventRequest>, I>>(base?: I): LogContentEventRequest {
    return LogContentEventRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogContentEventRequest>, I>>(object: I): LogContentEventRequest {
    const message = createBaseLogContentEventRequest();
    message.event = (object.event !== undefined && object.event !== null)
      ? ContentEvent.fromPartial(object.event)
      : undefined;
    return message;
  },
};

function createBaseLogContentEventResponse(): LogContentEventResponse {
  return { success: false };
}

export const LogContentEventResponse: MessageFns<LogContentEventResponse> = {
  encode(message: LogContentEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogContentEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogContentEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogContentEventResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: LogContentEventResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogContentEventResponse>, I>>(base?: I): LogContentEventResponse {
    return LogContentEventResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogContentEventResponse>, I>>(object: I): LogContentEventResponse {
    const message = createBaseLogContentEventResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseModerateContentRequest(): ModerateContentRequest {
  return { contentId: "", action: "", moderatorId: "", reason: "" };
}

export const ModerateContentRequest: MessageFns<ModerateContentRequest> = {
  encode(message: ModerateContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentId !== "") {
      writer.uint32(10).string(message.contentId);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.moderatorId !== "") {
      writer.uint32(26).string(message.moderatorId);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModerateContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModerateContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.moderatorId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModerateContentRequest {
    return {
      contentId: isSet(object.contentId) ? globalThis.String(object.contentId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      moderatorId: isSet(object.moderatorId) ? globalThis.String(object.moderatorId) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: ModerateContentRequest): unknown {
    const obj: any = {};
    if (message.contentId !== "") {
      obj.contentId = message.contentId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.moderatorId !== "") {
      obj.moderatorId = message.moderatorId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModerateContentRequest>, I>>(base?: I): ModerateContentRequest {
    return ModerateContentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModerateContentRequest>, I>>(object: I): ModerateContentRequest {
    const message = createBaseModerateContentRequest();
    message.contentId = object.contentId ?? "";
    message.action = object.action ?? "";
    message.moderatorId = object.moderatorId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseModerateContentResponse(): ModerateContentResponse {
  return { success: false, status: "" };
}

export const ModerateContentResponse: MessageFns<ModerateContentResponse> = {
  encode(message: ModerateContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModerateContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModerateContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModerateContentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: ModerateContentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModerateContentResponse>, I>>(base?: I): ModerateContentResponse {
    return ModerateContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModerateContentResponse>, I>>(object: I): ModerateContentResponse {
    const message = createBaseModerateContentResponse();
    message.success = object.success ?? false;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseContentResponse(): ContentResponse {
  return { content: undefined };
}

export const ContentResponse: MessageFns<ContentResponse> = {
  encode(message: ContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== undefined) {
      Content.encode(message.content, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = Content.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentResponse {
    return { content: isSet(object.content) ? Content.fromJSON(object.content) : undefined };
  },

  toJSON(message: ContentResponse): unknown {
    const obj: any = {};
    if (message.content !== undefined) {
      obj.content = Content.toJSON(message.content);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContentResponse>, I>>(base?: I): ContentResponse {
    return ContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContentResponse>, I>>(object: I): ContentResponse {
    const message = createBaseContentResponse();
    message.content = (object.content !== undefined && object.content !== null)
      ? Content.fromPartial(object.content)
      : undefined;
    return message;
  },
};

function createBaseDeleteContentResponse(): DeleteContentResponse {
  return { success: false };
}

export const DeleteContentResponse: MessageFns<DeleteContentResponse> = {
  encode(message: DeleteContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteContentResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteContentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteContentResponse>, I>>(base?: I): DeleteContentResponse {
    return DeleteContentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteContentResponse>, I>>(object: I): DeleteContentResponse {
    const message = createBaseDeleteContentResponse();
    message.success = object.success ?? false;
    return message;
  },
};

export interface ContentService {
  CreateContent(request: CreateContentRequest): Promise<ContentResponse>;
  GetContent(request: GetContentRequest): Promise<ContentResponse>;
  UpdateContent(request: UpdateContentRequest): Promise<ContentResponse>;
  DeleteContent(request: DeleteContentRequest): Promise<DeleteContentResponse>;
  ListContent(request: ListContentRequest): Promise<ListContentResponse>;
  SearchContent(request: SearchContentRequest): Promise<ListContentResponse>;
  AddComment(request: AddCommentRequest): Promise<CommentResponse>;
  ListComments(request: ListCommentsRequest): Promise<ListCommentsResponse>;
  DeleteComment(request: DeleteCommentRequest): Promise<DeleteCommentResponse>;
  AddReaction(request: AddReactionRequest): Promise<ReactionResponse>;
  ListReactions(request: ListReactionsRequest): Promise<ListReactionsResponse>;
  LogContentEvent(request: LogContentEventRequest): Promise<LogContentEventResponse>;
  /** Moderation hooks (stub) */
  ModerateContent(request: ModerateContentRequest): Promise<ModerateContentResponse>;
}

export const ContentServiceServiceName = "content.v1.ContentService";
export class ContentServiceClientImpl implements ContentService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ContentServiceServiceName;
    this.rpc = rpc;
    this.CreateContent = this.CreateContent.bind(this);
    this.GetContent = this.GetContent.bind(this);
    this.UpdateContent = this.UpdateContent.bind(this);
    this.DeleteContent = this.DeleteContent.bind(this);
    this.ListContent = this.ListContent.bind(this);
    this.SearchContent = this.SearchContent.bind(this);
    this.AddComment = this.AddComment.bind(this);
    this.ListComments = this.ListComments.bind(this);
    this.DeleteComment = this.DeleteComment.bind(this);
    this.AddReaction = this.AddReaction.bind(this);
    this.ListReactions = this.ListReactions.bind(this);
    this.LogContentEvent = this.LogContentEvent.bind(this);
    this.ModerateContent = this.ModerateContent.bind(this);
  }
  CreateContent(request: CreateContentRequest): Promise<ContentResponse> {
    const data = CreateContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateContent", data);
    return promise.then((data) => ContentResponse.decode(new BinaryReader(data)));
  }

  GetContent(request: GetContentRequest): Promise<ContentResponse> {
    const data = GetContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetContent", data);
    return promise.then((data) => ContentResponse.decode(new BinaryReader(data)));
  }

  UpdateContent(request: UpdateContentRequest): Promise<ContentResponse> {
    const data = UpdateContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateContent", data);
    return promise.then((data) => ContentResponse.decode(new BinaryReader(data)));
  }

  DeleteContent(request: DeleteContentRequest): Promise<DeleteContentResponse> {
    const data = DeleteContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteContent", data);
    return promise.then((data) => DeleteContentResponse.decode(new BinaryReader(data)));
  }

  ListContent(request: ListContentRequest): Promise<ListContentResponse> {
    const data = ListContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListContent", data);
    return promise.then((data) => ListContentResponse.decode(new BinaryReader(data)));
  }

  SearchContent(request: SearchContentRequest): Promise<ListContentResponse> {
    const data = SearchContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SearchContent", data);
    return promise.then((data) => ListContentResponse.decode(new BinaryReader(data)));
  }

  AddComment(request: AddCommentRequest): Promise<CommentResponse> {
    const data = AddCommentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddComment", data);
    return promise.then((data) => CommentResponse.decode(new BinaryReader(data)));
  }

  ListComments(request: ListCommentsRequest): Promise<ListCommentsResponse> {
    const data = ListCommentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListComments", data);
    return promise.then((data) => ListCommentsResponse.decode(new BinaryReader(data)));
  }

  DeleteComment(request: DeleteCommentRequest): Promise<DeleteCommentResponse> {
    const data = DeleteCommentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteComment", data);
    return promise.then((data) => DeleteCommentResponse.decode(new BinaryReader(data)));
  }

  AddReaction(request: AddReactionRequest): Promise<ReactionResponse> {
    const data = AddReactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddReaction", data);
    return promise.then((data) => ReactionResponse.decode(new BinaryReader(data)));
  }

  ListReactions(request: ListReactionsRequest): Promise<ListReactionsResponse> {
    const data = ListReactionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListReactions", data);
    return promise.then((data) => ListReactionsResponse.decode(new BinaryReader(data)));
  }

  LogContentEvent(request: LogContentEventRequest): Promise<LogContentEventResponse> {
    const data = LogContentEventRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LogContentEvent", data);
    return promise.then((data) => LogContentEventResponse.decode(new BinaryReader(data)));
  }

  ModerateContent(request: ModerateContentRequest): Promise<ModerateContentResponse> {
    const data = ModerateContentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ModerateContent", data);
    return promise.then((data) => ModerateContentResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
