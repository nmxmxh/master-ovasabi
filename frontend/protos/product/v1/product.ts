// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: product/v1/product.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Metadata } from "../../common/v1/metadata";

export const protobufPackage = "product.v1";

export enum ProductType {
  PRODUCT_TYPE_UNSPECIFIED = 0,
  PRODUCT_TYPE_PHYSICAL = 1,
  PRODUCT_TYPE_DIGITAL = 2,
  PRODUCT_TYPE_SERVICE = 3,
  PRODUCT_TYPE_SUBSCRIPTION = 4,
  UNRECOGNIZED = -1,
}

export function productTypeFromJSON(object: any): ProductType {
  switch (object) {
    case 0:
    case "PRODUCT_TYPE_UNSPECIFIED":
      return ProductType.PRODUCT_TYPE_UNSPECIFIED;
    case 1:
    case "PRODUCT_TYPE_PHYSICAL":
      return ProductType.PRODUCT_TYPE_PHYSICAL;
    case 2:
    case "PRODUCT_TYPE_DIGITAL":
      return ProductType.PRODUCT_TYPE_DIGITAL;
    case 3:
    case "PRODUCT_TYPE_SERVICE":
      return ProductType.PRODUCT_TYPE_SERVICE;
    case 4:
    case "PRODUCT_TYPE_SUBSCRIPTION":
      return ProductType.PRODUCT_TYPE_SUBSCRIPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductType.UNRECOGNIZED;
  }
}

export function productTypeToJSON(object: ProductType): string {
  switch (object) {
    case ProductType.PRODUCT_TYPE_UNSPECIFIED:
      return "PRODUCT_TYPE_UNSPECIFIED";
    case ProductType.PRODUCT_TYPE_PHYSICAL:
      return "PRODUCT_TYPE_PHYSICAL";
    case ProductType.PRODUCT_TYPE_DIGITAL:
      return "PRODUCT_TYPE_DIGITAL";
    case ProductType.PRODUCT_TYPE_SERVICE:
      return "PRODUCT_TYPE_SERVICE";
    case ProductType.PRODUCT_TYPE_SUBSCRIPTION:
      return "PRODUCT_TYPE_SUBSCRIPTION";
    case ProductType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProductStatus {
  PRODUCT_STATUS_UNSPECIFIED = 0,
  PRODUCT_STATUS_ACTIVE = 1,
  PRODUCT_STATUS_INACTIVE = 2,
  PRODUCT_STATUS_ARCHIVED = 3,
  UNRECOGNIZED = -1,
}

export function productStatusFromJSON(object: any): ProductStatus {
  switch (object) {
    case 0:
    case "PRODUCT_STATUS_UNSPECIFIED":
      return ProductStatus.PRODUCT_STATUS_UNSPECIFIED;
    case 1:
    case "PRODUCT_STATUS_ACTIVE":
      return ProductStatus.PRODUCT_STATUS_ACTIVE;
    case 2:
    case "PRODUCT_STATUS_INACTIVE":
      return ProductStatus.PRODUCT_STATUS_INACTIVE;
    case 3:
    case "PRODUCT_STATUS_ARCHIVED":
      return ProductStatus.PRODUCT_STATUS_ARCHIVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductStatus.UNRECOGNIZED;
  }
}

export function productStatusToJSON(object: ProductStatus): string {
  switch (object) {
    case ProductStatus.PRODUCT_STATUS_UNSPECIFIED:
      return "PRODUCT_STATUS_UNSPECIFIED";
    case ProductStatus.PRODUCT_STATUS_ACTIVE:
      return "PRODUCT_STATUS_ACTIVE";
    case ProductStatus.PRODUCT_STATUS_INACTIVE:
      return "PRODUCT_STATUS_INACTIVE";
    case ProductStatus.PRODUCT_STATUS_ARCHIVED:
      return "PRODUCT_STATUS_ARCHIVED";
    case ProductStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Product {
  id: string;
  masterId: string;
  masterUuid: string;
  name: string;
  description: string;
  type: ProductType;
  status: ProductStatus;
  tags: string[];
  variants: ProductVariant[];
  metadata?: Metadata | undefined;
  createdAt: string;
  updatedAt: string;
  mainImageUrl: string;
  galleryImageUrls: string[];
  ownerId: string;
  /** campaign/tenant context */
  campaignId: string;
}

export interface ProductVariant {
  id: string;
  productId: string;
  sku: string;
  name: string;
  price: number;
  currency: string;
  inventory: number;
  attributes: { [key: string]: string };
  isDefault: boolean;
  paymentType: string;
  compareAtPrice: number;
  createdAt: string;
  updatedAt: string;
  metadata?: Metadata | undefined;
}

export interface ProductVariant_AttributesEntry {
  key: string;
  value: string;
}

export interface CreateProductRequest {
  product?: Product | undefined;
}

export interface CreateProductResponse {
  product?: Product | undefined;
}

export interface UpdateProductRequest {
  product?: Product | undefined;
}

export interface UpdateProductResponse {
  product?: Product | undefined;
}

export interface DeleteProductRequest {
  productId: string;
}

export interface DeleteProductResponse {
  success: boolean;
}

export interface GetProductRequest {
  productId: string;
}

export interface GetProductResponse {
  product?: Product | undefined;
}

export interface ListProductsRequest {
  page: number;
  pageSize: number;
  ownerId: string;
  type: ProductType;
  status: ProductStatus;
  tags: string[];
  /** campaign/tenant context */
  campaignId: string;
}

export interface ListProductsResponse {
  products: Product[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface SearchProductsRequest {
  query: string;
  page: number;
  pageSize: number;
  tags: string[];
  type: ProductType;
  status: ProductStatus;
  /** campaign/tenant context */
  campaignId: string;
}

export interface SearchProductsResponse {
  products: Product[];
  totalCount: number;
  page: number;
  totalPages: number;
}

export interface UpdateInventoryRequest {
  variantId: string;
  delta: number;
}

export interface UpdateInventoryResponse {
  variant?: ProductVariant | undefined;
}

export interface ListProductVariantsRequest {
  productId: string;
}

export interface ListProductVariantsResponse {
  variants: ProductVariant[];
}

function createBaseProduct(): Product {
  return {
    id: "",
    masterId: "0",
    masterUuid: "",
    name: "",
    description: "",
    type: 0,
    status: 0,
    tags: [],
    variants: [],
    metadata: undefined,
    createdAt: "0",
    updatedAt: "0",
    mainImageUrl: "",
    galleryImageUrls: [],
    ownerId: "",
    campaignId: "0",
  };
}

export const Product: MessageFns<Product> = {
  encode(message: Product, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.masterId !== "0") {
      writer.uint32(16).int64(message.masterId);
    }
    if (message.masterUuid !== "") {
      writer.uint32(114).string(message.masterUuid);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    for (const v of message.tags) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.variants) {
      ProductVariant.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(74).fork()).join();
    }
    if (message.createdAt !== "0") {
      writer.uint32(80).int64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(88).int64(message.updatedAt);
    }
    if (message.mainImageUrl !== "") {
      writer.uint32(98).string(message.mainImageUrl);
    }
    for (const v of message.galleryImageUrls) {
      writer.uint32(106).string(v!);
    }
    if (message.ownerId !== "") {
      writer.uint32(122).string(message.ownerId);
    }
    if (message.campaignId !== "0") {
      writer.uint32(128).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.masterId = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.masterUuid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.variants.push(ProductVariant.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.createdAt = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.updatedAt = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.mainImageUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.galleryImageUrls.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      masterId: isSet(object.masterId) ? globalThis.String(object.masterId) : "0",
      masterUuid: isSet(object.masterUuid) ? globalThis.String(object.masterUuid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? productTypeFromJSON(object.type) : 0,
      status: isSet(object.status) ? productStatusFromJSON(object.status) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      variants: globalThis.Array.isArray(object?.variants)
        ? object.variants.map((e: any) => ProductVariant.fromJSON(e))
        : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "0",
      mainImageUrl: isSet(object.mainImageUrl) ? globalThis.String(object.mainImageUrl) : "",
      galleryImageUrls: globalThis.Array.isArray(object?.galleryImageUrls)
        ? object.galleryImageUrls.map((e: any) => globalThis.String(e))
        : [],
      ownerId: isSet(object.ownerId) ? globalThis.String(object.ownerId) : "",
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: Product): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.masterId !== "0") {
      obj.masterId = message.masterId;
    }
    if (message.masterUuid !== "") {
      obj.masterUuid = message.masterUuid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = productTypeToJSON(message.type);
    }
    if (message.status !== 0) {
      obj.status = productStatusToJSON(message.status);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => ProductVariant.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.createdAt !== "0") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "0") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.mainImageUrl !== "") {
      obj.mainImageUrl = message.mainImageUrl;
    }
    if (message.galleryImageUrls?.length) {
      obj.galleryImageUrls = message.galleryImageUrls;
    }
    if (message.ownerId !== "") {
      obj.ownerId = message.ownerId;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Product>, I>>(base?: I): Product {
    return Product.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Product>, I>>(object: I): Product {
    const message = createBaseProduct();
    message.id = object.id ?? "";
    message.masterId = object.masterId ?? "0";
    message.masterUuid = object.masterUuid ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.status = object.status ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.variants = object.variants?.map((e) => ProductVariant.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    message.mainImageUrl = object.mainImageUrl ?? "";
    message.galleryImageUrls = object.galleryImageUrls?.map((e) => e) || [];
    message.ownerId = object.ownerId ?? "";
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseProductVariant(): ProductVariant {
  return {
    id: "",
    productId: "",
    sku: "",
    name: "",
    price: 0,
    currency: "",
    inventory: 0,
    attributes: {},
    isDefault: false,
    paymentType: "",
    compareAtPrice: 0,
    createdAt: "0",
    updatedAt: "0",
    metadata: undefined,
  };
}

export const ProductVariant: MessageFns<ProductVariant> = {
  encode(message: ProductVariant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.sku !== "") {
      writer.uint32(26).string(message.sku);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.price !== 0) {
      writer.uint32(41).double(message.price);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.inventory !== 0) {
      writer.uint32(56).int32(message.inventory);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      ProductVariant_AttributesEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.isDefault !== false) {
      writer.uint32(72).bool(message.isDefault);
    }
    if (message.paymentType !== "") {
      writer.uint32(82).string(message.paymentType);
    }
    if (message.compareAtPrice !== 0) {
      writer.uint32(89).double(message.compareAtPrice);
    }
    if (message.createdAt !== "0") {
      writer.uint32(96).int64(message.createdAt);
    }
    if (message.updatedAt !== "0") {
      writer.uint32(104).int64(message.updatedAt);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductVariant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductVariant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sku = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.inventory = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = ProductVariant_AttributesEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.attributes[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.paymentType = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.compareAtPrice = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.createdAt = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.updatedAt = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductVariant {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      inventory: isSet(object.inventory) ? globalThis.Number(object.inventory) : 0,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      paymentType: isSet(object.paymentType) ? globalThis.String(object.paymentType) : "",
      compareAtPrice: isSet(object.compareAtPrice) ? globalThis.Number(object.compareAtPrice) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "0",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : "0",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ProductVariant): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.sku !== "") {
      obj.sku = message.sku;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.inventory !== 0) {
      obj.inventory = Math.round(message.inventory);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.paymentType !== "") {
      obj.paymentType = message.paymentType;
    }
    if (message.compareAtPrice !== 0) {
      obj.compareAtPrice = message.compareAtPrice;
    }
    if (message.createdAt !== "0") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "0") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductVariant>, I>>(base?: I): ProductVariant {
    return ProductVariant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductVariant>, I>>(object: I): ProductVariant {
    const message = createBaseProductVariant();
    message.id = object.id ?? "";
    message.productId = object.productId ?? "";
    message.sku = object.sku ?? "";
    message.name = object.name ?? "";
    message.price = object.price ?? 0;
    message.currency = object.currency ?? "";
    message.inventory = object.inventory ?? 0;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.isDefault = object.isDefault ?? false;
    message.paymentType = object.paymentType ?? "";
    message.compareAtPrice = object.compareAtPrice ?? 0;
    message.createdAt = object.createdAt ?? "0";
    message.updatedAt = object.updatedAt ?? "0";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseProductVariant_AttributesEntry(): ProductVariant_AttributesEntry {
  return { key: "", value: "" };
}

export const ProductVariant_AttributesEntry: MessageFns<ProductVariant_AttributesEntry> = {
  encode(message: ProductVariant_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductVariant_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductVariant_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductVariant_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ProductVariant_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProductVariant_AttributesEntry>, I>>(base?: I): ProductVariant_AttributesEntry {
    return ProductVariant_AttributesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProductVariant_AttributesEntry>, I>>(
    object: I,
  ): ProductVariant_AttributesEntry {
    const message = createBaseProductVariant_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateProductRequest(): CreateProductRequest {
  return { product: undefined };
}

export const CreateProductRequest: MessageFns<CreateProductRequest> = {
  encode(message: CreateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductRequest {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: CreateProductRequest): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductRequest>, I>>(base?: I): CreateProductRequest {
    return CreateProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductRequest>, I>>(object: I): CreateProductRequest {
    const message = createBaseCreateProductRequest();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseCreateProductResponse(): CreateProductResponse {
  return { product: undefined };
}

export const CreateProductResponse: MessageFns<CreateProductResponse> = {
  encode(message: CreateProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: CreateProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProductResponse>, I>>(base?: I): CreateProductResponse {
    return CreateProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProductResponse>, I>>(object: I): CreateProductResponse {
    const message = createBaseCreateProductResponse();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseUpdateProductRequest(): UpdateProductRequest {
  return { product: undefined };
}

export const UpdateProductRequest: MessageFns<UpdateProductRequest> = {
  encode(message: UpdateProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductRequest {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: UpdateProductRequest): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductRequest>, I>>(base?: I): UpdateProductRequest {
    return UpdateProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductRequest>, I>>(object: I): UpdateProductRequest {
    const message = createBaseUpdateProductRequest();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseUpdateProductResponse(): UpdateProductResponse {
  return { product: undefined };
}

export const UpdateProductResponse: MessageFns<UpdateProductResponse> = {
  encode(message: UpdateProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: UpdateProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateProductResponse>, I>>(base?: I): UpdateProductResponse {
    return UpdateProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateProductResponse>, I>>(object: I): UpdateProductResponse {
    const message = createBaseUpdateProductResponse();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseDeleteProductRequest(): DeleteProductRequest {
  return { productId: "" };
}

export const DeleteProductRequest: MessageFns<DeleteProductRequest> = {
  encode(message: DeleteProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: DeleteProductRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductRequest>, I>>(base?: I): DeleteProductRequest {
    return DeleteProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductRequest>, I>>(object: I): DeleteProductRequest {
    const message = createBaseDeleteProductRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseDeleteProductResponse(): DeleteProductResponse {
  return { success: false };
}

export const DeleteProductResponse: MessageFns<DeleteProductResponse> = {
  encode(message: DeleteProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProductResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteProductResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProductResponse>, I>>(base?: I): DeleteProductResponse {
    return DeleteProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProductResponse>, I>>(object: I): DeleteProductResponse {
    const message = createBaseDeleteProductResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetProductRequest(): GetProductRequest {
  return { productId: "" };
}

export const GetProductRequest: MessageFns<GetProductRequest> = {
  encode(message: GetProductRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: GetProductRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductRequest>, I>>(base?: I): GetProductRequest {
    return GetProductRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductRequest>, I>>(object: I): GetProductRequest {
    const message = createBaseGetProductRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseGetProductResponse(): GetProductResponse {
  return { product: undefined };
}

export const GetProductResponse: MessageFns<GetProductResponse> = {
  encode(message: GetProductResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProductResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProductResponse {
    return { product: isSet(object.product) ? Product.fromJSON(object.product) : undefined };
  },

  toJSON(message: GetProductResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProductResponse>, I>>(base?: I): GetProductResponse {
    return GetProductResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProductResponse>, I>>(object: I): GetProductResponse {
    const message = createBaseGetProductResponse();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    return message;
  },
};

function createBaseListProductsRequest(): ListProductsRequest {
  return { page: 0, pageSize: 0, ownerId: "", type: 0, status: 0, tags: [], campaignId: "0" };
}

export const ListProductsRequest: MessageFns<ListProductsRequest> = {
  encode(message: ListProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.ownerId !== "") {
      writer.uint32(26).string(message.ownerId);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    for (const v of message.tags) {
      writer.uint32(50).string(v!);
    }
    if (message.campaignId !== "0") {
      writer.uint32(56).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      ownerId: isSet(object.ownerId) ? globalThis.String(object.ownerId) : "",
      type: isSet(object.type) ? productTypeFromJSON(object.type) : 0,
      status: isSet(object.status) ? productStatusFromJSON(object.status) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: ListProductsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.ownerId !== "") {
      obj.ownerId = message.ownerId;
    }
    if (message.type !== 0) {
      obj.type = productTypeToJSON(message.type);
    }
    if (message.status !== 0) {
      obj.status = productStatusToJSON(message.status);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductsRequest>, I>>(base?: I): ListProductsRequest {
    return ListProductsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductsRequest>, I>>(object: I): ListProductsRequest {
    const message = createBaseListProductsRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.ownerId = object.ownerId ?? "";
    message.type = object.type ?? 0;
    message.status = object.status ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseListProductsResponse(): ListProductsResponse {
  return { products: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const ListProductsResponse: MessageFns<ListProductsResponse> = {
  encode(message: ListProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductsResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: ListProductsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductsResponse>, I>>(base?: I): ListProductsResponse {
    return ListProductsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductsResponse>, I>>(object: I): ListProductsResponse {
    const message = createBaseListProductsResponse();
    message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseSearchProductsRequest(): SearchProductsRequest {
  return { query: "", page: 0, pageSize: 0, tags: [], type: 0, status: 0, campaignId: "0" };
}

export const SearchProductsRequest: MessageFns<SearchProductsRequest> = {
  encode(message: SearchProductsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    for (const v of message.tags) {
      writer.uint32(34).string(v!);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.campaignId !== "0") {
      writer.uint32(56).int64(message.campaignId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchProductsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.campaignId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchProductsRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      type: isSet(object.type) ? productTypeFromJSON(object.type) : 0,
      status: isSet(object.status) ? productStatusFromJSON(object.status) : 0,
      campaignId: isSet(object.campaignId) ? globalThis.String(object.campaignId) : "0",
    };
  },

  toJSON(message: SearchProductsRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.type !== 0) {
      obj.type = productTypeToJSON(message.type);
    }
    if (message.status !== 0) {
      obj.status = productStatusToJSON(message.status);
    }
    if (message.campaignId !== "0") {
      obj.campaignId = message.campaignId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchProductsRequest>, I>>(base?: I): SearchProductsRequest {
    return SearchProductsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchProductsRequest>, I>>(object: I): SearchProductsRequest {
    const message = createBaseSearchProductsRequest();
    message.query = object.query ?? "";
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.type = object.type ?? 0;
    message.status = object.status ?? 0;
    message.campaignId = object.campaignId ?? "0";
    return message;
  },
};

function createBaseSearchProductsResponse(): SearchProductsResponse {
  return { products: [], totalCount: 0, page: 0, totalPages: 0 };
}

export const SearchProductsResponse: MessageFns<SearchProductsResponse> = {
  encode(message: SearchProductsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.totalPages !== 0) {
      writer.uint32(32).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchProductsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchProductsResponse {
    return {
      products: globalThis.Array.isArray(object?.products) ? object.products.map((e: any) => Product.fromJSON(e)) : [],
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: SearchProductsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchProductsResponse>, I>>(base?: I): SearchProductsResponse {
    return SearchProductsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchProductsResponse>, I>>(object: I): SearchProductsResponse {
    const message = createBaseSearchProductsResponse();
    message.products = object.products?.map((e) => Product.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.page = object.page ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseUpdateInventoryRequest(): UpdateInventoryRequest {
  return { variantId: "", delta: 0 };
}

export const UpdateInventoryRequest: MessageFns<UpdateInventoryRequest> = {
  encode(message: UpdateInventoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantId !== "") {
      writer.uint32(10).string(message.variantId);
    }
    if (message.delta !== 0) {
      writer.uint32(16).int32(message.delta);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInventoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInventoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.delta = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInventoryRequest {
    return {
      variantId: isSet(object.variantId) ? globalThis.String(object.variantId) : "",
      delta: isSet(object.delta) ? globalThis.Number(object.delta) : 0,
    };
  },

  toJSON(message: UpdateInventoryRequest): unknown {
    const obj: any = {};
    if (message.variantId !== "") {
      obj.variantId = message.variantId;
    }
    if (message.delta !== 0) {
      obj.delta = Math.round(message.delta);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateInventoryRequest>, I>>(base?: I): UpdateInventoryRequest {
    return UpdateInventoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateInventoryRequest>, I>>(object: I): UpdateInventoryRequest {
    const message = createBaseUpdateInventoryRequest();
    message.variantId = object.variantId ?? "";
    message.delta = object.delta ?? 0;
    return message;
  },
};

function createBaseUpdateInventoryResponse(): UpdateInventoryResponse {
  return { variant: undefined };
}

export const UpdateInventoryResponse: MessageFns<UpdateInventoryResponse> = {
  encode(message: UpdateInventoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variant !== undefined) {
      ProductVariant.encode(message.variant, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInventoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInventoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variant = ProductVariant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInventoryResponse {
    return { variant: isSet(object.variant) ? ProductVariant.fromJSON(object.variant) : undefined };
  },

  toJSON(message: UpdateInventoryResponse): unknown {
    const obj: any = {};
    if (message.variant !== undefined) {
      obj.variant = ProductVariant.toJSON(message.variant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateInventoryResponse>, I>>(base?: I): UpdateInventoryResponse {
    return UpdateInventoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateInventoryResponse>, I>>(object: I): UpdateInventoryResponse {
    const message = createBaseUpdateInventoryResponse();
    message.variant = (object.variant !== undefined && object.variant !== null)
      ? ProductVariant.fromPartial(object.variant)
      : undefined;
    return message;
  },
};

function createBaseListProductVariantsRequest(): ListProductVariantsRequest {
  return { productId: "" };
}

export const ListProductVariantsRequest: MessageFns<ListProductVariantsRequest> = {
  encode(message: ListProductVariantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductVariantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductVariantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductVariantsRequest {
    return { productId: isSet(object.productId) ? globalThis.String(object.productId) : "" };
  },

  toJSON(message: ListProductVariantsRequest): unknown {
    const obj: any = {};
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductVariantsRequest>, I>>(base?: I): ListProductVariantsRequest {
    return ListProductVariantsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductVariantsRequest>, I>>(object: I): ListProductVariantsRequest {
    const message = createBaseListProductVariantsRequest();
    message.productId = object.productId ?? "";
    return message;
  },
};

function createBaseListProductVariantsResponse(): ListProductVariantsResponse {
  return { variants: [] };
}

export const ListProductVariantsResponse: MessageFns<ListProductVariantsResponse> = {
  encode(message: ListProductVariantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.variants) {
      ProductVariant.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProductVariantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProductVariantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variants.push(ProductVariant.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProductVariantsResponse {
    return {
      variants: globalThis.Array.isArray(object?.variants)
        ? object.variants.map((e: any) => ProductVariant.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListProductVariantsResponse): unknown {
    const obj: any = {};
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => ProductVariant.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProductVariantsResponse>, I>>(base?: I): ListProductVariantsResponse {
    return ListProductVariantsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProductVariantsResponse>, I>>(object: I): ListProductVariantsResponse {
    const message = createBaseListProductVariantsResponse();
    message.variants = object.variants?.map((e) => ProductVariant.fromPartial(e)) || [];
    return message;
  },
};

export interface ProductService {
  CreateProduct(request: CreateProductRequest): Promise<CreateProductResponse>;
  UpdateProduct(request: UpdateProductRequest): Promise<UpdateProductResponse>;
  DeleteProduct(request: DeleteProductRequest): Promise<DeleteProductResponse>;
  GetProduct(request: GetProductRequest): Promise<GetProductResponse>;
  ListProducts(request: ListProductsRequest): Promise<ListProductsResponse>;
  SearchProducts(request: SearchProductsRequest): Promise<SearchProductsResponse>;
  UpdateInventory(request: UpdateInventoryRequest): Promise<UpdateInventoryResponse>;
  ListProductVariants(request: ListProductVariantsRequest): Promise<ListProductVariantsResponse>;
}

export const ProductServiceServiceName = "product.v1.ProductService";
export class ProductServiceClientImpl implements ProductService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ProductServiceServiceName;
    this.rpc = rpc;
    this.CreateProduct = this.CreateProduct.bind(this);
    this.UpdateProduct = this.UpdateProduct.bind(this);
    this.DeleteProduct = this.DeleteProduct.bind(this);
    this.GetProduct = this.GetProduct.bind(this);
    this.ListProducts = this.ListProducts.bind(this);
    this.SearchProducts = this.SearchProducts.bind(this);
    this.UpdateInventory = this.UpdateInventory.bind(this);
    this.ListProductVariants = this.ListProductVariants.bind(this);
  }
  CreateProduct(request: CreateProductRequest): Promise<CreateProductResponse> {
    const data = CreateProductRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateProduct", data);
    return promise.then((data) => CreateProductResponse.decode(new BinaryReader(data)));
  }

  UpdateProduct(request: UpdateProductRequest): Promise<UpdateProductResponse> {
    const data = UpdateProductRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateProduct", data);
    return promise.then((data) => UpdateProductResponse.decode(new BinaryReader(data)));
  }

  DeleteProduct(request: DeleteProductRequest): Promise<DeleteProductResponse> {
    const data = DeleteProductRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteProduct", data);
    return promise.then((data) => DeleteProductResponse.decode(new BinaryReader(data)));
  }

  GetProduct(request: GetProductRequest): Promise<GetProductResponse> {
    const data = GetProductRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProduct", data);
    return promise.then((data) => GetProductResponse.decode(new BinaryReader(data)));
  }

  ListProducts(request: ListProductsRequest): Promise<ListProductsResponse> {
    const data = ListProductsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListProducts", data);
    return promise.then((data) => ListProductsResponse.decode(new BinaryReader(data)));
  }

  SearchProducts(request: SearchProductsRequest): Promise<SearchProductsResponse> {
    const data = SearchProductsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SearchProducts", data);
    return promise.then((data) => SearchProductsResponse.decode(new BinaryReader(data)));
  }

  UpdateInventory(request: UpdateInventoryRequest): Promise<UpdateInventoryResponse> {
    const data = UpdateInventoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateInventory", data);
    return promise.then((data) => UpdateInventoryResponse.decode(new BinaryReader(data)));
  }

  ListProductVariants(request: ListProductVariantsRequest): Promise<ListProductVariantsResponse> {
    const data = ListProductVariantsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListProductVariants", data);
    return promise.then((data) => ListProductVariantsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
